/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MetadataMenu
});
module.exports = __toCommonJS(main_exports);

// env.js
window.DEBUG = false;

// main.ts
var import_obsidian83 = require("obsidian");

// src/commands/paletteCommands.ts
var import_obsidian59 = require("obsidian");

// src/components/NoteFields.ts
var import_obsidian58 = require("obsidian");

// node_modules/crypto-random-string/core.js
var urlSafeCharacters = [..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~"];
var numericCharacters = [..."0123456789"];
var distinguishableCharacters = [..."CDEHKMPRTUWXY012458"];
var asciiPrintableCharacters = [..."!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"];
var alphanumericCharacters = [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"];
var readUInt16LE = (uInt8Array, offset2) => uInt8Array[offset2] + (uInt8Array[offset2 + 1] << 8);
var generateForCustomCharacters = (length, characters, randomBytes) => {
  const characterCount = characters.length;
  const maxValidSelector = Math.floor(65536 / characterCount) * characterCount - 1;
  const entropyLength = 2 * Math.ceil(1.1 * length);
  let string2 = "";
  let stringLength = 0;
  while (stringLength < length) {
    const entropy = randomBytes(entropyLength);
    let entropyPosition = 0;
    while (entropyPosition < entropyLength && stringLength < length) {
      const entropyValue = readUInt16LE(entropy, entropyPosition);
      entropyPosition += 2;
      if (entropyValue > maxValidSelector) {
        continue;
      }
      string2 += characters[entropyValue % characterCount];
      stringLength++;
    }
  }
  return string2;
};
var generateForCustomCharactersAsync = async (length, characters, randomBytesAsync) => {
  const characterCount = characters.length;
  const maxValidSelector = Math.floor(65536 / characterCount) * characterCount - 1;
  const entropyLength = 2 * Math.ceil(1.1 * length);
  let string2 = "";
  let stringLength = 0;
  while (stringLength < length) {
    const entropy = await randomBytesAsync(entropyLength);
    let entropyPosition = 0;
    while (entropyPosition < entropyLength && stringLength < length) {
      const entropyValue = readUInt16LE(entropy, entropyPosition);
      entropyPosition += 2;
      if (entropyValue > maxValidSelector) {
        continue;
      }
      string2 += characters[entropyValue % characterCount];
      stringLength++;
    }
  }
  return string2;
};
var allowedTypes = /* @__PURE__ */ new Set([
  void 0,
  "hex",
  "base64",
  "url-safe",
  "numeric",
  "distinguishable",
  "ascii-printable",
  "alphanumeric"
]);
var createGenerator = (generateForCustomCharacters2, specialRandomBytes2, randomBytes) => ({ length, type, characters }) => {
  if (!(length >= 0 && Number.isFinite(length))) {
    throw new TypeError("Expected a `length` to be a non-negative finite number");
  }
  if (type !== void 0 && characters !== void 0) {
    throw new TypeError("Expected either `type` or `characters`");
  }
  if (characters !== void 0 && typeof characters !== "string") {
    throw new TypeError("Expected `characters` to be string");
  }
  if (!allowedTypes.has(type)) {
    throw new TypeError(`Unknown type: ${type}`);
  }
  if (type === void 0 && characters === void 0) {
    type = "hex";
  }
  if (type === "hex" || type === void 0 && characters === void 0) {
    return specialRandomBytes2(Math.ceil(length * 0.5), "hex", length);
  }
  if (type === "base64") {
    return specialRandomBytes2(Math.ceil(length * 0.75), "base64", length);
  }
  if (type === "url-safe") {
    return generateForCustomCharacters2(length, urlSafeCharacters, randomBytes);
  }
  if (type === "numeric") {
    return generateForCustomCharacters2(length, numericCharacters, randomBytes);
  }
  if (type === "distinguishable") {
    return generateForCustomCharacters2(length, distinguishableCharacters, randomBytes);
  }
  if (type === "ascii-printable") {
    return generateForCustomCharacters2(length, asciiPrintableCharacters, randomBytes);
  }
  if (type === "alphanumeric") {
    return generateForCustomCharacters2(length, alphanumericCharacters, randomBytes);
  }
  if (characters.length === 0) {
    throw new TypeError("Expected `characters` string length to be greater than or equal to 1");
  }
  if (characters.length > 65536) {
    throw new TypeError("Expected `characters` string length to be less or equal to 65536");
  }
  return generateForCustomCharacters2(length, characters, randomBytes);
};
function createStringGenerator(specialRandomBytes2, randomBytes) {
  return createGenerator(generateForCustomCharacters, specialRandomBytes2, randomBytes);
}
function createAsyncStringGenerator(specialRandomBytesAsync, randomBytesAsync) {
  return createGenerator(generateForCustomCharactersAsync, specialRandomBytesAsync, randomBytesAsync);
}

// node_modules/crypto-random-string/browser.js
var toHex = (uInt8Array) => [...uInt8Array].map((byte) => byte.toString(16).padStart(2, "0")).join("");
var toBase64 = (uInt8Array) => btoa(String.fromCodePoint(...uInt8Array));
var maxEntropy = 65536;
function getRandomValues(byteLength) {
  const generatedBytes = new Uint8Array(byteLength);
  for (let totalGeneratedBytes = 0; totalGeneratedBytes < byteLength; totalGeneratedBytes += maxEntropy) {
    generatedBytes.set(
      crypto.getRandomValues(new Uint8Array(Math.min(maxEntropy, byteLength - totalGeneratedBytes))),
      totalGeneratedBytes
    );
  }
  return generatedBytes;
}
function specialRandomBytes(byteLength, type, length) {
  const generatedBytes = getRandomValues(byteLength);
  const convert = type === "hex" ? toHex : toBase64;
  return convert(generatedBytes).slice(0, length);
}
var browser_default = createStringGenerator(specialRandomBytes, getRandomValues);
var cryptoRandomStringAsync = createAsyncStringGenerator(specialRandomBytes, getRandomValues);

// src/fields/fieldManagers/InputField.ts
var import_obsidian34 = require("obsidian");

// src/modals/fields/InputModal.ts
var import_obsidian33 = require("obsidian");

// src/note/note.ts
var import_obsidian = require("obsidian");

// src/types/lookupTypes.ts
var BuiltinSummarizing = /* @__PURE__ */ ((BuiltinSummarizing2) => {
  BuiltinSummarizing2["Sum"] = "Sum";
  BuiltinSummarizing2["Count"] = "Count";
  BuiltinSummarizing2["CountAll"] = "CountAll";
  BuiltinSummarizing2["Average"] = "Average";
  BuiltinSummarizing2["Max"] = "Max";
  BuiltinSummarizing2["Min"] = "Min";
  return BuiltinSummarizing2;
})(BuiltinSummarizing || {});
var BuiltinSummarizingFunctionDescription = {
  "Sum": "Returns the sum of <{{summarizedFieldName}}> fields in the pages matching the query",
  "Count": "Counts all pages matching the query where <{{summarizedFieldName}}> is non empty",
  "CountAll": "Counts all pages matching the query (including empty fields)",
  "Average": "Returns the average value of <{{summarizedFieldName}}> fields in the pages matching the query",
  "Max": "Returns the maximum value of <{{summarizedFieldName}}> fields in the pages matching the query",
  "Min": "Returns the minimum value of <{{summarizedFieldName}}> fields in the pages matching the query"
};
var BuiltinSummarizingFunction = {
  "Sum": 'const i=0;const sum = pages.reduce((p, c) => p + c["{{summarizedFieldName}}"], i); return sum',
  "CountAll": "return pages.length",
  "Count": 'return pages.filter(p => !!p["{{summarizedFieldName}}"]).length',
  "Average": 'const i=0.0;const sum = pages.reduce((p, c) => p + c["{{summarizedFieldName}}"], i); return sum / pages.length',
  "Max": 'return pages.reduce((p,c) => p["{{summarizedFieldName}}"] >= c["{{summarizedFieldName}}"] ? p : c)["{{summarizedFieldName}}"]',
  "Min": 'return pages.reduce((p,c) => p["{{summarizedFieldName}}"]!==null && p["{{summarizedFieldName}}"] <= c["{{summarizedFieldName}}"] ? p : c)["{{summarizedFieldName}}"]'
};
var Type = /* @__PURE__ */ ((Type3) => {
  Type3["LinksList"] = "LinksList";
  Type3["LinksBulletList"] = "LinksBulletList";
  Type3["BuiltinSummarizing"] = "BuiltinSummarizing";
  Type3["CustomList"] = "CustomList";
  Type3["CustomBulletList"] = "CustomBulletList";
  Type3["CustomSummarizing"] = "CustomSummarizing";
  return Type3;
})(Type || {});
var ShortDescription = {
  "LinksList": "Inline list of links",
  "LinksBulletList": "Bullet list of links",
  "BuiltinSummarizing": "",
  "CustomList": "Inline list of customized links",
  "CustomBulletList": "Bullet list of customized links",
  "CustomSummarizing": "Custom summarizing function"
};
var Description = {
  "LinksList": "List of related links displayed inline",
  "LinksBulletList": "List of related links displayed below the field",
  "BuiltinSummarizing": "Built-in summarizing function",
  "CustomList": "Custom list rendering function displayed inline",
  "CustomBulletList": "Custom list rendering function displayed below the field",
  "CustomSummarizing": "Custom summarizing function"
};
var OptionLabel = {
  "LinksList": "",
  "LinksBulletList": "",
  "BuiltinSummarizing": "Built-in summarize function:",
  "CustomList": "Query's results' list's rendering function:",
  "CustomBulletList": "Query's results' list's rendering function:",
  "CustomSummarizing": "Query's results' list's summarizing function:"
};
var OptionSubLabel = {
  "LinksList": "",
  "LinksBulletList": "",
  "BuiltinSummarizing": "",
  "CustomList": `function(page) { return <function using "page">; }`,
  "CustomBulletList": `function(page) { return <function using "page">; }`,
  "CustomSummarizing": `function(page) { return <function using "page">; }`
};
var Helper = {
  "LinksList": "",
  "LinksBulletList": "",
  "BuiltinSummarizing": "",
  "CustomList": 'Javascript string, the "page" (dataview page type) variable is available\nexample 1: page.file.name\nexample 2: `${page.file.name} of gender ${page.gender}`',
  "CustomBulletList": 'Javascript string, the "page" (dataview page type) variable is available\nexample 1: page.file.name\nexample 2: `${page.file.name} of gender ${page.gender}`',
  "CustomSummarizing": 'Javascript string, the "pages" (dataview pages type) variable is available\nexample: \nconst initialValue = 0;\nconst sumWithInitial = pages.reduce(\n    (previousValue, currentValue) => previousValue + currentValue,\n    initialValue\n);\nreturn `${sumWithInitial}`\n'
};
var Default = {
  "LinksList": "",
  "LinksBulletList": "",
  "BuiltinSummarizing": "Count" /* Count */,
  "CustomList": "page.file.name",
  "CustomBulletList": "page.file.name",
  "CustomSummarizing": "return pages.length"
};
var bulletListLookupTypes = [
  "LinksBulletList" /* LinksBulletList */,
  "CustomBulletList" /* CustomBulletList */
];
var statusIcon = {
  "mayHaveChanged": "refresh-ccw",
  "error": "file-warning",
  "upToDate": "file-check",
  "changed": "refresh-ccw"
};

// src/utils/parser.ts
var genericFieldRegex = "(?<inQuote>>*(\\s+)?)?(?<inList>- )?(?<preSpacer>(\\s+)?)?(?<startStyle>[_\\*~`]*)(?<attribute>[-\\w\\p{Letter}\\p{Emoji_Presentation}\\s]*)(?<endStyle>[_\\*~`]*)(?<beforeSeparatorSpacer>\\s*)";
var fullLineRegex = new RegExp(`^\\s*${genericFieldRegex}::\\s*(?<values>.*)?`, "u");
var inSentenceRegexBrackets = new RegExp(`\\[${genericFieldRegex}::\\s*(?<values>[^\\]]+)?\\]`, "gu");
var inSentenceRegexPar = new RegExp(`\\(${genericFieldRegex}::\\s*(?<values>[^\\)]+)?\\)`, "gu");
var LinkRegex = new RegExp(`\\[\\[(?<target>[^\\|]*)(\\|)?(?<alias>.*)?\\]\\]`);
var getLink = (linkText, source) => {
  var _a, _b, _c, _d;
  const fR = (_a = `${linkText}`) == null ? void 0 : _a.match(LinkRegex);
  if ((_b = fR == null ? void 0 : fR.groups) == null ? void 0 : _b.target) {
    const path = (_d = app.metadataCache.getFirstLinkpathDest((_c = fR == null ? void 0 : fR.groups) == null ? void 0 : _c.target, source.path)) == null ? void 0 : _d.path;
    if (path) {
      return {
        path,
        alias: fR.groups.alias
      };
    }
  }
  return;
};
var extractLinks = (rawContent) => {
  var _a, _b;
  const links = [];
  const linksIterator = rawContent.matchAll(/\[\[(?:[^\]]*)\]\]/g);
  let rawLink;
  while (rawLink = (_b = (_a = linksIterator.next()) == null ? void 0 : _a.value) == null ? void 0 : _b[0]) {
    links.push(rawLink);
  }
  return links;
};
var encodeLink = (value) => {
  return value ? value.replace(/\[\[/g, "\u20AC\xF9").replace(/\]\]/g, "\xF9\u20AC") : value;
};
var decodeLink = (value) => {
  return value ? value.replace(/€ù/gu, "[[").replace(/ù€/gu, "]]") : value;
};
var frontMatterLineField = (line) => {
  const frontMatterRegex = new RegExp(/(?<indentation>\s*)(?<list>-\s)?(?<attribute>[-\w\p{Letter}\p{Emoji_Presentation}\s]*[^\s])(?<beforeSeparatorSpacer>\s*):(?<afterSeparatorSpacer>\s*)(?<values>.*)/u);
  const fR = line.match(frontMatterRegex);
  if (fR == null ? void 0 : fR.groups) {
    return {
      attribute: fR == null ? void 0 : fR.groups.attribute,
      indentation: fR == null ? void 0 : fR.groups.indentation,
      list: fR == null ? void 0 : fR.groups.list,
      beforeSeparatorSpacer: fR == null ? void 0 : fR.groups.beforeSeparatorSpacer,
      afterSeparatorSpacer: fR == null ? void 0 : fR.groups.afterSeparatorSpacer,
      values: fR == null ? void 0 : fR.groups.values
    };
  }
  return {
    attribute: void 0,
    indentation: void 0,
    list: void 0,
    beforeSeparatorSpacer: void 0,
    afterSeparatorSpacer: void 0,
    values: void 0
  };
};
var getLineFields = (line) => {
  const fields = [];
  const fR = line.match(fullLineRegex);
  if (fR == null ? void 0 : fR.groups) {
    const { attribute, inList, inQuote, preSpacer, startStyle, endStyle, beforeSeparatorSpacer, afterSeparatorSpacer, values } = fR.groups;
    fields.push({ attribute, values: values || "", index: 0, length: line.length, inList, inQuote, preSpacer, startStyle, endStyle, beforeSeparatorSpacer, afterSeparatorSpacer });
  } else {
    const sRBk = encodeLink(line).matchAll(inSentenceRegexBrackets);
    let next = sRBk.next();
    while (!next.done) {
      if (next.value.groups) {
        const { attribute, values, inList, inQuote, preSpacer, startStyle, endStyle, beforeSeparatorSpacer, afterSeparatorSpacer } = next.value.groups;
        fields.push({ attribute, values: decodeLink(values), index: next.value.index || 0, length: next.value[0].length, inList, inQuote, preSpacer, startStyle, endStyle, beforeSeparatorSpacer, afterSeparatorSpacer, enclosureType: "brackets" });
      }
      next = sRBk.next();
    }
    const sRBc = encodeLink(line).matchAll(inSentenceRegexPar);
    next = sRBc.next();
    while (!next.done) {
      if (next.value.groups) {
        const { attribute, values, inList, inQuote, preSpacer, startStyle, endStyle, beforeSeparatorSpacer, afterSeparatorSpacer } = next.value.groups;
        fields.push({ attribute, values: decodeLink(values), index: next.value.index || 0, length: next.value[0].length, inList, inQuote, preSpacer, startStyle, endStyle, beforeSeparatorSpacer, afterSeparatorSpacer, enclosureType: "parenthesis" });
      }
      next = sRBc.next();
    }
  }
  fields.sort((a, b) => {
    if (a.index < b.index)
      return -1;
    if (a.index > b.index)
      return 1;
    return 0;
  });
  return fields;
};

// src/types/dataviewTypes.ts
var FieldStyle = /* @__PURE__ */ ((FieldStyle2) => {
  FieldStyle2["Code"] = "Code";
  FieldStyle2["Italic"] = "Italic";
  FieldStyle2["Bold"] = "Bold";
  FieldStyle2["Strikethrough"] = "Strikethrough";
  return FieldStyle2;
})(FieldStyle || {});
var FieldHTMLTagMap = {
  "Code": "pre",
  "Italic": "i",
  "Bold": "b",
  "Strikethrough": "s"
};
var FieldStyleLabel = {
  "code": "Code",
  "italic": "Italic",
  "bold": "Bold",
  "strikethrough": "Strikethrough"
};
var FieldStyleKey = {
  "Code": "code",
  "Italic": "italic",
  "Bold": "bold",
  "Strikethrough": "strikethrough"
};
var FieldStyleSyntax = {
  "Code": "`",
  "Italic": "*",
  "Bold": "**",
  "Strikethrough": "~~"
};
var buildStartStyle = (style) => {
  let startStyle = "";
  FieldStyleLabel.Italic;
  if (style[FieldStyleKey.Italic])
    startStyle += FieldStyleSyntax.Italic;
  if (style[FieldStyleKey.Strikethrough])
    startStyle += FieldStyleSyntax.Strikethrough;
  if (style[FieldStyleKey.Bold])
    startStyle += FieldStyleSyntax.Bold;
  if (style[FieldStyleKey.Code])
    startStyle += FieldStyleSyntax.Code;
  return startStyle;
};
var buildEndStyle = (style) => {
  let endStyle = "";
  if (style[FieldStyleKey.Code])
    endStyle += FieldStyleSyntax.Code;
  if (style[FieldStyleKey.Bold])
    endStyle += FieldStyleSyntax.Bold;
  if (style[FieldStyleKey.Strikethrough])
    endStyle += FieldStyleSyntax.Strikethrough;
  if (style[FieldStyleKey.Italic])
    endStyle += FieldStyleSyntax.Italic;
  return endStyle;
};

// src/fields/ExistingField.ts
var ExistingField = class {
  constructor(field, value, indexedId, indexedPath) {
    this.field = field;
    this.value = value;
    this.indexedId = indexedId;
    this.indexedPath = indexedPath;
    this.name = this.field.name;
    this.indexedId = this.indexedId || this.field.id;
    this.indexedPath = this.indexedPath || this.indexedId;
  }
  isRoot() {
    return this.indexedId === this.indexedPath;
  }
  async getChildrenFields(plugin, file) {
    if (!Array.isArray(this.value))
      return [];
    const items = [];
    await Promise.all(this.value.map(async (value, index) => {
      const upperPath = `${this.indexedPath}[${index}]`;
      const eFields = (await Note.getExistingFields(plugin, file)).filter((eF) => eF.indexedPath && Field_default.upperPath(eF.indexedPath) === upperPath);
      items.push({
        fields: eFields,
        indexInList: index,
        indexedPath: upperPath
      });
    }));
    return items;
  }
};

// src/note/lineNode.ts
var separator = {
  "yaml": ":",
  "inline": "::"
};
var enclosure = {
  "brackets": {
    start: "[",
    end: "]"
  },
  "parenthesis": {
    start: "(",
    end: ")"
  }
};
var LineNode = class {
  constructor(plugin, line, rawContent = "", indentationLevel = 0, index = 0, field, value, parsedField2, blockquote = "") {
    this.plugin = plugin;
    this.line = line;
    this.rawContent = rawContent;
    this.indentationLevel = indentationLevel;
    this.index = index;
    this.field = field;
    this.value = value;
    this.parsedField = parsedField2;
    this.blockquote = blockquote;
    this.buildDecoratedFieldName = () => {
      if (!this.field)
        return "";
      let level = this.field.getIndentationLevel(this);
      switch (this.line.position) {
        case "yaml":
          const _ = this.field.isFirstItemOfObjectList(this) ? "- " : "";
          return `${"  ".repeat(level)}${_}${this.field.name}`;
        case "inline": {
          const targetStartStyle = buildStartStyle(this.field.style || {});
          const targetEndStyle = buildEndStyle(this.field.style || {});
          return `${this.blockquote}${"  ".repeat(this.indentationLevel)}${this.line.isNewListItem ? "- " : ""}${targetStartStyle}${this.field.name}${targetEndStyle}`;
        }
      }
    };
    this.buildIndentedListItem = (value, shift = 0) => {
      if (!this.field)
        return "";
      const ancestors = this.field.getAncestors();
      const level = ancestors.length;
      return `${"  ".repeat(level + 1 + shift)}- ${value}`;
    };
    this.removeIndentedListItems = () => {
      if (!this.field || !(this.field.type === "JSON" /* JSON */ || this.field.type === "YAML" /* YAML */ || this.field.type === "Lookup" /* Lookup */ || this.field.type === "Multi" /* Multi */ || this.field.type === "MultiFile" /* MultiFile */ || this.field.type === "Canvas" /* Canvas */ || this.field.type === "CanvasGroup" /* CanvasGroup */ || this.field.type === "CanvasGroupLink" /* CanvasGroupLink */))
        return;
      if (this.line.position === "inline" && this.field.type !== "Lookup" /* Lookup */)
        return;
      const indentLevel = this.field.getAncestors().length;
      const nextLines = this.line.note.lines.filter((_line) => _line.number > this.line.number);
      for (const line of nextLines) {
        if (line.rawContent.startsWith("  ".repeat(indentLevel + 1))) {
          line.removeLineFromNote();
        } else {
          break;
        }
      }
    };
    if (this.line.shouldParse) {
      const nodeRegex = new RegExp(/(?<blockquote>\>*)(?<indentation>\s*)(?<list>-\s)?(?<value>.*)/);
      const parsedContent = this.rawContent.match(nodeRegex);
      this.defineLinePrefixAttributes(parsedContent);
      this.defineExistingFieldsAndValues(parsedContent);
    }
    this.line.nodes.push(this);
  }
  defineLinePrefixAttributes(parsedContent) {
    if (parsedContent == null ? void 0 : parsedContent.groups) {
      if (parsedContent.groups.indentation) {
        this.indentationLevel = parsedContent.groups.indentation.length / 2;
        if (parsedContent.groups.list) {
          this.indentationLevel += 1;
        }
      }
      this.line.isNewListItem = !!parsedContent.groups.list;
      this.blockquote = parsedContent.groups.blockquote || "";
    }
    this.line.indentationLevel = this.indentationLevel;
    if (this.indentationLevel) {
      const parentLine = this.line.note.lines.filter(
        (line) => line.number < this.line.number && line.indentationLevel < this.line.indentationLevel
      ).last();
      this.line.parentLine = parentLine;
    }
  }
  defineExistingFieldsAndValues(parsedContent) {
    var _a;
    const frontmatter = this.line.note.frontmatter || {};
    const field = this.field;
    switch (this.line.position) {
      case "yaml":
        {
          const { attribute: yamlAttr, values: value } = frontMatterLineField(this.rawContent);
          if (!yamlAttr && this.line.isNewListItem) {
            const parentLine = this.line.parentLine;
            const parentNode = parentLine == null ? void 0 : parentLine.nodes[0];
            const parentField = parentNode == null ? void 0 : parentNode.field;
            if ((parentField == null ? void 0 : parentField.type) === "ObjectList" /* ObjectList */ || (parentField == null ? void 0 : parentField.type) === "Lookup" /* Lookup */ && bulletListLookupTypes.includes(parentField.options.outputType)) {
              const objectListLines = parentLine.objectListLines;
              objectListLines.push([this.line]);
              const index = objectListLines.length - 1;
              this.indexedId = "";
              this.indexedPath = `${parentNode == null ? void 0 : parentNode.indexedPath}[${index}]`;
              this.value = "";
            }
          }
          for (const field2 of this.line.note.fields) {
            if (yamlAttr === field2.name) {
              let indexedId = field2.id;
              if (this.line.parentLine) {
                const parentNode = this.line.parentLine.nodes[0];
                const parentField = parentNode.field;
                if (parentField) {
                  const parentIndexedId = (_a = this.line.note.existingFields.find((eF) => eF.field.id === parentField.id)) == null ? void 0 : _a.indexedId;
                  indexedId = `${parentIndexedId}____${field2.id}` || field2.id;
                } else {
                  indexedId = field2.id;
                }
              } else {
                indexedId = field2.id;
              }
              if (field2.path && indexedId !== `${field2.path}____${field2.id}`)
                continue;
              this.indexedId = indexedId;
              const existingField = new ExistingField(field2, this.value, this.indexedId);
              if (field2.path) {
                const parentLine = this.line.parentLine;
                const parentNode = parentLine == null ? void 0 : parentLine.nodes[0];
                const parentField = parentNode == null ? void 0 : parentNode.field;
                if ((parentField == null ? void 0 : parentField.id) === field2.path.split("____").last()) {
                  this.field = field2;
                  if (this.field && (parentField == null ? void 0 : parentField.type) === "ObjectList" /* ObjectList */) {
                    const objectListLines = parentLine.objectListLines;
                    if (this.line.isNewListItem) {
                      objectListLines.push([this.line]);
                    } else {
                      const lastObject = objectListLines.last();
                      lastObject == null ? void 0 : lastObject.push(this.line);
                    }
                    const index = objectListLines.length - 1;
                    this.indexedId = `${this.field.id}`;
                    this.indexedPath = `${parentNode == null ? void 0 : parentNode.indexedPath}[${index}]____${this.field.id}`;
                  } else {
                    this.indexedId = `${this.field.id}`;
                    this.indexedPath = `${parentNode == null ? void 0 : parentNode.indexedPath}____${this.field.id}`;
                  }
                  this.value = Field_default.getValueFromIndexedPath(this.field, this.line.note.frontmatter, this.indexedPath);
                  existingField.value = this.value;
                  existingField.indexedId = this.indexedId;
                  existingField.indexedPath = this.indexedPath;
                  this.line.note.existingFields.push(existingField);
                  break;
                } else if (!parentField) {
                  this.field = field2;
                  this.indexedPath = this.field.getIndexedPath(this);
                } else {
                  break;
                }
              } else if (field2.id === indexedId) {
                this.field = field2;
                this.indexedPath = this.field.getIndexedPath(this);
                this.value = frontmatter[field2.name];
                existingField.value = this.value;
                this.line.note.existingFields.push(existingField);
                break;
              }
            }
          }
          if (yamlAttr === this.plugin.settings.fileClassAlias) {
            const fileClasses = [...this.plugin.fieldIndex.fileClassesName.keys()].sort();
            const fileClassField = new Field_default(this.plugin, yamlAttr, fileClasses);
            fileClassField.type = "Select" /* Select */;
            fileClassField.id = `fileclass-field-${this.plugin.settings.fileClassAlias}`;
            this.field = fileClassField;
            this.indexedPath = fileClassField.id;
            this.value = value;
            const existingField = new ExistingField(fileClassField, value, this.field.id);
            this.line.note.existingFields.push(existingField);
          }
        }
        break;
      case "inline":
        {
          if (field && !frontmatterOnlyTypes.includes(field.type)) {
            const existingField = new ExistingField(field, this.value, field.id);
            this.indexedId = field.id;
            this.indexedPath = field.getIndexedPath(this);
            this.line.note.existingFields.push(existingField);
          } else if (this.line.isNewListItem) {
            const parentLine = this.line.parentLine;
            const parentNode = parentLine == null ? void 0 : parentLine.nodes[0];
            const parentField = parentNode == null ? void 0 : parentNode.field;
            if (parentField && (parentField == null ? void 0 : parentField.type) === "Lookup" /* Lookup */ && bulletListLookupTypes.includes(parentField.options.outputType)) {
              const objectListLines = parentLine.objectListLines;
              objectListLines.push([this.line]);
              this.indexedId = "";
              this.value = "";
              const eF = parentLine.note.getExistingFieldForIndexedPath(parentField.id);
              if (eF) {
                if ((parsedContent == null ? void 0 : parsedContent.groups) && parsedContent.groups.value) {
                  eF.value = [...eF.value || [], parsedContent.groups.value];
                }
              }
            }
          }
        }
        break;
    }
  }
  wrapField(content) {
    if (this.parsedField) {
      const enclosureType = this.parsedField.enclosureType;
      if (enclosureType) {
        const start2 = enclosure[enclosureType].start;
        const end2 = enclosure[enclosureType].end;
        return `${start2}${content}${end2}`;
      }
    }
    return content;
  }
  createFieldNodeContent(field, value, location, asList = false, asBlockquote = false) {
    const _ = separator[location];
    this.field = field;
    let content;
    if (this.field) {
      const fieldHeader = this.buildDecoratedFieldName();
      const newValue = this.line.note.renderFieldValue(this.field, value, location);
      this.removeIndentedListItems();
      if (Array.isArray(newValue)) {
        if (this.field.getDisplay() === "asList" /* asList */ || this.field.type === "Lookup" /* Lookup */ && bulletListLookupTypes.includes(this.field.options.outputType)) {
          content = `${fieldHeader}${_}`;
          newValue.filter((v) => !!v).reverse().forEach((item, i) => {
            const newItemLine = new Line(this.plugin, this.line.note, location, "", this.line.number + 1);
            new LineNode(this.plugin, newItemLine, this.buildIndentedListItem(item));
            newItemLine.renderLine(asList, asBlockquote);
          });
        } else {
          content = `${fieldHeader}${_} [${newValue.join(", ")}]`;
        }
      } else {
        content = `${fieldHeader}${_} ${newValue}`;
        if (this.field.type === "ObjectList" /* ObjectList */) {
          const newItemLine = new Line(this.plugin, this.line.note, location, "", this.line.number + 1);
          new LineNode(this.plugin, newItemLine, this.buildIndentedListItem("", 1));
          newItemLine.renderLine(asList, asBlockquote);
        }
      }
    } else {
      content = `${field.name}${_} ${value}`;
    }
    if (location === "inline") {
      this.rawContent = this.wrapField(content);
    } else {
      this.rawContent = content;
    }
  }
};

// src/note/line.ts
var Line = class {
  constructor(plugin, note, position, rawContent = "", number, indentationLevel = 0, shouldParse = true) {
    this.plugin = plugin;
    this.note = note;
    this.position = position;
    this.rawContent = rawContent;
    this.number = number;
    this.indentationLevel = indentationLevel;
    this.shouldParse = shouldParse;
    this.nodes = [];
    this.objectListLines = [];
    this.isNewListItem = false;
    this.buildNodes();
    this.insertLineInNote();
  }
  buildNodes() {
    if (!(this.position === "yaml") && this.plugin.settings.frontmatterOnly) {
      new LineNode(this.plugin, this, this.rawContent);
      return;
    }
    if (this.note.codeBlocksLines.includes(this.number))
      this.shouldParse = false;
    if (!(this.position === "yaml") && !this.note.prefixedLines.includes(this.number) && !this.note.inlineFieldsLines.includes(this.number))
      this.shouldParse = false;
    if (!this.shouldParse) {
      new LineNode(this.plugin, this, this.rawContent);
      return;
    }
    switch (this.position) {
      case "yaml":
        new LineNode(this.plugin, this, this.rawContent);
        break;
      case "inline":
        const fields = getLineFields(this.rawContent);
        const nodesIndexes = [0];
        for (const field of fields) {
          const fieldIndex = field.index;
          const nextNodeIndex = field.index + field.length;
          if (nodesIndexes.indexOf(fieldIndex) === -1)
            nodesIndexes.push(fieldIndex);
          nodesIndexes.push(nextNodeIndex);
        }
        for (const index of nodesIndexes) {
          const parsedField2 = fields.find((_field) => _field.index === index);
          if (parsedField2) {
            const start2 = parsedField2.index;
            const end2 = start2 + parsedField2.length;
            const _field = this.note.getFieldFromNameAndPath(parsedField2.attribute);
            const field = _field && !frontmatterOnlyTypes.includes(_field.type) ? _field : void 0;
            new LineNode(this.plugin, this, this.rawContent.slice(start2, end2), 0, index, field, parsedField2.values, parsedField2);
          } else {
            const nextIndex = nodesIndexes[nodesIndexes.indexOf(index) + 1] || this.rawContent.length;
            const content = this.rawContent.slice(index, nextIndex);
            if (content)
              new LineNode(this.plugin, this, content, 0, index);
          }
        }
        break;
    }
  }
  getParentLineWithField() {
    if (this.parentLine) {
      if (!this.parentLine.nodes.some((node) => !!node.field)) {
        return this.parentLine.getParentLineWithField();
      } else {
        return this.parentLine;
      }
    } else {
      if (this.nodes.some((node) => !!node.field))
        return this;
    }
  }
  removeLineFromNote() {
    for (const _line of this.note.lines) {
      if (_line.number && _line.number >= this.number) {
        _line.number -= 1;
      }
    }
    this.nodes = [];
    this.note.lines.remove(this);
  }
  getLastChildLine() {
    let lastChildLine = this;
    for (const line of this.note.lines.filter((_l) => _l.number > this.number)) {
      if (line.indentationLevel === 0)
        break;
      if (line.indentationLevel > this.indentationLevel || line.indentationLevel === this.indentationLevel && !line.isNewListItem) {
        lastChildLine = line;
      } else {
        break;
      }
    }
    return lastChildLine;
  }
  insertLineInNote() {
    for (const _line of this.note.lines) {
      if (_line.number && _line.number >= this.number) {
        _line.number += 1;
      }
    }
    this.note.lines.splice(this.number, 0, this);
  }
  renderLine(asList = false, asBlockquote = false) {
    const rawContent = this.nodes.map((node) => node.rawContent).join("");
    this.rawContent = `${asBlockquote ? ">" : ""}${asList ? "- " : ""}${rawContent}`;
  }
};

// src/note/note.ts
var Note = class {
  constructor(plugin, file) {
    this.plugin = plugin;
    this.file = file;
    this.lines = [];
    this.fields = [];
    this.existingFields = [];
    this.codeBlocksLines = [];
    this.inlineFieldsLines = [];
    this.prefixedLines = [];
    this.renderMultiFields = (rawValue, itemRendering) => {
      const values = rawValue.replace(/(\,\s+)/g, ",").split(",").filter((v) => !!v).map((value) => itemRendering(value));
      return values.length ? values : "";
    };
    this.createLine = (value, position, lineNumber, field, asList = false, asBlockquote = false) => {
      const newLine = new Line(this.plugin, this, position, "", lineNumber);
      const newNode = new LineNode(this.plugin, newLine);
      if (field)
        newNode.createFieldNodeContent(field, value, position);
      newLine.renderLine(asList, asBlockquote);
    };
    this.fields = this.plugin.fieldIndex.filesFields.get(this.file.path) || [];
  }
  getField(id) {
    return this.fields.find((field) => field.id === id);
  }
  getFieldFromNameAndPath(name, path = "") {
    return this.fields.find((field) => field.name === name && field.path === path);
  }
  renderValueString(_rawValue, fieldType, indentationLevel = 0) {
    if (_rawValue) {
      if (_rawValue.startsWith("[[")) {
        return `"${_rawValue}"`;
      } else if (_rawValue.startsWith("#")) {
        return `${_rawValue}`;
      } else if (fieldType && rawObjectTypes.includes(fieldType)) {
        const indentation = `
${"  ".repeat(indentationLevel + 1)}`;
        return `${indentation}${_rawValue.split("\n").join(indentation)}`;
      } else {
        return (0, import_obsidian.parseYaml)(_rawValue);
      }
      ;
    } else {
      return "";
    }
  }
  renderFieldValue(field, rawValue, location) {
    const type = field == null ? void 0 : field.type;
    const indentationLevel = (field == null ? void 0 : field.path) ? field.path.split("____").length : 0;
    switch (location) {
      case "yaml":
        switch (type) {
          case "Lookup" /* Lookup */:
            return this.renderMultiFields(rawValue, (item) => this.renderValueString(item, type, indentationLevel));
          case "Multi" /* Multi */:
            return this.renderMultiFields(rawValue, (item) => this.renderValueString(item, type, indentationLevel));
          case "MultiFile" /* MultiFile */:
            return this.renderMultiFields(rawValue, (item) => `"${item}"`);
          case "Canvas" /* Canvas */:
            return this.renderMultiFields(rawValue, (item) => item ? `"${item}"` : "");
          case "CanvasGroup" /* CanvasGroup */:
            return this.renderMultiFields(rawValue, (item) => this.renderValueString(item, type, indentationLevel));
          case "CanvasGroupLink" /* CanvasGroupLink */:
            return this.renderMultiFields(rawValue, (item) => item ? `"${item}"` : "");
          case void 0:
            if ([...ReservedMultiAttributes, this.plugin.settings.fileClassAlias].includes(field.name)) {
              return this.renderMultiFields(rawValue, (item) => `${item}`);
            } else {
              return this.renderValueString(rawValue, type, indentationLevel);
            }
            ;
          default:
            return this.renderValueString(rawValue, type, indentationLevel);
        }
      case "inline":
        switch (type) {
          case "Lookup" /* Lookup */: {
            if (field && bulletListLookupTypes.includes(field.options.outputType)) {
              return this.renderMultiFields(rawValue, (item) => item);
            } else {
              return rawValue;
            }
          }
          case "JSON" /* JSON */:
            return JSON.stringify(JSON.parse(rawValue || "{}"));
          case "YAML" /* YAML */: {
            const fm = new FieldManager["YAML" /* YAML */](this.plugin, field);
            return fm.dumpValue(rawValue);
          }
          default:
            return rawValue;
        }
    }
  }
  buildSections(content) {
    var _a, _b;
    const yamlLines = [];
    let inFrontmatter = false;
    let inStartingBlankLines = false;
    let frontmatterStart;
    let frontmatterEnd;
    let startsWithText = false;
    let previousLineIsCode = false;
    for (const [i, rawLine] of content.split("\n").entries()) {
      if (frontmatterEnd === void 0) {
        if (!inFrontmatter) {
          if (rawLine.trim() === "")
            inStartingBlankLines = true;
          else if (!((_a = this.frontmatterPosition) == null ? void 0 : _a.end.line) && rawLine !== "---")
            startsWithText = true;
        }
        if (!startsWithText) {
          if (!inFrontmatter && !((_b = this.frontmatterPosition) == null ? void 0 : _b.end.line) && rawLine === "---" && (inStartingBlankLines || i === 0)) {
            inFrontmatter = true;
            inStartingBlankLines = false;
            frontmatterStart = { line: i };
          } else if (inFrontmatter) {
            if (rawLine === "---") {
              inFrontmatter = false;
              frontmatterEnd = { line: i };
            } else {
              yamlLines.push(rawLine);
            }
          }
        }
      }
      if (!inFrontmatter) {
        if (this.plugin.settings.frontmatterOnly)
          break;
        if (rawLine.startsWith("```")) {
          this.codeBlocksLines.push(i);
          previousLineIsCode = !previousLineIsCode;
        } else if (previousLineIsCode) {
          this.codeBlocksLines.push(i);
        } else {
          if (rawLine.includes("::"))
            this.inlineFieldsLines.push(i);
          if ([" ", "-", ">", "*", "~", "_", "`"].some((prefix) => rawLine.startsWith(prefix)))
            this.prefixedLines.push(i);
        }
      }
    }
    try {
      this.frontmatter = yamlLines.length ? (0, import_obsidian.parseYaml)(yamlLines.join("\n")) : void 0;
      if (frontmatterStart && frontmatterEnd)
        this.frontmatterPosition = {
          start: frontmatterStart,
          end: frontmatterEnd
        };
    } catch (error) {
      this.frontmatterPosition = void 0;
    }
  }
  async build() {
    const content = await this.plugin.app.vault.read(this.file);
    const lines = content.split("\n");
    this.buildSections(content);
    const frontmatterEnd = this.frontmatterEnd();
    for (const [i, rawLine] of lines.entries()) {
      const position = !!frontmatterEnd && i <= frontmatterEnd ? "yaml" : "inline";
      new Line(this.plugin, this, position, rawLine, i);
    }
  }
  getExistingFieldForIndexedPath(indexedPath) {
    return this.existingFields.find((eF) => eF.indexedPath === indexedPath);
  }
  getNodeForIndexedPath(indexedPath) {
    for (const line of this.lines) {
      const node = line.nodes.find((_node) => _node.indexedPath === indexedPath);
      if (node)
        return node;
    }
    return void 0;
  }
  getNodeAtPosition(position) {
    var _a;
    const { ch: cursor, line: lineNumber } = position;
    const nodes = ((_a = this.lines.find((line) => line.number === lineNumber)) == null ? void 0 : _a.nodes) || [];
    nodes.sort((a, b) => a.index - b.index);
    for (const node of nodes) {
      if (node.index <= cursor && cursor <= node.rawContent.length + node.index)
        return node;
    }
    return;
  }
  frontmatterEnd() {
    var _a;
    return (_a = this.frontmatterPosition) == null ? void 0 : _a.end.line;
  }
  initFrontmatter() {
    new Line(this.plugin, this, "yaml", "---", 0);
    new Line(this.plugin, this, "yaml", "---", 0);
    this.frontmatter = {};
    this.frontmatterPosition = { start: { line: 0 }, end: { line: 1 } };
  }
  insertField(indexedPath, payload, lineNumber, asList = false, asBlockquote = false) {
    var _a, _b, _c, _d, _e;
    const upperPath = Field_default.upperIndexedPathObjectPath(indexedPath);
    const { id, index } = Field_default.getIdAndIndex(indexedPath.split("____").last());
    const { id: upperFieldId, index: upperFieldIndex } = Field_default.getIdAndIndex(upperPath.split("____").last());
    if (lineNumber === -1 && !this.frontmatter)
      this.initFrontmatter();
    if (id.startsWith("fileclass-field")) {
      const fR = id.match(/fileclass-field-(?<fileClassAlias>.*)/);
      if ((_a = fR == null ? void 0 : fR.groups) == null ? void 0 : _a.fileClassAlias) {
        const content = `${fR.groups.fileClassAlias}: ${payload.value}`;
        const newLine = new Line(this.plugin, this, "yaml", content, 1);
        newLine.renderLine(asList, asBlockquote);
      }
    } else if (id.startsWith("new-field-")) {
      const frontmatterEnd = this.frontmatterEnd();
      const position = frontmatterEnd && (lineNumber || this.lines.length) <= frontmatterEnd ? "yaml" : "inline";
      const _ = position === "yaml" ? ":" : "::";
      const fR = id.match(/new-field-(?<fieldName>.*)/);
      if ((_b = fR == null ? void 0 : fR.groups) == null ? void 0 : _b.fieldName) {
        const content = `${fR.groups.fieldName}${_} ${payload.value}`;
        const newLine = new Line(this.plugin, this, position, content, lineNumber || this.lines.length);
        newLine.renderLine(asList, asBlockquote);
      }
    } else {
      if (upperFieldIndex) {
        const i = parseInt(upperFieldIndex);
        const parentFieldIndexedPath = upperPath.replace(/\[\w+\]$/, "");
        const parentNode = this.getNodeForIndexedPath(parentFieldIndexedPath);
        if (!parentNode) {
          new import_obsidian.Notice("A parent field is missing, this field can't be added");
          return;
        }
        const field = this.getField(id);
        const lastItemLine = parentNode.line.objectListLines[i].last();
        if (lastItemLine) {
          if (/-(\s+)?$/.test(((_c = parentNode.line.objectListLines[i].last()) == null ? void 0 : _c.rawContent) || "") && field) {
            const node = lastItemLine.nodes[0];
            node.createFieldNodeContent(field, payload.value, "yaml");
            node.line.renderLine(asList, asBlockquote);
          } else {
            const lastChildLine = lastItemLine.getLastChildLine();
            this.createLine(payload.value, "yaml", lastChildLine ? lastChildLine.number + 1 : 1, field, asList, asBlockquote);
          }
        }
      } else {
        const field = this.getField(id);
        if (!field)
          return;
        if (frontmatterOnlyTypes.includes(field.type) && !this.frontmatter)
          this.initFrontmatter();
        const frontmatterEnd = this.frontmatterEnd();
        let insertLineNumber = (lineNumber ? Math.max(lineNumber, 0) : void 0) || frontmatterEnd || ((_d = this.lines.last()) == null ? void 0 : _d.number) || 0;
        if (frontmatterOnlyTypes.includes(field.type))
          insertLineNumber = frontmatterEnd;
        const position = frontmatterEnd && insertLineNumber <= frontmatterEnd ? "yaml" : "inline";
        if (field.type === "ObjectList" /* ObjectList */) {
          const node = this.getNodeForIndexedPath(upperPath);
          if (node) {
            const newItemLine = new Line(this.plugin, node.line.note, position, "", node.line.number + 1);
            const shift = /^(\s+)-(\s+)?(.*)/.test(node.rawContent) ? 1 : 0;
            new LineNode(this.plugin, newItemLine, node.buildIndentedListItem("", shift));
            newItemLine.renderLine(asList, asBlockquote);
          } else {
            const objectListHeaderLine = new Line(this.plugin, this, position, `${field.name}:`, insertLineNumber);
            objectListHeaderLine.renderLine();
          }
        } else {
          const parentField = this.existingFields.find((eF) => eF.indexedPath === upperPath);
          if ((parentField == null ? void 0 : parentField.field.type) === "Object" /* Object */) {
            const parentLine = (_e = this.getNodeForIndexedPath(upperPath)) == null ? void 0 : _e.line;
            const lastChildLine = parentLine == null ? void 0 : parentLine.getLastChildLine();
            this.createLine(payload.value, "yaml", lastChildLine ? lastChildLine.number + 1 : 1, field, asList, asBlockquote);
          } else {
            this.createLine(payload.value, position, insertLineNumber, field, asList, asBlockquote);
          }
        }
      }
    }
  }
  async removeObject(indexedPath) {
    const nodes = this.lines.map((_l) => _l.nodes.filter((_n) => {
      var _a;
      return (_a = _n.indexedPath) == null ? void 0 : _a.startsWith(indexedPath);
    })).flat(Infinity);
    nodes.map((_n) => _n.line.removeLineFromNote());
    await this.plugin.app.vault.modify(this.file, this.renderNote());
  }
  async createOrUpdateFields(fields, lineNumber, asList = false, asBlockquote = false) {
    fields.forEach((field) => {
      const node = this.getNodeForIndexedPath(field.id);
      if (node && node.field) {
        node.createFieldNodeContent(node.field, field.payload.value, node.line.position, asList, asBlockquote);
        node.line.renderLine(asList, asBlockquote);
      } else {
        this.insertField(field.id, field.payload, lineNumber, asList, asBlockquote);
      }
    });
    await this.plugin.app.vault.modify(this.file, this.renderNote());
  }
  renderNote() {
    return this.lines.map((line) => line.rawContent).join("\n");
  }
  static async buildNote(plugin, file) {
    const note = new Note(plugin, file);
    await note.build();
    return note;
  }
  static async getExistingFields(plugin, file) {
    const note = await Note.buildNote(plugin, file);
    return note.existingFields;
  }
  static async getExistingFieldForIndexedPath(plugin, file, indexedPath) {
    const eFs = await Note.getExistingFields(plugin, file);
    return eFs.find((eF) => eF.indexedPath === indexedPath);
  }
};

// src/utils/fileUtils.ts
var import_obsidian2 = require("obsidian");
function resolve_tfolder(plugin, folder_str) {
  folder_str = (0, import_obsidian2.normalizePath)(folder_str);
  const folder = plugin.app.vault.getAbstractFileByPath(folder_str);
  if (!folder) {
    throw new Error(`Folder "${folder_str}" doesn't exist`);
  }
  if (!(folder instanceof import_obsidian2.TFolder)) {
    throw new Error(`${folder_str} is a file, not a folder`);
  }
  return folder;
}
function get_tfiles_from_folder(plugin, folder_str) {
  const folder = resolve_tfolder(plugin, folder_str);
  const files = [];
  import_obsidian2.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian2.TFile) {
      files.push(file);
    }
  });
  files.sort((a, b) => {
    return a.basename.localeCompare(b.basename);
  });
  return files;
}
function getFileFromFileOrPath(plugin, fileOrFilePath) {
  let file;
  if (fileOrFilePath instanceof import_obsidian2.TFile) {
    file = fileOrFilePath;
  } else {
    const _file = plugin.app.vault.getAbstractFileByPath(fileOrFilePath);
    if (_file instanceof import_obsidian2.TFile && _file.extension == "md") {
      file = _file;
    } else {
      throw Error("path doesn't correspond to a proper file");
    }
  }
  return file;
}
function getFrontmatterPosition(plugin, file) {
  var _a;
  const cache = plugin.app.metadataCache.getFileCache(file);
  if (cache) {
    if (cache.frontmatterPosition) {
      return cache.frontmatterPosition;
    } else if (cache.frontmatter) {
      return cache.frontmatter.position;
    } else {
      const firstSection = (_a = cache.sections) == null ? void 0 : _a[0];
      if ((firstSection == null ? void 0 : firstSection.type) === "yaml") {
        return firstSection.position;
      } else {
        return { start: void 0, end: void 0 };
      }
    }
  } else {
    return { start: void 0, end: void 0 };
  }
}

// src/commands/postValues.ts
async function postValues(plugin, payload, fileOrFilePath, lineNumber, asList = false, asBlockquote = false) {
  const file = getFileFromFileOrPath(plugin, fileOrFilePath);
  const note = await Note.buildNote(plugin, file);
  await note.createOrUpdateFields(payload, lineNumber, asList, asBlockquote);
}

// src/utils/modals.ts
var cleanActions = (container, actionClass) => {
  const actions = container.querySelector(actionClass);
  if (actions)
    actions.remove();
};

// src/modals/BaseModal.ts
var import_obsidian32 = require("obsidian");

// src/fields/FieldManager.ts
var import_obsidian7 = require("obsidian");

// src/modals/insertFieldSuggestModal.ts
var import_obsidian4 = require("obsidian");

// src/commands/insertMissingFields.ts
async function insertMissingFields(plugin, fileOrFilePath, lineNumber, asList = false, asBlockquote = false, fileClassName, indexedPath) {
  var _a;
  const file = getFileFromFileOrPath(plugin, fileOrFilePath);
  const note = await Note.buildNote(plugin, file);
  const f = plugin.fieldIndex;
  const fields = f.filesFields.get(file.path);
  const filteredClassFields = fileClassName ? ((_a = plugin.fieldIndex.fileClassesFields.get(fileClassName)) == null ? void 0 : _a.filter((field) => field.fileClassName === fileClassName)) || void 0 : void 0;
  const fieldsToInsert = [];
  if (!indexedPath) {
    fields == null ? void 0 : fields.filter((field) => field.isRoot() && !note.existingFields.map((_f) => _f.field.id).includes(field.id)).filter((field) => filteredClassFields ? filteredClassFields.map((f2) => f2.id).includes(field.id) : true).forEach((field) => {
      fieldsToInsert.push({ id: field.id, payload: { value: "" } });
    });
  } else {
    const { id, index } = Field_default.getIdAndIndex(indexedPath == null ? void 0 : indexedPath.split("____").last());
    const existingFields = note.existingFields.filter((_f) => {
      var _a2;
      const upperIndexedIdsInPath = (_a2 = _f.indexedPath) == null ? void 0 : _a2.split("____");
      upperIndexedIdsInPath == null ? void 0 : upperIndexedIdsInPath.pop();
      return (upperIndexedIdsInPath == null ? void 0 : upperIndexedIdsInPath.join("____")) === indexedPath;
    });
    const missingFields = (note == null ? void 0 : note.fields.filter((_f) => {
      var _a2;
      return ((_a2 = _f.getFirstAncestor()) == null ? void 0 : _a2.id) === id;
    }).filter((_f) => !existingFields.map((eF) => eF.field.id).includes(_f.id))) || [];
    missingFields.forEach((field) => {
      fieldsToInsert.push({ id: `${indexedPath}____${field.id}`, payload: { value: "" } });
    });
  }
  if (fieldsToInsert.length)
    await postValues(plugin, fieldsToInsert, file, lineNumber, asList, asBlockquote);
}

// src/modals/chooseSectionModal.ts
var import_obsidian3 = require("obsidian");
var chooseSectionModal = class extends import_obsidian3.SuggestModal {
  constructor(plugin, file, onSelect) {
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
    this.onSelect = onSelect;
    this.addAsListItem = false;
    this.addAsComment = false;
    this.addAtEndOfFrontMatter = false;
    this.onSelect = onSelect;
    this.containerEl.addClass("metadata-menu");
    this.resultContainerEl.addClass("sections");
  }
  onOpen() {
    super.onOpen();
    const inputContainer = this.containerEl.createDiv({ cls: "suggester-input" });
    inputContainer.appendChild(this.inputEl);
    this.containerEl.find(".prompt").prepend(inputContainer);
    const addAsListItemBtn = new import_obsidian3.ButtonComponent(inputContainer);
    addAsListItemBtn.setIcon("list");
    addAsListItemBtn.onClick(() => {
      if (this.addAsListItem) {
        addAsListItemBtn.removeCta();
        this.addAsListItem = false;
      } else {
        addAsListItemBtn.setCta();
        this.addAsListItem = true;
      }
    });
    addAsListItemBtn.setDisabled(this.addAtEndOfFrontMatter);
    addAsListItemBtn.setTooltip("Add this field as a list item");
    const addAsCommentItemBtn = new import_obsidian3.ButtonComponent(inputContainer);
    addAsCommentItemBtn.setIcon("message-square");
    addAsCommentItemBtn.onClick(() => {
      if (this.addAsComment) {
        addAsCommentItemBtn.removeCta();
        this.addAsComment = false;
      } else {
        addAsCommentItemBtn.setCta();
        this.addAsComment = true;
      }
    });
    addAsCommentItemBtn.setDisabled(this.addAtEndOfFrontMatter);
    addAsCommentItemBtn.setTooltip("Add this field as a comment item");
    const addAtEndOfFrontMatterBtn = new import_obsidian3.ButtonComponent(inputContainer);
    addAtEndOfFrontMatterBtn.setIcon("list-end");
    addAtEndOfFrontMatterBtn.onClick(() => {
      this.onSelect(-1, false, false);
      this.close();
    });
    addAtEndOfFrontMatterBtn.setTooltip("Add this field at the end of the frontmatter");
  }
  async getSuggestions(query) {
    const content = await this.plugin.app.vault.read(this.file);
    const suggestions = [{
      lineNumber: -1,
      lineText: "----------Add on top of the file--------"
    }];
    content.split("\n").forEach((lineContent, i) => {
      if (lineContent.toLowerCase().includes(query.toLowerCase())) {
        suggestions.push({
          lineNumber: i,
          lineText: lineContent.substring(0, 57) + (lineContent.length < 57 ? "" : "...")
        });
      }
    });
    return suggestions;
  }
  renderSuggestion(value, el) {
    el.addClass("item");
    const container = el.createDiv({ cls: "line" });
    container.createDiv({ text: `${value.lineNumber + 1}`, cls: "lineNumber" });
    container.createDiv({ text: value.lineText, cls: "lineText" });
  }
  onChooseSuggestion(item, evt) {
    this.onSelect(
      item.lineNumber == -1 ? 0 : item.lineNumber,
      this.addAsListItem,
      this.addAsComment
    );
  }
};

// src/modals/insertFieldSuggestModal.ts
var defaulOptions = [
  {
    actionLabel: "Insert missing fields in frontmatter",
    icon: "align-vertical-space-around"
  },
  {
    actionLabel: "Insert missing fields at section",
    icon: "enter"
  }
];
var InsertFieldSuggestModal = class extends import_obsidian4.FuzzySuggestModal {
  // a modal to insert field at root level
  constructor(plugin, file, lineNumber, asList = false, asBlockquote = false) {
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.containerEl.addClass("metadata-menu");
  }
  getItems() {
    var _a, _b, _c;
    const { start: start2, end: end2 } = ((_a = this.plugin.app.metadataCache.getFileCache(this.file)) == null ? void 0 : _a.frontmatterPosition) || {};
    if (start2 && end2 && start2.line <= this.lineNumber && end2.line >= this.lineNumber || this.lineNumber === -1) {
      return defaulOptions.concat(
        ((_b = this.plugin.fieldIndex.filesFields.get(this.file.path)) == null ? void 0 : _b.filter((_f) => _f.isRoot()).map((field) => {
          return { actionLabel: field.name, type: field.type };
        })) || []
      );
    } else {
      return defaulOptions.concat(
        ((_c = this.plugin.fieldIndex.filesFields.get(this.file.path)) == null ? void 0 : _c.filter((_f) => _f.isRoot() && !frontmatterOnlyTypes.includes(_f.type)).filter((_f) => !objectTypes2.includes(_f.type)).map((field) => {
          return { actionLabel: field.name, type: field.type };
        })) || []
      );
    }
  }
  getItemText(item) {
    return item.actionLabel;
  }
  renderSuggestion(item, el) {
    el.addClass("value-container");
    const iconContainer = el.createDiv({ cls: "icon-container" });
    item.item.type ? (0, import_obsidian4.setIcon)(iconContainer, FieldIcon[item.item.type]) : (0, import_obsidian4.setIcon)(iconContainer, item.item.icon || "plus-with-circle");
    el.createDiv({ text: item.item.actionLabel });
    el.createDiv({ cls: "spacer" });
    if (item.item.type)
      el.createDiv({ cls: `chip ${FieldTypeTagClass[item.item.type]}`, text: item.item.type });
  }
  async onChooseItem(item, evt) {
    var _a;
    if (item.actionLabel === "Insert missing fields in frontmatter") {
      insertMissingFields(this.plugin, this.file.path, -1);
    } else if (item.actionLabel === "Insert missing fields at section") {
      new chooseSectionModal(
        this.plugin,
        this.file,
        (lineNumber, asList, asBlockquote) => insertMissingFields(
          this.plugin,
          this.file.path,
          lineNumber,
          asList,
          asBlockquote
        )
      ).open();
    } else {
      const field = (_a = this.plugin.fieldIndex.filesFields.get(this.file.path)) == null ? void 0 : _a.find((field2) => field2.name === item.actionLabel);
      if (field) {
        if (objectTypes2.includes(field.type)) {
          await postValues(this.plugin, [{ id: field.id, payload: { value: "" } }], this.file);
          const eF = await Note.getExistingFieldForIndexedPath(this.plugin, this.file, field.id);
          const fieldManager = new FieldManager[field.type](this.plugin, field);
          fieldManager.createAndOpenFieldModal(this.file, field.name, eF, field.id, void 0, void 0, void 0, void 0);
        } else {
          const fieldManager = new FieldManager[field.type](this.plugin, field);
          fieldManager.createAndOpenFieldModal(this.file, item.actionLabel, void 0, void 0, this.lineNumber, this.asList, this.asBlockquote);
        }
      }
    }
  }
};

// src/settings/FieldSetting.ts
var import_obsidian5 = require("obsidian");
var FieldSetting = class extends import_obsidian5.Setting {
  constructor(containerEl, field, plugin) {
    super(containerEl);
    this.containerEl = containerEl;
    this.field = field;
    this.plugin = plugin;
    this.setTextContentWithname();
    this.addEditButton();
    this.addDeleteButton();
    this.settingEl.addClass("no-border");
  }
  setTextContentWithname() {
    const manager = new FieldManager[this.field.type](this.plugin, this.field);
    this.infoEl.textContent = "";
    this.infoEl.addClass("setting-item");
    this.fieldNameContainer = this.infoEl.createDiv({ cls: "name" });
    const level = !this.field.path ? 0 : this.field.path.split("____").length;
    for (let i = 0; i < level; i++) {
      const indentation = this.fieldNameContainer.createDiv({ cls: "indentation" });
      if (i === level - 1) {
        (0, import_obsidian5.setIcon)(indentation, "corner-down-right");
      }
    }
    this.fieldNameContainer.createDiv({ text: `${this.field.name}` });
    this.typeContainer = this.infoEl.createEl("div");
    this.typeContainer.setAttr("class", `chip ${FieldTypeTagClass[this.field.type]}`);
    this.typeContainer.setText(this.field.type);
    this.fieldOptionsContainer = this.infoEl.createEl("div");
    this.fieldOptionsContainer.setText(`${manager.getOptionsStr()}`);
  }
  addEditButton() {
    this.addButton((b) => {
      b.setIcon("pencil").setTooltip("Edit").onClick(() => {
        let modal = new FieldSettingsModal(this.plugin, this.containerEl, this, this.field);
        modal.open();
      });
    });
  }
  addDeleteButton() {
    this.addButton((b) => {
      b.setIcon("trash").setTooltip("Delete").onClick(() => {
        var _a;
        const currentExistingProperty = this.plugin.presetFields.filter((p) => p.id == this.field.id)[0];
        if (currentExistingProperty) {
          this.plugin.presetFields.remove(currentExistingProperty);
        }
        ;
        (_a = this.settingEl.parentElement) == null ? void 0 : _a.removeChild(this.settingEl);
        this.plugin.saveSettings();
      });
    });
  }
  static async getValuesListFromNote(plugin, notePath) {
    let values = [];
    const file = plugin.app.vault.getAbstractFileByPath(notePath);
    if (file instanceof import_obsidian5.TFile && file.extension == "md") {
      const result = await plugin.app.vault.read(file);
      result.split("\n").forEach((line) => {
        if (/^(.*)$/.test(line)) {
          values.push(line.trim());
        }
        ;
      });
      return values;
    } else {
      return [];
    }
    ;
  }
};

// src/settings/BaseSettingModal.ts
var import_obsidian6 = require("obsidian");
var BaseSettingModal = class extends import_obsidian6.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.initialField = new Field_default(plugin);
  }
  initFieldManagerAndCommand() {
    this.path = this.field.path;
    this.fieldManager = new FieldManager[this.field.type](this.plugin, this.field);
    this.addCommand = this.field.command !== void 0;
    this.command = this.field.command || {
      id: this.field ? `insert__${this.field.id}` : "",
      icon: "list-plus",
      label: this.field ? `Insert ${this.field.name} field` : "",
      hotkey: void 0
    };
  }
  onOpen() {
    this.containerEl.addClass("metadata-menu");
    if (this.field.name == "") {
      this.titleEl.setText(`Add a field and define options`);
    } else {
      this.titleEl.setText(`Manage settings options for ${this.field.name}`);
    }
    ;
    this.createnameInputContainer();
    this.parentSelectContainer = this.contentEl.createDiv({ cls: "field-container" });
    this.buildParentSelectContainer();
    this.contentEl.createEl("hr");
    this.createCommandContainer();
    this.createFrontmatterListDisplayContainer();
    const styleContainer = this.contentEl.createDiv({ cls: "field-container" });
    this.typeSelectContainer = this.contentEl.createDiv({ cls: "field-container" });
    this.contentEl.createEl("hr");
    this.fieldOptionsContainer = this.contentEl.createDiv();
    cleanActions(this.contentEl, ".footer-actions");
    const footer = this.contentEl.createDiv({ cls: "footer-actions" });
    footer.createDiv({ cls: "spacer" });
    this.createSaveButton(footer);
    if (this.field)
      this.createRemovalBtn(footer);
    this.createCancelButton(footer);
    this.createStyleSelectorContainer(styleContainer);
    this.buildTypeSelectContainer();
    this.fieldManager.createSettingContainer(this.fieldOptionsContainer, this.plugin, this.location);
  }
  createnameInputContainer() {
    const container = this.contentEl.createDiv({ cls: "field-container" });
    container.createDiv({ cls: "label", text: "Field Name: " });
    const input = new import_obsidian6.TextComponent(container);
    input.inputEl.addClass("with-label");
    input.inputEl.addClass("full-width");
    input.inputEl.focus();
    const name = this.field.name;
    input.setValue(name);
    input.setPlaceholder("Name of the field");
    input.onChange((value) => {
      this.field.name = value;
      this.command.id = `insert__${this.field.fileClassName || "presetField"}__${value}`;
      this.command.label = `Insert ${value} field`;
      this.titleEl.setText(`Manage options for ${this.field.name}`);
      BaseSettingModal.removeValidationError(input);
    });
    this.namePromptComponent = input;
  }
  buildParentSelectContainer() {
    this.parentSelectContainer.replaceChildren();
    const compatibleParents = this.field.getCompatibleParents();
    const parentSelectorContainerLabel = this.parentSelectContainer.createDiv({ cls: "label" });
    parentSelectorContainerLabel.setText(`Parent:`);
    this.parentSelectContainer.createDiv({ cls: "spacer" });
    const parentSelect = new import_obsidian6.DropdownComponent(this.parentSelectContainer);
    parentSelect.addOption("none", "--None--");
    compatibleParents.forEach((parent) => {
      const path = parent.path ? parent.path + "____" + parent.id : parent.id;
      const display = path.split("____").map((id) => {
        var _a;
        return ((_a = Field_default.getFieldFromId(this.plugin, id, this.getFileClassName())) == null ? void 0 : _a.name) || "";
      }).join(" > ");
      parentSelect.addOption(path, display);
    });
    if (this.field.path) {
      parentSelect.setValue(this.field.path || "none");
    } else {
      parentSelect.setValue("none");
    }
    parentSelect.onChange((path) => {
      if (path === "none") {
        this.path = "";
        this.field.path = "";
      } else {
        this.path = path;
        this.field.path = path;
      }
      this.buildTypeSelectContainer();
    });
    if (!compatibleParents.length)
      this.parentSelectContainer.hide();
  }
  createFrontmatterListDisplayContainer() {
    this.frontmatterListDisplayContainer = this.contentEl.createDiv({ cls: "field-container" });
    this.frontmatterListDisplayContainer.createDiv({ text: "Frontmatter list display type", cls: "label" });
    this.frontmatterListDisplayContainer.createDiv({ cls: "spacer" });
    const frontmatterListDisplay = new import_obsidian6.DropdownComponent(this.frontmatterListDisplayContainer);
    const options2 = {};
    options2["asArray"] = "display as array";
    options2["asList"] = "display as indented list";
    options2["undefined"] = `Plugin Default (${this.plugin.settings.frontmatterListDisplay})`;
    frontmatterListDisplay.addOptions(options2);
    switch (this.field.display) {
      case "asArray" /* asArray */:
        frontmatterListDisplay.setValue("asArray");
        break;
      case "asList" /* asList */:
        frontmatterListDisplay.setValue("asList");
        break;
      case void 0:
        frontmatterListDisplay.setValue("undefined");
        break;
    }
    frontmatterListDisplay.onChange((value) => {
      switch (value) {
        case "asArray":
          this.frontmatterListDisplay = "asArray" /* asArray */;
          break;
        case "asList":
          this.frontmatterListDisplay = "asList" /* asList */;
          break;
        case "undefined":
          this.frontmatterListDisplay = void 0;
          break;
        default:
          this.frontmatterListDisplay = void 0;
      }
    });
    if (!multiTypes.includes(this.field.type))
      this.frontmatterListDisplayContainer.hide();
  }
  createCommandContainer() {
    const commandContainer = this.contentEl.createDiv({ cls: "field-container" });
    commandContainer.createDiv({ text: "set a command for this field?", cls: "label" });
    commandContainer.createDiv({ cls: "spacer" });
    const addCommandToggler = new import_obsidian6.ToggleComponent(commandContainer);
    addCommandToggler.setValue(this.addCommand);
    const iconContainer = this.contentEl.createDiv({ cls: "field-container" });
    this.addCommand ? iconContainer.show() : iconContainer.hide();
    iconContainer.createDiv({ text: "Icon name", cls: "label" });
    this.iconName = new import_obsidian6.TextComponent(iconContainer);
    this.iconName.inputEl.addClass("full-width");
    this.iconName.inputEl.addClass("with-label");
    const iconPreview = iconContainer.createDiv({ cls: "icon-preview" });
    this.iconName.setValue(this.command.icon);
    (0, import_obsidian6.setIcon)(iconPreview, this.command.icon);
    this.iconName.onChange((value) => {
      this.command.icon = value;
      (0, import_obsidian6.setIcon)(iconPreview, value);
    });
    addCommandToggler.onChange((value) => {
      this.addCommand = value;
      this.addCommand ? iconContainer.show() : iconContainer.hide();
    });
  }
  setLabelStyle(label) {
    const fieldStyle = this.field.style || {};
    Object.keys(FieldStyle).forEach((style) => {
      const styleKey = FieldStyleKey[style];
      if (!!fieldStyle[styleKey]) {
        label.addClass(styleKey);
      } else {
        label.removeClass(styleKey);
      }
    });
  }
  createStyleSelectorContainer(parentNode) {
    const styleSelectorLabel = parentNode.createDiv({ cls: "label" });
    styleSelectorLabel.setText(`Inline field style`);
    this.setLabelStyle(styleSelectorLabel);
    parentNode.createDiv({ text: "::" });
    parentNode.createDiv({ cls: "spacer" });
    const styleButtonsContainer = parentNode.createDiv({ cls: "style-buttons-container" });
    Object.keys(FieldStyle).forEach((style) => {
      const styleBtnContainer = styleButtonsContainer.createEl(FieldHTMLTagMap[style], { cls: "style-button-container" });
      styleBtnContainer.createDiv({ cls: "style-btn-label", text: FieldStyleKey[style] });
      const styleBtnToggler = new import_obsidian6.ToggleComponent(styleBtnContainer);
      const fieldStyle = this.field.style || {};
      styleBtnToggler.setValue(fieldStyle[FieldStyleKey[style]]);
      styleBtnToggler.onChange((v) => {
        fieldStyle[FieldStyleKey[style]] = v;
        this.field.style = fieldStyle;
        this.setLabelStyle(styleSelectorLabel);
      });
    });
  }
  setTypeInfo() {
    this.frontmatterOnlyTypeInfoContainer.replaceChildren();
    if (frontmatterOnlyTypes.includes(this.field.type)) {
      const info = new import_obsidian6.ButtonComponent(this.frontmatterOnlyTypeInfoContainer);
      info.setClass("tooltip-button");
      (0, import_obsidian6.setIcon)(info.buttonEl, "info");
      info.setTooltip(`${this.field.type} field type 
are only available
in the frontmatter section`);
    }
  }
  buildTypeSelectContainer() {
    this.typeSelectContainer.replaceChildren();
    const typeSelectorContainerLabel = this.typeSelectContainer.createDiv({ cls: "label" });
    typeSelectorContainerLabel.setText(`Field type:`);
    this.typeSelectContainer.createDiv({ cls: "spacer" });
    const infoBtnContainer = this.typeSelectContainer.createDiv({ cls: "tooltip-btn" });
    const info = new import_obsidian6.ButtonComponent(infoBtnContainer);
    info.setClass("tooltip-button");
    (0, import_obsidian6.setIcon)(info.buttonEl, !(this.field.id && !this.isNew()) ? "shield-alert" : "lock");
    info.setTooltip(`The field type 
can't be modified once saved`);
    const typeSelect = new import_obsidian6.DropdownComponent(this.typeSelectContainer);
    this.frontmatterOnlyTypeInfoContainer = this.typeSelectContainer.createDiv({ cls: "tooltip-btn" });
    this.setTypeInfo();
    Object.keys(FieldTypeTooltip).forEach((key) => {
      if (!rootOnlyTypes.includes(key)) {
        typeSelect.addOption(key, FieldTypeTooltip[key]);
      } else {
        if (this.field.isRoot())
          typeSelect.addOption(key, FieldTypeTooltip[key]);
      }
    });
    if (this.field.type) {
      typeSelect.setValue(this.field.type);
      if (multiTypes.includes(this.field.type)) {
        this.frontmatterListDisplayContainer.show();
      } else {
        this.frontmatterListDisplayContainer.hide();
      }
    }
    if (this.field.id && !this.isNew()) {
      typeSelect.setDisabled(true);
      return;
    }
    typeSelect.onChange((typeLabel) => {
      this.field = new Field_default(this.plugin);
      this.setFileClassName();
      Field_default.copyProperty(this.field, this.initialField);
      this.field.name = this.namePromptComponent.getValue();
      this.field.type = FieldTypeLabelMapping[typeLabel];
      this.field.path = this.path;
      if (this.field.type !== this.initialField.type && ![this.field.type, this.initialField.type].every(
        (fieldType) => ["Multi" /* Multi */, "Select" /* Select */, "Cycle" /* Cycle */].includes(fieldType)
      )) {
        this.field.options = {};
      }
      this.buildParentSelectContainer();
      this.setTypeInfo();
      if (multiTypes.includes(this.field.type)) {
        this.frontmatterListDisplayContainer.show();
      } else {
        this.frontmatterListDisplayContainer.hide();
      }
      while (this.fieldOptionsContainer.firstChild) {
        this.fieldOptionsContainer.removeChild(this.fieldOptionsContainer.firstChild);
      }
      this.fieldManager = new FieldManager[this.field.type](this.plugin, this.field);
      this.fieldManager.createSettingContainer(this.fieldOptionsContainer, this.plugin, this.location);
    });
  }
  validateFields() {
    return this.fieldManager.validateName(
      this.namePromptComponent,
      this.contentEl
    ) && this.fieldManager.validateOptions();
  }
  createSaveButton(container) {
    const saveButton = new import_obsidian6.ButtonComponent(container);
    saveButton.setTooltip("Save");
    saveButton.setIcon("checkmark");
    saveButton.onClick(async () => {
      let error = !this.validateFields();
      if (error) {
        new import_obsidian6.Notice("Fix errors before saving.");
        return;
      }
      ;
      if (this.addCommand) {
        this.field.command = this.command;
        addInsertFieldCommand(this.plugin, this.command, this.field, this.field.fileClassName);
      } else {
        delete this.field.command;
      }
      if (this.frontmatterListDisplay !== void 0) {
        this.field.display = this.frontmatterListDisplay;
      } else {
        delete this.field.display;
      }
      this.onSave();
      this.close();
    });
  }
  createRemovalBtn(container) {
    const removeButton = new import_obsidian6.ButtonComponent(container);
    removeButton.setIcon("trash");
    removeButton.onClick(() => {
      const confirmModal = new import_obsidian6.Modal(this.plugin.app);
      confirmModal.containerEl.addClass("metadata-menu");
      confirmModal.titleEl.setText("Please confirm");
      confirmModal.contentEl.createDiv().setText(`Do you really want to remove this field?`);
      const confirmFooter = confirmModal.contentEl.createDiv({ cls: "footer-actions" });
      confirmFooter.createDiv({ cls: "spacer" });
      const confirmButton = new import_obsidian6.ButtonComponent(confirmFooter);
      confirmButton.setWarning();
      confirmButton.setIcon("checkmark");
      confirmButton.onClick(async () => {
        if (this.field)
          await this.removeField();
        confirmModal.close();
        this.close();
      });
      const dismissButton = new import_obsidian6.ButtonComponent(confirmFooter);
      dismissButton.setIcon("cross");
      dismissButton.onClick(() => this.close());
      confirmModal.open();
    });
  }
  createCancelButton(container) {
    const cancelButton = new import_obsidian6.ButtonComponent(container);
    cancelButton.setIcon("cross");
    cancelButton.setTooltip("Cancel");
    cancelButton.onClick(() => this.onCancel());
  }
  /* utils functions */
  static setValidationError(textInput, message) {
    textInput.inputEl.addClass("is-invalid");
    const fieldContainer = textInput.inputEl.parentElement;
    const fieldsContainer = fieldContainer == null ? void 0 : fieldContainer.parentElement;
    if (message && fieldsContainer) {
      let mDiv = fieldsContainer.querySelector(".field-error");
      if (!mDiv)
        mDiv = createDiv({ cls: "field-error" });
      mDiv.innerText = message;
      fieldsContainer.insertBefore(mDiv, fieldContainer);
    }
  }
  static removeValidationError(textInput) {
    if (textInput.inputEl.hasClass("is-invalid"))
      textInput.inputEl.removeClass("is-invalid");
    const fieldContainer = textInput.inputEl.parentElement;
    const fieldsContainer = fieldContainer == null ? void 0 : fieldContainer.parentElement;
    const fieldError = fieldsContainer == null ? void 0 : fieldsContainer.querySelector(".field-error");
    if (fieldError)
      fieldsContainer.removeChild(fieldError);
  }
};

// src/settings/MetadataMenuSettings.ts
var DEFAULT_SETTINGS = {
  presetFields: [],
  fileClassQueries: [],
  displayFieldsInContextMenu: true,
  globallyIgnoredFields: [],
  classFilesPath: null,
  isAutosuggestEnabled: true,
  fileClassAlias: "fileClass",
  settingsVersion: void 0,
  globalFileClass: void 0,
  firstDayOfWeek: 1,
  enableLinks: true,
  enableTabHeader: true,
  enableEditor: true,
  enableBacklinks: true,
  enableStarred: true,
  enableFileExplorer: true,
  enableSearch: true,
  enableProperties: true,
  tableViewMaxRecords: 20,
  frontmatterListDisplay: "asArray" /* asArray */,
  fileClassExcludedFolders: [],
  showIndexingStatusInStatusBar: true,
  fileIndexingExcludedFolders: [],
  fileIndexingExcludedExtensions: [".excalidraw.md"],
  fileIndexingExcludedRegex: [],
  frontmatterOnly: false,
  showFileClassSelectInModal: true,
  chooseFileClassAtFileCreation: false,
  autoInsertFieldsAtFileClassInsertion: false,
  fileClassIcon: "package",
  isAutoCalculationEnabled: true
};
var incrementVersion = (plugin) => {
  const currentVersion = plugin.settings.settingsVersion;
  if (currentVersion && typeof currentVersion === "string") {
    const [x, y] = currentVersion.split(".");
    plugin.settings.settingsVersion = `${x}.${parseInt(y) + 1}`;
  } else {
    plugin.settings.settingsVersion = "5.0";
  }
};

// src/settings/FieldSettingsModal.ts
var FieldSettingsModal = class extends BaseSettingModal {
  constructor(plugin, parentSettingContainer, parentSetting, field) {
    super(plugin);
    this.plugin = plugin;
    this.parentSettingContainer = parentSettingContainer;
    this.parentSetting = parentSetting;
    this.saved = false;
    this.new = true;
    this.initialField = new Field_default(plugin);
    this.initFieldAndLocation(field);
    this.initFieldManagerAndCommand();
  }
  isNew() {
    return this.new;
  }
  initFieldAndLocation(field) {
    if (field) {
      this.new = false;
      this.field = field;
      Field_default.copyProperty(this.initialField, this.field);
    } else {
      this.field = new Field_default(this.plugin);
      const id = Field_default.getNewFieldId(this.plugin);
      this.field.id = id;
      this.initialField.id = id;
    }
    this.location = 0 /* PluginSettings */;
  }
  async onSave() {
    var _a;
    this.saved = true;
    const currentExistingField = this.plugin.presetFields.filter((p) => p.id == this.field.id)[0];
    if (currentExistingField) {
      Field_default.copyProperty(currentExistingField, this.field);
    } else {
      this.plugin.presetFields.push(this.field);
    }
    ;
    Field_default.copyProperty(this.initialField, this.field);
    if (this.parentSetting)
      Field_default.copyProperty(this.parentSetting.field, this.field);
    (_a = this.parentSetting) == null ? void 0 : _a.setTextContentWithname();
    incrementVersion(this.plugin);
    await this.plugin.saveSettings();
  }
  onCancel() {
    this.saved = false;
    if (this.initialField.name != "") {
      Object.assign(this.field, this.initialField);
    }
    ;
    this.close();
  }
  getFileClassName() {
    return;
  }
  setFileClassName() {
  }
  async removeField() {
    const currentExistingProperty = this.plugin.presetFields.filter((p) => p.id == this.field.id)[0];
    if (currentExistingProperty) {
      this.plugin.presetFields.remove(currentExistingProperty);
    }
    ;
    await this.plugin.saveSettings();
  }
  onClose() {
    Object.assign(this.field, this.initialField);
    if (!this.new && this.parentSetting) {
      this.parentSetting.setTextContentWithname();
    } else if (this.saved) {
      new FieldSetting(this.parentSettingContainer, this.field, this.plugin);
    }
    ;
  }
};

// src/fields/FieldManager.ts
var FieldManager2 = class {
  constructor(plugin, field, type) {
    this.plugin = plugin;
    this.field = field;
    this.type = type;
    this.showModalOption = true;
    if (field.type !== type)
      throw Error(`This field is not of type ${type}`);
  }
  static buildMarkDownLink(plugin, file, path, subPath, alias) {
    const destFile = plugin.app.metadataCache.getFirstLinkpathDest(path, file.path);
    if (destFile) {
      return plugin.app.fileManager.generateMarkdownLink(
        destFile,
        file.path,
        subPath,
        alias
      );
    }
    return "";
  }
  validateName(textInput, contentEl) {
    var _a;
    let error = false;
    if (/^[#>-]/.test(this.field.name)) {
      FieldSettingsModal.setValidationError(
        textInput,
        "Field name cannot start with #, >, -"
      );
      error = true;
    }
    ;
    if (this.field.name == "") {
      FieldSettingsModal.setValidationError(
        textInput,
        "Field name can not be Empty"
      );
      error = true;
    }
    ;
    if (this.field.fileClassName) {
      const fields = (_a = this.plugin.fieldIndex.fileClassesFields.get(this.field.fileClassName)) == null ? void 0 : _a.filter((_f) => _f.path === this.field.path && _f.id !== this.field.id && _f.fileClassName === this.field.fileClassName);
      if (fields == null ? void 0 : fields.map((_f) => _f.name).includes(this.field.name)) {
        FieldSettingsModal.setValidationError(
          textInput,
          `There is already a field with this name for this path in this ${this.plugin.settings.fileClassAlias}. Please choose another name`
        );
        error = true;
      }
    } else {
      const fields = this.plugin.presetFields.filter((_f) => _f.path === this.field.path && _f.id !== this.field.id);
      if (fields == null ? void 0 : fields.map((_f) => _f.name).includes(this.field.name)) {
        FieldSettingsModal.setValidationError(
          textInput,
          "There is already a field with this name for this path in presetFields. Please choose another name"
        );
        error = true;
      }
    }
    return !error;
  }
  validateValue(value) {
    return true;
  }
  static async replaceValues(plugin, path, id, value) {
    const file = plugin.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian7.TFile && file.extension == "md") {
      await postValues(plugin, [{ id, payload: { value } }], file);
    }
  }
  static isSuggest(location) {
    return location.getItems !== void 0;
  }
  static isInsertFieldCommand(location) {
    return location === "InsertFieldCommand";
  }
  static isFieldOptions(location) {
    return location.addOption !== void 0;
  }
  static createAndOpenModal(plugin, file, fieldName, field, eF, indexedPath, lineNumber, asList, asBlockquote) {
    if (field) {
      const fieldManager = new FieldManager[field.type](plugin, field);
      fieldManager.createAndOpenFieldModal(file, fieldName, eF, indexedPath, lineNumber, asList, asBlockquote);
    } else {
      const fieldManager = FieldManager2.createDefault(plugin, fieldName);
      fieldManager.createAndOpenFieldModal(file, fieldName, eF, indexedPath, lineNumber, asList, asBlockquote);
    }
  }
  static openFieldModal(plugin, file, fieldName, lineNumber, asList, asBlockquote) {
    var _a;
    if (!fieldName) {
      const modal = new InsertFieldSuggestModal(plugin, file, lineNumber, asList, asBlockquote);
      modal.open();
    } else {
      const field = (_a = plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a.find((field2) => field2.name === fieldName);
      if (field)
        this.createAndOpenModal(plugin, file, fieldName, field, void 0, void 0, lineNumber, asList, asBlockquote);
    }
  }
  static createDefault(plugin, name) {
    const field = Field_default.createDefault(plugin, name);
    return new FieldManager[field.type](plugin, field);
  }
  static stringToBoolean(value) {
    let toBooleanValue = false;
    if (isBoolean(value)) {
      toBooleanValue = value;
    } else if (/true/i.test(value) || /1/.test(value)) {
      toBooleanValue = true;
    } else if (/false/i.test(value) || /0/.test(value)) {
      toBooleanValue = false;
    }
    ;
    return toBooleanValue;
  }
  displayValue(container, file, value, onClicked = () => {
  }) {
    let valueText;
    switch (value) {
      case void 0:
        valueText = "";
        break;
      case null:
        valueText = "";
        break;
      case false:
        valueText = "false";
        break;
      case 0:
        valueText = "0";
        break;
      default:
        valueText = value.toString() || "";
    }
    container.createDiv({ text: `${valueText}` });
  }
};

// src/fields/fieldManagers/ObjectField.ts
var import_obsidian30 = require("obsidian");

// src/options/FieldCommandSuggestModal.ts
var import_obsidian8 = require("obsidian");
var FieldCommandSuggestModal = class extends import_obsidian8.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.options = [];
    this.containerEl.addClass("metadata-menu");
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item.actionLabel;
  }
  onChooseItem(item, evt) {
    item.action();
  }
  renderSuggestion(item, el) {
    if (item.item.id === "__optionSeparator") {
      el.addClass("suggest-separator");
    } else {
      el.addClass("value-container");
      const iconContainer = el.createDiv({ cls: "icon-container" });
      item.item.icon ? (0, import_obsidian8.setIcon)(iconContainer, item.item.icon) : (0, import_obsidian8.setIcon)(iconContainer, "pencil");
      const actionLabel = el.createDiv();
      actionLabel.innerHTML = item.item.actionLabel;
    }
  }
};

// src/options/OptionsList.ts
var import_obsidian29 = require("obsidian");

// src/fileClass/fileClassAttribute.ts
var FileClassAttribute = class {
  constructor(plugin, origin, name, id, type = "Input" /* Input */, options2 = [], fileClassName, command, display, style, path) {
    this.plugin = plugin;
    this.origin = origin;
    this.name = name;
    this.id = id;
    this.type = type;
    this.options = options2;
    this.fileClassName = fileClassName;
    this.command = command;
    this.display = display;
    this.style = style;
    this.path = path;
  }
  getLevel() {
    if (!this.path)
      return 0;
    return this.path.split("____").length;
  }
  getField() {
    var _a;
    let options2 = {};
    if (Array.isArray(this.options)) {
      (_a = this.options) == null ? void 0 : _a.forEach((option, index) => {
        options2[index] = option;
      });
    } else {
      options2 = this.options;
    }
    return new Field_default(this.plugin, this.name, options2, this.id, this.type, this.fileClassName, this.command, this.display, this.style, this.path);
  }
  getOptionsString(plugin) {
    const field = this.getField();
    const manager = new FieldManager[field.type](plugin, field);
    return manager.getOptionsStr();
  }
};

// src/fileClass/fileClass.ts
var import_obsidian9 = require("obsidian");

// src/utils/textUtils.ts
var capitalize = (s) => {
  return s && s[0].toUpperCase() + s.slice(1);
};

// src/fileClass/fileClass.ts
var options = {
  "limit": { name: "limit", toValue: (value) => value },
  "mapWithTag": { name: "mapWithTag", toValue: (value) => value },
  "icon": { name: "icon", toValue: (value) => `${value || "file-spreadsheet"}` },
  "tagNames": { name: "tagNames", toValue: (values) => values.length ? values : null },
  "filesPaths": { name: "filesPaths", toValue: (values) => values.length ? values : null },
  "bookmarksGroups": { name: "bookmarksGroups", toValue: (values) => values.length ? values : null },
  "excludes": { name: "excludes", toValue: (values) => values.length ? values.map((attr) => attr.name) : null },
  "parent": { name: "extends", toValue: (value) => (value == null ? void 0 : value.name) || null },
  "savedViews": { name: "savedViews", toValue: (value) => value },
  "favoriteView": { name: "favoriteView", toValue: (value) => value || null }
};
var FileClassOptions = class {
  constructor(limit, icon, parent, excludes, tagNames, mapWithTag = false, filesPaths, bookmarksGroups, savedViews, favoriteView) {
    this.limit = limit;
    this.icon = icon;
    this.parent = parent;
    this.excludes = excludes;
    this.tagNames = tagNames;
    this.mapWithTag = mapWithTag;
    this.filesPaths = filesPaths;
    this.bookmarksGroups = bookmarksGroups;
    this.savedViews = savedViews;
    this.favoriteView = favoriteView;
  }
};
var AddFileClassToFileModal = class extends import_obsidian9.SuggestModal {
  constructor(plugin, file) {
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
  }
  getSuggestions(query) {
    const fileClasses = [...this.plugin.fieldIndex.fileClassesName.keys()].filter(
      (fileClassName) => {
        var _a;
        return !((_a = this.plugin.fieldIndex.filesFileClasses.get(this.file.path)) == null ? void 0 : _a.map((fileClass) => fileClass.name).includes(fileClassName));
      }
    ).filter((fileClassName) => fileClassName.toLocaleLowerCase().contains(query.toLowerCase())).sort();
    return fileClasses;
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
  onChooseSuggestion(item, evt) {
    this.insertFileClassToFile(item);
  }
  async insertFileClassToFile(value) {
    const fileClassAlias = this.plugin.settings.fileClassAlias;
    const currentFileClasses = this.plugin.fieldIndex.filesFileClasses.get(this.file.path);
    const newValue = currentFileClasses ? [...currentFileClasses.map((fc) => fc.name), value].join(", ") : value;
    await postValues(this.plugin, [{ id: `fileclass-field-${fileClassAlias}`, payload: { value: newValue } }], this.file, -1);
    if (this.plugin.settings.autoInsertFieldsAtFileClassInsertion) {
      insertMissingFields(this.plugin, this.file, -1);
    }
  }
};
var FileClass = class {
  constructor(plugin, name) {
    this.plugin = plugin;
    this.name = name;
    this.attributes = [];
  }
  getFileClassOptions() {
    var _a, _b;
    const {
      extends: _parent,
      limit: _limit,
      excludes: _excludes,
      mapWithTag: _mapWithTag,
      tagNames: _tagNames,
      filesPaths: _filesPaths,
      bookmarksGroups: _bookmarksGroups,
      icon: _icon,
      savedViews: _savedViews,
      favoriteView: _favoriteView
    } = ((_a = this.plugin.app.metadataCache.getFileCache(this.getClassFile())) == null ? void 0 : _a.frontmatter) || {};
    const index = this.plugin.fieldIndex;
    const parent = index.fileClassesName.get(_parent);
    const excludedNames = FileClass.getExcludedFieldsFromFrontmatter(_excludes);
    const excludes = [];
    (_b = index.fileClassesAncestors.get(this.getClassFile().basename)) == null ? void 0 : _b.forEach((ancestorName) => {
      var _a2;
      (_a2 = index.fileClassesName.get(ancestorName)) == null ? void 0 : _a2.attributes.forEach((attr) => {
        if (excludedNames.includes(attr.name) && !excludes.map((attr2) => attr2.name).includes(attr.name))
          excludes.push(attr);
      });
    });
    const limit = typeof _limit === "number" ? _limit : this.plugin.settings.tableViewMaxRecords;
    const mapWithTag = FieldManager2.stringToBoolean(_mapWithTag);
    const tagNames = FileClass.getTagNamesFromFrontMatter(_tagNames);
    const filesPaths = FileClass.getFilesPathsFromFrontMatter(_filesPaths);
    const bookmarksGroups = FileClass.getBookmarksGroupsFromFrontMatter(_bookmarksGroups);
    const icon = typeof _icon === "string" ? _icon : this.plugin.settings.fileClassIcon;
    const savedViews = _savedViews || [];
    const favoriteView = typeof _favoriteView === "string" && _favoriteView !== "" ? _favoriteView : null;
    return new FileClassOptions(limit, icon, parent, excludes, tagNames, mapWithTag, filesPaths, bookmarksGroups, savedViews, favoriteView);
  }
  isMappedWithTag() {
    var _a, _b;
    try {
      const fileClassFile = this.getClassFile();
      const mapWithTag = (_b = (_a = this.plugin.app.metadataCache.getFileCache(fileClassFile)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.mapWithTag;
      return !!mapWithTag;
    } catch (error) {
      return false;
    }
  }
  getClassFile() {
    const filesClassPath = this.plugin.settings.classFilesPath;
    const file = this.plugin.app.vault.getAbstractFileByPath(`${filesClassPath}${this.name}.md`);
    if (file instanceof import_obsidian9.TFile && file.extension == "md") {
      return file;
    } else {
      const error = new Error(
        `no file named <${this.name}.md> in <${filesClassPath}> folder to match <${this.plugin.settings.fileClassAlias}: ${this.name}> in one of these notes`
      );
      throw error;
    }
  }
  getIcon() {
    const parents = [this.name, ...this.plugin.fieldIndex.fileClassesAncestors.get(this.name) || []];
    let icon;
    parents.some((fileClassName, i) => {
      var _a, _b;
      const fileClass = this.plugin.fieldIndex.fileClassesName.get(fileClassName);
      if (fileClass) {
        const file = fileClass.getClassFile();
        const _icon = (_b = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.icon;
        if (_icon) {
          icon = _icon;
          return true;
        }
        ;
      }
    });
    return icon || this.plugin.settings.fileClassIcon;
  }
  async missingFieldsForFileClass(file) {
    var _a;
    const note = await Note.buildNote(this.plugin, file);
    const currentFieldsIds = note.existingFields.map((_f) => _f.field.id);
    const missingFields = this && file ? !((_a = this.plugin.fieldIndex.fileClassesFields.get(this.name)) == null ? void 0 : _a.map((f) => f.id).every((id) => currentFieldsIds.includes(id))) : false;
    return missingFields;
  }
  getViewChildren(name) {
    var _a, _b;
    if (!name)
      return [];
    const childrenNames = ((_b = (_a = this.getFileClassOptions().savedViews) == null ? void 0 : _a.find((_view) => _view.name === name)) == null ? void 0 : _b.children) || [];
    return this.getChildren().filter((c) => childrenNames.includes(c.name));
  }
  static getFileClassAttributes(plugin, fileClass, excludes) {
    var _a, _b;
    const file = fileClass.getClassFile();
    const rawAttributes = ((_b = (_a = plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.fields) || [];
    const attributes = [];
    rawAttributes.forEach((attr) => {
      const { name, id, type, options: options2, command, display, style, path } = attr;
      const fieldType = FieldTypeLabelMapping[capitalize(type)];
      attributes.push(new FileClassAttribute(plugin, this.name, name, id, fieldType, options2, fileClass.name, command, display, style, path));
    });
    if (excludes) {
      return attributes.filter((attr) => !excludes.includes(attr.name));
    } else {
      return attributes;
    }
  }
  static getExcludedFieldsFromFrontmatter(excludedFields) {
    if (Array.isArray(excludedFields)) {
      return excludedFields;
    } else if (excludedFields) {
      return excludedFields.split(",");
    } else {
      return [];
    }
  }
  static getTagNamesFromFrontMatter(_tagNames) {
    if (Array.isArray(_tagNames)) {
      return _tagNames;
    } else if (_tagNames) {
      return _tagNames.split(",");
    } else {
      return [];
    }
  }
  static getFilesPathsFromFrontMatter(_filesPaths) {
    if (Array.isArray(_filesPaths)) {
      return _filesPaths;
    } else if (_filesPaths) {
      return _filesPaths.split(",");
    } else {
      return [];
    }
  }
  static getBookmarksGroupsFromFrontMatter(_bookmarksGroups) {
    if (Array.isArray(_bookmarksGroups)) {
      return _bookmarksGroups;
    } else if (_bookmarksGroups) {
      return _bookmarksGroups.split(",");
    } else {
      return [];
    }
  }
  getAttributes() {
    var _a, _b;
    try {
      const file = this.getClassFile();
      const ancestors = this.plugin.fieldIndex.fileClassesAncestors.get(this.name);
      const _excludedFields = (_b = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.excludes;
      let excludedFields = FileClass.getExcludedFieldsFromFrontmatter(_excludedFields);
      const ancestorsAttributes = /* @__PURE__ */ new Map();
      ancestorsAttributes.set(this.name, FileClass.getFileClassAttributes(this.plugin, this, excludedFields));
      ancestors == null ? void 0 : ancestors.forEach((ancestorName) => {
        var _a2, _b2;
        const ancestorFile = this.plugin.app.vault.getAbstractFileByPath(`${this.plugin.settings.classFilesPath}${ancestorName}.md`);
        const ancestor = new FileClass(this.plugin, ancestorName);
        ancestorsAttributes.set(ancestorName, FileClass.getFileClassAttributes(this.plugin, ancestor, excludedFields));
        if (ancestorFile instanceof import_obsidian9.TFile && ancestorFile.extension === "md") {
          const _excludedFields2 = (_b2 = (_a2 = this.plugin.app.metadataCache.getFileCache(ancestorFile)) == null ? void 0 : _a2.frontmatter) == null ? void 0 : _b2.excludes;
          excludedFields.push(...FileClass.getExcludedFieldsFromFrontmatter(_excludedFields2));
        }
      });
      for (const [fileClassName, fileClassAttributes] of ancestorsAttributes) {
        this.attributes.push(...fileClassAttributes.filter((attr) => !this.attributes.map((_attr) => _attr.name).includes(attr.name)));
      }
    } catch (error) {
      throw error;
    }
  }
  getVersion() {
    var _a, _b;
    return (_b = (_a = this.plugin.app.metadataCache.getFileCache(this.getClassFile())) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.version;
  }
  getMajorVersion() {
    const version = this.getVersion();
    if (version) {
      const [x, y] = `${version}`.split(".");
      if (!y)
        return void 0;
      return parseInt(x);
    } else {
      return void 0;
    }
  }
  async incrementVersion() {
    var _a, _b;
    const file = this.getClassFile();
    const currentVersion = (_b = (_a = this.plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.version;
    await this.plugin.app.fileManager.processFrontMatter(file, (fm) => {
      if (currentVersion) {
        const [x, y] = currentVersion.split(".");
        fm.version = `${x}.${parseInt(y) + 1}`;
      } else {
        fm.version = "2.0";
      }
    });
  }
  async updateOptions(newOptions) {
    const file = this.getClassFile();
    await this.plugin.app.fileManager.processFrontMatter(file, (fm) => {
      Object.keys(options).forEach(async (key) => {
        const { name, toValue } = options[key];
        fm[name] = toValue(newOptions[key]);
      });
    });
    await this.incrementVersion();
  }
  getChildren() {
    const childrenNames = [];
    [...this.plugin.fieldIndex.fileClassesAncestors].forEach(([_fName, ancestors]) => {
      if (ancestors.includes(this.name)) {
        const path = [...ancestors.slice(0, ancestors.indexOf(this.name)).reverse(), _fName];
        const fileClass = this.plugin.fieldIndex.fileClassesName.get(_fName);
        if (fileClass) {
          childrenNames.push({
            name: _fName,
            path,
            fileClass
          });
        }
      }
    });
    return childrenNames;
  }
  async updateAttribute(newType, newName, newOptions, attr, newCommand, newDisplay, newStyle, newPath) {
    const fileClass = attr ? this.plugin.fieldIndex.fileClassesName.get(attr.fileClassName) : this;
    const file = fileClass.getClassFile();
    await this.plugin.app.fileManager.processFrontMatter(file, (fm) => {
      fm.fields = fm.fields || [];
      if (attr) {
        const field = fm.fields.find((f) => f.id === attr.id);
        field.type = newType;
        if (newOptions)
          field.options = newOptions;
        if (newCommand)
          field.command = newCommand;
        if (newDisplay)
          field.display = newDisplay;
        if (newStyle)
          field.style = newStyle;
        if (newName)
          field.name = newName;
        if (newPath !== void 0)
          field.path = newPath;
      } else {
        fm.fields.push({
          name: newName,
          type: newType,
          options: newOptions,
          command: newCommand,
          display: newDisplay,
          style: newStyle,
          path: newPath,
          id: Field_default.getNewFieldId(this.plugin)
        });
      }
    });
    await this.incrementVersion();
  }
  async removeAttribute(attr) {
    const file = this.getClassFile();
    await this.plugin.app.fileManager.processFrontMatter(file, (fm) => {
      fm.fields = fm.fields.filter((f) => f.id !== attr.id);
    });
  }
  static createFileClass(plugin, name) {
    const fileClass = new FileClass(plugin, name);
    fileClass.options = fileClass.getFileClassOptions();
    fileClass.getAttributes();
    return fileClass;
  }
  static getFileClassNameFromPath(settings, path) {
    var _a, _b;
    const fileClassNameRegex = new RegExp(`${settings.classFilesPath}(?<fileClassName>.*).md`);
    return (_b = (_a = path.match(fileClassNameRegex)) == null ? void 0 : _a.groups) == null ? void 0 : _b.fileClassName;
  }
  static indexFileClass(index, file) {
    var _a, _b, _c, _d, _e, _f, _g;
    const fileClassName = FileClass.getFileClassNameFromPath(index.plugin.settings, file.path);
    if (fileClassName) {
      try {
        const fileClass = FileClass.createFileClass(index.plugin, fileClassName);
        index.fileClassesFields.set(
          fileClassName,
          fileClass.attributes.map((attr) => attr.getField())
        );
        index.fileClassesPath.set(file.path, fileClass);
        index.fileClassesName.set(fileClass.name, fileClass);
        const cache = index.plugin.app.metadataCache.getFileCache(file);
        if (fileClass.getMajorVersion() === void 0 || fileClass.getMajorVersion() < 2) {
          index.v1FileClassesPath.set(file.path, fileClass);
          index.remainingLegacyFileClasses = true;
        } else if (fileClass.getMajorVersion() === 2) {
          index.v2FileClassesPath.set(file.path, fileClass);
          index.remainingLegacyFileClasses = true;
        }
        if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.mapWithTag) {
          if (!fileClassName.includes(" ")) {
            index.tagsMatchingFileClasses.set(fileClassName, fileClass);
          }
        }
        if ((_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b.tagNames) {
          const _tagNames = (_c = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _c.tagNames;
          const tagNames = Array.isArray(_tagNames) ? [..._tagNames] : _tagNames.split(",").map((t) => t.trim());
          tagNames.forEach((tag) => {
            if (!tag.includes(" ")) {
              index.tagsMatchingFileClasses.set(tag, fileClass);
            }
          });
        }
        if ((_d = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _d.filesPaths) {
          const _filesPaths = (_e = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _e.filesPaths;
          const filesPaths = Array.isArray(_filesPaths) ? [..._filesPaths] : _filesPaths.split(",").map((f) => f.trim());
          filesPaths.forEach((path) => index.filesPathsMatchingFileClasses.set(path, fileClass));
        }
        if ((_f = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _f.bookmarksGroups) {
          const _bookmarksGroups = (_g = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _g.bookmarksGroups;
          const bookmarksGroups = Array.isArray(_bookmarksGroups) ? [..._bookmarksGroups] : _bookmarksGroups.split(",").map((g) => g.trim());
          bookmarksGroups.forEach((group) => index.bookmarksGroupsMatchingFileClasses.set(group, fileClass));
        }
      } catch (error) {
        console.error(error);
      }
    }
  }
};

// src/modals/AddNewFileClassModal.ts
var import_obsidian10 = require("obsidian");
var AddNewFileClassModal = class extends import_obsidian10.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.containerEl.addClass("metadata-menu");
  }
  onOpen() {
    this.titleEl.setText("Add a new fileClass");
    this.containerEl.onkeydown = async (e) => {
      if (e.key == "Enter" && e.altKey) {
        e.preventDefault();
        await this.save();
      }
      if (e.key === "Escape" && e.altKey) {
        this.close();
      }
    };
    this.buildAddFileClassForm();
  }
  buildAddFileClassForm() {
    const fileClassesPath = this.plugin.settings.classFilesPath;
    const fileClassAlias = this.plugin.settings.fileClassAlias;
    const nameContainer = this.contentEl.createDiv({ cls: "field-container" });
    nameContainer.createDiv({ text: `${fileClassAlias} name`, cls: "label" });
    const nameInput = new import_obsidian10.TextComponent(nameContainer);
    nameInput.inputEl.addClass("with-label");
    nameInput.inputEl.addClass("full-width");
    const nameErrorContainer = this.contentEl.createDiv({ cls: "field-error", text: `This ${fileClassAlias} file already exists` });
    cleanActions(this.contentEl, ".footer-actions");
    const actionsContainer = this.contentEl.createDiv({ cls: "footer-actions" });
    actionsContainer.createDiv({ cls: "spacer" });
    const infoContainer = actionsContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    const saveBtn = new import_obsidian10.ButtonComponent(actionsContainer);
    saveBtn.setDisabled(true);
    saveBtn.setIcon("file-plus-2");
    nameErrorContainer.hide();
    nameInput.onChange(async (value) => {
      this.name = nameInput.getValue();
      nameErrorContainer.hide();
      saveBtn.setDisabled(false);
      saveBtn.setCta();
      if (await this.plugin.app.vault.adapter.exists(`${fileClassesPath}${value}.md`)) {
        nameErrorContainer.show();
        saveBtn.setDisabled(true);
        saveBtn.removeCta();
      } else {
        saveBtn.setDisabled(false);
        saveBtn.setCta();
      }
    });
    saveBtn.onClick(async () => await this.save());
  }
  async save() {
    const fileClassName = this.name;
    const classFilesPath = this.plugin.settings.classFilesPath;
    let fCFile;
    const openAfterCreate = this.plugin.fieldIndex.openFileClassManagerAfterIndex;
    if (classFilesPath) {
      try {
        openAfterCreate.push(fileClassName);
        fCFile = await this.plugin.app.vault.create(`${classFilesPath}${fileClassName}.md`, "");
      } catch (error) {
        openAfterCreate.remove(fileClassName);
        new import_obsidian10.Notice("Something went wrong. Impossible to create this fileClass", 3e3);
        return;
      }
    }
    this.close();
  }
};

// src/utils/dataviewUtils.ts
function genuineKeys(obj, depth = 0) {
  const reservedKeys = ["file", "aliases", "tags"];
  const _genuineKeys = [];
  for (const key of Object.keys(obj)) {
    if (depth === 0 && reservedKeys.includes(key))
      continue;
    if (typeof obj[key] === "object" && obj[key] !== null) {
      if (!_genuineKeys.map((k) => k.toLowerCase().replace(/\s/g, "-")).includes(key.toLowerCase().replace(/\s/g, "-"))) {
        _genuineKeys.push(key);
      }
      _genuineKeys.push(...genuineKeys(obj[key], depth + 1).filter((k) => !_genuineKeys.includes(k)));
    } else if (!_genuineKeys.map((k) => k.toLowerCase().replace(/\s/g, "-")).includes(key.toLowerCase().replace(/\s/g, "-"))) {
      _genuineKeys.push(key);
    } else {
      if (key !== key.toLowerCase().replace(/\s/g, "-")) {
        _genuineKeys[_genuineKeys.indexOf(key.toLowerCase().replace(/\s/g, "-"))] = key;
      }
    }
  }
  return _genuineKeys;
}
function legacyGenuineKeys(dvFile) {
  const genuineKeys2 = [];
  if (dvFile)
    Object.keys(dvFile).forEach((key) => {
      if (!genuineKeys2.map((k) => k.toLowerCase().replace(/\s/g, "-")).includes(key.toLowerCase().replace(/\s/g, "-"))) {
        genuineKeys2.push(key);
      } else {
        if (key !== key.toLowerCase().replace(/\s/g, "-")) {
          genuineKeys2[genuineKeys2.indexOf(key.toLowerCase().replace(/\s/g, "-"))] = key;
        }
      }
    });
  return genuineKeys2;
}

// src/options/FileClassOptionsList.ts
var import_obsidian28 = require("obsidian");

// src/components/FileClassViewManager.ts
var import_obsidian27 = require("obsidian");

// src/fileClass/views/fileClassView.ts
var import_obsidian25 = require("obsidian");

// src/fileClass/views/fileClassFieldsView.ts
var import_obsidian11 = require("obsidian");

// src/commands/removeFileClassAttribute.ts
async function removeFileClassAttributeWithId(plugin, fileClass, id) {
  const file = fileClass.getClassFile();
  if (file) {
    await plugin.app.fileManager.processFrontMatter(file, (fm) => {
      fm.fields = fm.fields.filter((f) => f.id !== id);
    });
  }
}

// src/fileClass/FileClassAttributeModal.ts
var FileClassAttributeModal = class extends BaseSettingModal {
  constructor(plugin, fileClass, attr) {
    super(plugin);
    this.plugin = plugin;
    this.fileClass = fileClass;
    this.attr = attr;
    this.initFieldAndLocation();
    this.initFieldManagerAndCommand();
  }
  isNew() {
    return !this.field.id;
  }
  initFieldAndLocation(field) {
    if (this.attr) {
      this.field = this.attr.getField();
      Field_default.copyProperty(this.initialField, this.field);
    } else {
      this.field = new Field_default(this.plugin);
      this.field.fileClassName = this.fileClass.name;
    }
    this.location = 1 /* FileClassAttributeSettings */;
  }
  async onSave() {
    await this.fileClass.updateAttribute(
      this.field.type,
      this.field.name,
      this.field.options,
      this.attr,
      this.field.command,
      this.field.display,
      this.field.style,
      this.field.path
    );
  }
  onCancel() {
    this.close();
  }
  getFileClassName() {
    return this.fileClass.name;
  }
  setFileClassName() {
    this.field.fileClassName = this.fileClass.name;
  }
  async removeField() {
    if (this.attr)
      await this.fileClass.removeAttribute(this.attr);
  }
};

// src/fileClass/views/fileClassFieldsView.ts
var FileClassFieldSetting = class {
  constructor(container, fileClass, fileClassAttribute, plugin) {
    this.container = container;
    this.fileClass = fileClass;
    this.fileClassAttribute = fileClassAttribute;
    this.plugin = plugin;
    this.buildSetting();
  }
  buildSetting() {
    const fCA = this.fileClassAttribute;
    const fieldNameContainer = this.container.createDiv({ cls: "name-container" });
    const level = !fCA.path ? 0 : fCA.path.split("____").length;
    for (let i = 0; i < level; i++) {
      const indentation = fieldNameContainer.createDiv({ cls: "indentation" });
      if (i === level - 1) {
        (0, import_obsidian11.setIcon)(indentation, "corner-down-right");
      }
    }
    fieldNameContainer.createEl("span", { text: fCA.name, cls: "title" });
    const typeContainer = this.container.createDiv({ cls: "type-container" });
    const chip = typeContainer.createDiv({ cls: `chip ${FieldTypeTagClass[fCA.type]}` });
    chip.setText(fCA.type);
    const fieldButtonsContainer = this.container.createDiv({ cls: "buttons-container" });
    this.addEditButton(fieldButtonsContainer);
    this.addDeleteButton(fieldButtonsContainer);
    const fieldOptionsContainer = this.container.createDiv({ cls: "options-container" });
    fieldOptionsContainer.createEl("span", { cls: "description", text: `${fCA.getOptionsString(this.plugin)}` });
  }
  addEditButton(container) {
    const btn = new import_obsidian11.ButtonComponent(container);
    btn.setIcon("pencil");
    btn.setTooltip("Edit");
    btn.onClick(() => {
      let modal = new FileClassAttributeModal(
        this.plugin,
        this.fileClass,
        this.fileClassAttribute
      );
      modal.open();
    });
  }
  addDeleteButton(container) {
    const btn = new import_obsidian11.ButtonComponent(container);
    btn.setIcon("trash");
    btn.setTooltip("Delete");
    btn.setClass("cell");
    btn.onClick(() => {
      removeFileClassAttributeWithId(this.plugin, this.fileClass, this.fileClassAttribute.id);
    });
  }
};
var FileClassFieldsView = class {
  constructor(plugin, viewContainer, fileClass) {
    this.viewContainer = viewContainer;
    this.fileClass = fileClass;
    this.plugin = plugin;
    this.container = this.viewContainer.createDiv({ cls: "fv-fields" });
    this.buildSettings();
  }
  builAddBtn() {
    const footer = this.container.createDiv({ cls: "footer" });
    const btnContainer = footer.createDiv({ cls: "cell" });
    const addBtn = btnContainer.createEl("button");
    (0, import_obsidian11.setIcon)(addBtn, "list-plus");
    addBtn.onclick = async () => {
      const fileClassAttributeModal = new FileClassAttributeModal(this.plugin, FileClass.createFileClass(this.plugin, this.fileClass.name));
      fileClassAttributeModal.open();
    };
  }
  buildSettings() {
    this.container.replaceChildren();
    const fieldsContainer = this.container.createDiv({ cls: "fields-container" });
    const attributes = FileClass.getFileClassAttributes(this.plugin, this.fileClass);
    const sortedAttributes = attributes.filter((attr) => !attr.path);
    let hasError = false;
    while (sortedAttributes.length < attributes.length) {
      const _initial = [...sortedAttributes];
      sortedAttributes.forEach((sAttr, parentIndex) => {
        var _a;
        for (const attr of attributes) {
          if (((_a = attr.path) == null ? void 0 : _a.split("____").last()) === sAttr.id && !sortedAttributes.includes(attr)) {
            const parentLevel = sAttr.getLevel();
            const parentSibling = sortedAttributes.slice(parentIndex + 1).find((oAttr) => oAttr.getLevel() <= parentLevel);
            const parentSiblingIndex = parentSibling ? sortedAttributes.indexOf(parentSibling) : sortedAttributes.length;
            sortedAttributes.splice(parentSiblingIndex, 0, attr);
            break;
          }
        }
      });
      if (_initial.length === sortedAttributes.length) {
        console.error("Impossible to restore field hierarchy, check you fileclass configuration");
        hasError = true;
        break;
      }
    }
    if (hasError) {
      attributes.forEach((attribute) => {
        new FileClassFieldSetting(fieldsContainer, this.fileClass, attribute, this.plugin);
      });
    } else {
      sortedAttributes.forEach((attribute) => {
        new FileClassFieldSetting(fieldsContainer, this.fileClass, attribute, this.plugin);
      });
    }
    this.builAddBtn();
  }
};

// src/fileClass/views/fileClassSettingsView.ts
var import_obsidian12 = require("obsidian");
var ParentSuggestModal = class extends import_obsidian12.SuggestModal {
  constructor(view) {
    super(view.plugin.app);
    this.view = view;
  }
  getSuggestions(query) {
    const fileClassesNames = [...this.view.plugin.fieldIndex.fileClassesName.keys()];
    const currentName = this.view.fileClass.name;
    return fileClassesNames.sort().filter((name) => name !== currentName && name.toLowerCase().includes(query.toLowerCase()));
  }
  onChooseSuggestion(item, evt) {
    const options2 = this.view.fileClass.getFileClassOptions();
    const parent = this.view.plugin.fieldIndex.fileClassesName.get(item);
    if (parent) {
      options2.parent = parent;
      this.view.fileClass.updateOptions(options2);
    }
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
};
var TagSuggestModal = class extends import_obsidian12.SuggestModal {
  constructor(view) {
    super(view.plugin.app);
    this.view = view;
  }
  getSuggestions(query) {
    const tags2 = Object.keys(this.view.plugin.app.metadataCache.getTags());
    return tags2.filter((t) => t.toLowerCase().includes(query.toLowerCase()));
  }
  onChooseSuggestion(item, evt) {
    const options2 = this.view.fileClass.getFileClassOptions();
    const tagNames = options2.tagNames || [];
    tagNames.push(item.replace(/^#(.*)/, "$1"));
    options2.tagNames = tagNames;
    this.view.fileClass.updateOptions(options2);
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
};
var FieldSuggestModal = class extends import_obsidian12.SuggestModal {
  constructor(view) {
    super(view.plugin.app);
    this.view = view;
  }
  getSuggestions(query) {
    const fileClassName = this.view.fileClass.name;
    const fileClassFields = this.view.plugin.fieldIndex.fileClassesFields.get(fileClassName) || [];
    const excludedFields = this.view.fileClass.getFileClassOptions().excludes;
    return fileClassFields.filter(
      (fCA) => {
        var _a;
        return fCA.fileClassName !== fileClassName && ((_a = fCA.fileClassName) == null ? void 0 : _a.toLowerCase().includes(query.toLowerCase())) && !(excludedFields == null ? void 0 : excludedFields.map((attr) => attr.name).includes(fCA.name));
      }
    ).map((fCA) => fCA.name);
  }
  onChooseSuggestion(item, evt) {
    const options2 = this.view.fileClass.getFileClassOptions();
    const excludedFields = options2.excludes || [];
    const excludedField = this.view.fileClass.attributes.find((field) => field.name === item);
    if (excludedField) {
      excludedFields.push(excludedField);
      options2.excludes = excludedFields;
      this.view.fileClass.updateOptions(options2);
    }
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
};
var PathSuggestModal = class extends import_obsidian12.SuggestModal {
  constructor(view) {
    super(view.plugin.app);
    this.view = view;
    this.plugin = view.plugin;
  }
  getSuggestions(query) {
    const abstractFiles = this.plugin.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = query.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian12.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders.map((f) => f.path);
  }
  onChooseSuggestion(item, evt) {
    const options2 = this.view.fileClass.getFileClassOptions();
    const filesPaths = options2.filesPaths || [];
    filesPaths.push(item);
    options2.filesPaths = filesPaths;
    this.view.fileClass.updateOptions(options2);
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
};
var BookmarksGroupSuggestModal = class extends import_obsidian12.SuggestModal {
  constructor(view) {
    super(view.plugin.app);
    this.view = view;
    this.getGroups = (items, groups = [], path = "") => {
      for (const item of items) {
        if (item.type === "group") {
          const subPath = `${path}${path ? "/" : ""}${item.title}`;
          groups.push(subPath);
          if (item.items)
            this.getGroups(item.items, groups, subPath);
        }
      }
    };
    this.plugin = view.plugin;
  }
  getSuggestions(query) {
    const bookmarks = this.plugin.fieldIndex.bookmarks;
    const groups = ["/"];
    if (bookmarks.enabled)
      this.getGroups(bookmarks.instance.items, groups);
    return groups;
  }
  onChooseSuggestion(item, evt) {
    const options2 = this.view.fileClass.getFileClassOptions();
    const bookmarksGroups = options2.bookmarksGroups || [];
    bookmarksGroups.push(item);
    options2.bookmarksGroups = bookmarksGroups;
    this.view.fileClass.updateOptions(options2);
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
};
var FileClassSetting = class {
  constructor(container, label, toolTipText, buildOptionAndAction) {
    this.container = container;
    this.label = label;
    this.toolTipText = toolTipText;
    this.buildOptionAndAction = buildOptionAndAction;
    this.buildSetting();
  }
  buildSetting() {
    this.container.createDiv({ text: this.label, cls: "label" });
    const toolTipBtnContainer = this.container.createDiv({ cls: "tooltip-btn" });
    const tooltipBtn = new import_obsidian12.ButtonComponent(toolTipBtnContainer).setIcon("help-circle").setClass("tooltip-button");
    const action = this.container.createDiv({ cls: "action" });
    this.buildOptionAndAction(action);
    const tooltip = this.container.createDiv({ cls: "tooltip-text" });
    tooltip.innerHTML = this.toolTipText;
    tooltip.hide();
    tooltipBtn.buttonEl.onmouseover = () => tooltip.show();
    tooltipBtn.buttonEl.onmouseout = () => tooltip.hide();
  }
};
var FileClassSettingsView = class {
  constructor(plugin, viewContainer, fileClass) {
    this.viewContainer = viewContainer;
    this.fileClass = fileClass;
    this.plugin = plugin;
    this.container = this.viewContainer.createDiv({ cls: "fv-settings" });
    this.buildSettings();
  }
  buildSettings() {
    this.fileClassOptions = this.fileClass.getFileClassOptions();
    this.container.replaceChildren();
    const settingsContainer = this.container.createDiv({ cls: "settings-container" });
    new FileClassSetting(
      settingsContainer,
      "Max records per page",
      "Maximum lines displayed per page in the table view",
      (action) => this.buildLimitComponent(action)
    );
    new FileClassSetting(
      settingsContainer,
      "Map with tag",
      `Bind tags with ${this.plugin.settings.fileClassAlias}<br/>If Tag Names are empty this fileClass will be bound with the tag of same name`,
      (action) => this.buildMapWithTagComponent(action)
    );
    new FileClassSetting(
      settingsContainer,
      "Button Icon",
      "Name of the icon for the metadata menu button<br/>(lucide.dev)",
      (action) => this.buildIconComponent(action)
    );
    new FileClassSetting(
      settingsContainer,
      "Tag Names",
      `Names of tags to bind this ${this.plugin.settings.fileClassAlias} with`,
      (action) => this.buildBindingComponent(action, this.fileClassOptions.tagNames, TagSuggestModal)
    );
    new FileClassSetting(
      settingsContainer,
      "Files paths",
      `Paths of files to bind this ${this.plugin.settings.fileClassAlias} with`,
      (action) => this.buildBindingComponent(action, this.fileClassOptions.filesPaths, PathSuggestModal)
    );
    new FileClassSetting(
      settingsContainer,
      "Bookmarks groups",
      `Names group of bookmarked files to bind this ${this.plugin.settings.fileClassAlias} with`,
      (action) => this.buildBindingComponent(action, this.fileClassOptions.bookmarksGroups, BookmarksGroupSuggestModal)
    );
    new FileClassSetting(
      settingsContainer,
      "Parent Fileclass",
      "Choose a fileClass to inherit fields from",
      (action) => this.buildExtendComponent(action)
    );
    new FileClassSetting(
      settingsContainer,
      "Excluded Fields",
      `Names of fields to exclude from ancestor fileclasses`,
      (action) => this.buildExcludesComponent(action)
    );
    this.buildSaveBtn();
    this.saveBtn.removeClass("active");
  }
  buildSaveBtn() {
    const footer = this.container.createDiv({ cls: "footer" });
    const btnContainer = footer.createDiv({ cls: "cell" });
    this.saveBtn = btnContainer.createEl("button");
    (0, import_obsidian12.setIcon)(this.saveBtn, "save");
    this.saveBtn.onclick = async () => {
      await this.fileClass.updateOptions(this.fileClassOptions);
      this.saveBtn.removeClass("active");
    };
  }
  buildLimitComponent(action) {
    const input = new import_obsidian12.TextComponent(action);
    input.setValue(`${this.fileClassOptions.limit}`);
    input.onChange((value) => {
      this.saveBtn.addClass("active");
      this.fileClassOptions.limit = parseInt(value) || this.fileClassOptions.limit;
    });
  }
  buildMapWithTagComponent(action) {
    const toggler = new import_obsidian12.ToggleComponent(action);
    toggler.setValue(this.fileClassOptions.mapWithTag);
    toggler.onChange((value) => {
      this.saveBtn.addClass("active");
      this.fileClassOptions.mapWithTag = value;
    });
  }
  buildIconComponent(action) {
    const iconManagerContainer = action.createDiv({ cls: "icon-manager" });
    const input = new import_obsidian12.TextComponent(iconManagerContainer);
    const iconContainer = iconManagerContainer.createDiv({});
    input.setValue(this.fileClassOptions.icon);
    (0, import_obsidian12.setIcon)(iconContainer, this.fileClassOptions.icon);
    input.onChange((value) => {
      this.saveBtn.addClass("active");
      this.fileClassOptions.icon = value;
      (0, import_obsidian12.setIcon)(iconContainer, this.fileClassOptions.icon);
    });
  }
  buildBindingComponent(action, boundItemsNames, suggestModal) {
    const itemsContainer = action.createDiv({ cls: "items" });
    boundItemsNames == null ? void 0 : boundItemsNames.forEach((item) => {
      const itemContainer = itemsContainer.createDiv({ cls: "item chip", text: item });
      new import_obsidian12.ButtonComponent(itemContainer).setIcon("x-circle").setClass("item-remove").onClick(async () => {
        boundItemsNames == null ? void 0 : boundItemsNames.remove(item);
        await this.fileClass.updateOptions(this.fileClassOptions);
      });
    });
    const addBtn = itemsContainer.createEl("button", { cls: "item add" });
    (0, import_obsidian12.setIcon)(addBtn, "plus-circle");
    addBtn.onclick = () => {
      new suggestModal(this).open();
    };
  }
  buildExcludesComponent(action) {
    var _a;
    const fieldsContainer = action.createDiv({ cls: "items" });
    (_a = this.fileClassOptions.excludes) == null ? void 0 : _a.forEach((field) => {
      const fieldontainer = fieldsContainer.createDiv({ cls: "item chip", text: field.name });
      new import_obsidian12.ButtonComponent(fieldontainer).setIcon("x-circle").setClass("item-remove").onClick(async () => {
        var _a2;
        const excludedFields = (_a2 = this.fileClassOptions.excludes) == null ? void 0 : _a2.filter((attr) => attr.name !== field.name);
        this.fileClassOptions.excludes = excludedFields;
        await this.fileClass.updateOptions(this.fileClassOptions);
      });
    });
    const fieldAddBtn = fieldsContainer.createEl("button", { cls: "item" });
    (0, import_obsidian12.setIcon)(fieldAddBtn, "plus-circle");
    fieldAddBtn.onclick = () => {
      new FieldSuggestModal(this).open();
    };
  }
  buildExtendComponent(action) {
    var _a;
    const parentManagerContainer = action.createDiv({ cls: "items" });
    const parentLinkContainer = parentManagerContainer.createDiv({ cls: "item" });
    const parent = this.fileClassOptions.parent;
    if (parent) {
      const path = this.fileClass.getClassFile().path;
      const component = this.plugin;
      import_obsidian12.MarkdownRenderer.renderMarkdown(`[[${parent.name}]]`, parentLinkContainer, path, component);
      (_a = parentLinkContainer.querySelector("a.internal-link")) == null ? void 0 : _a.addEventListener("click", (e) => {
        var _a2;
        this.plugin.app.workspace.openLinkText(
          //@ts-ignore
          (_a2 = e.target.getAttr("data-href").split("/").last()) == null ? void 0 : _a2.replace(/(.*).md/, "$1"),
          path,
          //@ts-ignore
          "tab"
        );
      });
    }
    parentManagerContainer.createDiv({ cls: "item spacer" });
    if (parent) {
      const parentRemoveBtn = parentManagerContainer.createEl("button", { cls: "item" });
      (0, import_obsidian12.setIcon)(parentRemoveBtn, "trash");
      parentRemoveBtn.onclick = async () => {
        delete this.fileClassOptions.parent;
        await this.fileClass.updateOptions(this.fileClassOptions);
      };
    }
    const parentChangeBtn = parentManagerContainer.createEl("button", { cls: "item right-align" });
    (0, import_obsidian12.setIcon)(parentChangeBtn, "edit");
    parentChangeBtn.onclick = () => {
      new ParentSuggestModal(this).open();
    };
  }
};

// src/fileClass/views/fileClassTableView.ts
var import_obsidian24 = require("obsidian");

// src/fileClass/views/tableViewComponents/FieldComponent.ts
var import_obsidian20 = require("obsidian");

// src/fileClass/views/tableViewComponents/RowSorterComponent.ts
var import_obsidian14 = require("obsidian");

// src/fileClass/views/tableViewComponents/OptionsPriorityModal.ts
var import_obsidian13 = require("obsidian");
var OptionsPriorityModal = class extends import_obsidian13.Modal {
  constructor(plugin, fileClassFile, field, parentFieldSet, rowSorterComponent) {
    var _a;
    super(plugin.app);
    this.plugin = plugin;
    this.fileClassFile = fileClassFile;
    this.field = field;
    this.parentFieldSet = parentFieldSet;
    this.rowSorterComponent = rowSorterComponent;
    this.titleEl.setText("Set a custom order by moving the values");
    this.containerEl.addClass("metadata-menu");
    this.initialOrder = ((_a = this.rowSorterComponent.customOrder) == null ? void 0 : _a.length) ? this.rowSorterComponent.customOrder : this.getOptions();
    this.orderedOptions = [...this.initialOrder];
    this.optionsContainer = this.contentEl.createDiv({});
    cleanActions(this.containerEl, ".footer-actions");
    const footerActionsContainer = this.containerEl.createDiv({ cls: "footer-actions" });
    this.buildFooterActions(footerActionsContainer);
  }
  onOpen() {
    this.buildOrderedOptions();
  }
  getOptions() {
    if (this.field === "file") {
      return [];
    } else {
      const field = this.field;
      switch (field.type) {
        case "Boolean" /* Boolean */: {
          return ["true", "false"];
        }
        case "Multi" /* Multi */:
        case "Select" /* Select */: {
          const fieldManager = new FieldManager[field.type](this.plugin, field);
          return fieldManager.getOptionsList();
        }
        case "MultiFile" /* MultiFile */:
        case "File" /* File */: {
          const sortingMethod = new Function("a", "b", `return ${field.options.customSorting}`) || function(a, b) {
            return a.basename < b.basename ? -1 : 1;
          };
          try {
            const fileManager = new FieldManager[field.type](this.plugin, field);
            return fileManager.getFiles().sort(sortingMethod).map((item) => item.basename.trim().replace(/\[\[|\]\]/g, ""));
          } catch (error) {
            return [];
          }
        }
        case "Lookup" /* Lookup */: {
          const _values = [...this.plugin.fieldIndex.fileLookupFieldLastValue.entries()].filter(([fieldId, lookupFiles]) => {
            return fieldId.endsWith(`__related__${this.parentFieldSet.fileClass.name}___${field.name}`) && lookupFiles !== "";
          }).map(([fieldId, lookupFiles]) => lookupFiles).join(",");
          return [...new Set(
            _values.split(",").map((item) => item.trim().replace(/\[\[|\]\]/g, ""))
          )];
        }
        default:
          return [];
      }
    }
  }
  renderOption(option, index) {
    const optionContainer = this.optionsContainer.createDiv({ cls: "suggestion-item value-container" });
    const swapElements = (array, index1, index2) => {
      array[index1] = array.splice(index2, 1, array[index1])[0];
    };
    const buildPrioBtn = (direction) => {
      const btn = new import_obsidian13.ButtonComponent(optionContainer);
      btn.setIcon(btnIcons[direction]);
      btn.setClass("small");
      btn.setDisabled(
        index === 0 && direction === "asc" || index === this.orderedOptions.length && direction === "desc"
      );
      btn.onClick(() => {
        if (direction === "asc") {
          swapElements(this.orderedOptions, index - 1, index);
        } else {
          swapElements(this.orderedOptions, index, index + 1);
        }
        this.buildOrderedOptions();
      });
      return btn;
    };
    buildPrioBtn("asc");
    buildPrioBtn("desc");
    const labelContainer = optionContainer.createDiv({ cls: "label" });
    labelContainer.setText(option);
  }
  buildOrderedOptions() {
    this.optionsContainer.replaceChildren();
    this.orderedOptions.forEach((option, index) => this.renderOption(option, index));
  }
  updateCustomOrder(newOrder) {
    this.rowSorterComponent.customOrder = newOrder;
    this.rowSorterComponent.toggleRowSorterButtonsState("asc");
    this.parentFieldSet.tableView.update();
    this.parentFieldSet.tableView.saveViewBtn.setCta();
  }
  buildConfirm(footerActionsContainer) {
    const infoContainer = footerActionsContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    this.confirmButton = new import_obsidian13.ButtonComponent(footerActionsContainer);
    this.confirmButton.setIcon("checkmark");
    this.confirmButton.onClick(() => {
      this.updateCustomOrder(this.orderedOptions);
      this.close();
    });
  }
  buildFooterActions(footerActionsContainer) {
    footerActionsContainer.createDiv({ cls: "spacer" });
    this.buildConfirm(footerActionsContainer);
    const cancelButton = new import_obsidian13.ButtonComponent(footerActionsContainer);
    cancelButton.setIcon("cross");
    cancelButton.onClick(() => this.close());
    cancelButton.setTooltip("Cancel");
    const refreshButton = new import_obsidian13.ButtonComponent(footerActionsContainer);
    refreshButton.setIcon("refresh-ccw");
    refreshButton.setTooltip("Cancel changes");
    refreshButton.onClick(async () => {
      this.orderedOptions = this.rowSorterComponent.customOrder || this.getOptions();
      this.buildOrderedOptions();
      this.confirmButton.removeCta();
    });
    const resetButton = new import_obsidian13.ButtonComponent(footerActionsContainer);
    resetButton.setIcon("eraser");
    resetButton.setTooltip("Reset initial ordering");
    resetButton.onClick(async () => {
      this.orderedOptions = this.getOptions();
      this.rowSorterComponent.toggleRowSorterButtonsState(void 0);
      this.buildOrderedOptions();
      this.confirmButton.setCta();
    });
    this.modalEl.appendChild(footerActionsContainer);
  }
};

// src/fileClass/views/tableViewComponents/RowSorterComponent.ts
var RowSorterComponent = class {
  constructor(parentFieldset, fileClass, fieldContainer, name, direction, priority, customOrder) {
    this.parentFieldset = parentFieldset;
    this.fileClass = fileClass;
    this.fieldContainer = fieldContainer;
    this.name = name;
    this.direction = direction;
    this.priority = priority;
    this.customOrder = customOrder;
    this.buildSorterBtn = (direction) => {
      const btn = new import_obsidian14.ButtonComponent(this.fieldContainer);
      btn.setIcon(btnIcons[direction]);
      btn.onClick(() => {
        this.toggleRowSorterButtonsState(direction);
        this.parentFieldset.tableView.update();
        this.parentFieldset.tableView.saveViewBtn.setCta();
      });
      return btn;
    };
    this.id = `${this.fileClass}____${this.name}`;
    this.ascBtn = this.buildSorterBtn("asc");
    this.descBtn = this.buildSorterBtn("desc");
    this.customOrderBtn = new import_obsidian14.ButtonComponent(fieldContainer);
    this.customOrderBtn.setIcon("list-ordered");
    this.customOrderBtn.onClick(() => {
      var _a;
      const plugin = this.parentFieldset.plugin;
      const fileClass2 = this.parentFieldset.fileClass;
      const fileClassFile = fileClass2.getClassFile();
      const field = (_a = plugin.fieldIndex.fileClassesFields.get(fileClass2.name)) == null ? void 0 : _a.find((f) => f.isRoot() && f.name === this.name);
      new OptionsPriorityModal(plugin, fileClassFile, field || "file", this.parentFieldset, this).open();
    });
  }
  toggleRowSorterButtonsState(direction) {
    var _a;
    this.direction = this.direction === direction ? void 0 : direction;
    switch (this.direction) {
      case void 0:
        this.ascBtn.buttonEl.removeClass("active");
        this.descBtn.buttonEl.removeClass("active");
        break;
      case "asc":
        this.ascBtn.buttonEl.addClass("active");
        this.descBtn.buttonEl.removeClass("active");
        break;
      case "desc":
        this.ascBtn.buttonEl.removeClass("active");
        this.descBtn.buttonEl.addClass("active");
        break;
    }
    if (!this.direction) {
      this.changeRowSorterPriority(void 0);
    } else {
      if (!this.priority) {
        const newPriority = this.getMaxRowSorterPriority() + 1;
        this.changeRowSorterPriority(newPriority);
      }
    }
    if (!((_a = this.customOrder) == null ? void 0 : _a.length)) {
      this.customOrderBtn.buttonEl.removeClass("active");
    } else {
      this.customOrderBtn.buttonEl.addClass("active");
    }
  }
  changeRowSorterPriority(priority) {
    const currentPriority = this.priority;
    Object.keys(this.parentFieldset.rowSorters).forEach((_id) => {
      const field = this.parentFieldset.fieldComponents.find((f) => f.id === _id);
      const sorter = this.parentFieldset.rowSorters[_id];
      if (_id == this.id) {
        sorter.priority = !currentPriority ? priority : void 0;
        field.priorityLabelContainer.textContent = sorter.priority ? `(${sorter.priority})` : "";
      } else if (currentPriority && sorter.priority && !priority && sorter.priority > currentPriority) {
        sorter.priority = sorter.priority - 1;
        field.priorityLabelContainer.textContent = `(${sorter.priority})`;
      }
    });
  }
  getMaxRowSorterPriority() {
    return Object.values(this.parentFieldset.rowSorters).reduce((intermediateMax, currentSorter) => Math.max(intermediateMax, currentSorter.priority || 0), 0);
  }
};

// src/fileClass/views/tableViewComponents/FilterComponent.ts
var import_obsidian19 = require("obsidian");

// src/fileClass/views/tableViewComponents/OptionsMultiSelectModal.ts
var import_obsidian17 = require("obsidian");

// src/fields/fieldManagers/AbstractFileBasedField.ts
var import_obsidian15 = require("obsidian");
var convertDataviewArrayOfLinkToArrayOfPath = (arr) => {
  return arr.reduce((acc, cur) => {
    if (!cur || !cur.path)
      return acc;
    return [...acc, cur.path];
  }, []);
};
var getFiles = (plugin, field, dvQueryString, currentFile) => {
  const getResults = (api) => {
    try {
      return new Function("dv", "current", `return ${dvQueryString}`)(api, currentFile ? api.page(currentFile.path) : void 0);
    } catch (error) {
      new import_obsidian15.Notice(`Wrong query for field <${field.name}>
check your settings`, 3e3);
    }
  };
  const dataview = plugin.app.plugins.plugins["dataview"];
  if (dvQueryString && (dataview == null ? void 0 : dataview.settings.enableDataviewJs) && (dataview == null ? void 0 : dataview.settings.enableInlineDataviewJs)) {
    try {
      let results = getResults(dataview.api);
      if (!results)
        return [];
      if (Array.isArray(results.values)) {
        results = results.values;
      }
      const filesPath = results.reduce((a, v) => {
        if (!v)
          return a;
        if (v.path)
          return [...a, v.path];
        if (v.file)
          return [...a, v.file.path];
        if (Array.isArray(v))
          return [...a, ...convertDataviewArrayOfLinkToArrayOfPath(v)];
        return a;
      }, []);
      return plugin.app.vault.getMarkdownFiles().filter((f) => filesPath.includes(f.path));
    } catch (error) {
      throw error;
    }
  } else {
    return plugin.app.vault.getMarkdownFiles();
  }
};
var AbstractFileBasedField = class extends FieldManager2 {
  constructor(plugin, field, type) {
    super(plugin, field, type);
    this.getFiles = (currentFile) => getFiles(this.plugin, this.field, this.field.options.dvQueryString, currentFile);
  }
  async buildAndOpenModal(file, indexedPath) {
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const modal = this.modalFactory(this.plugin, file, this.field, eF, indexedPath);
    modal.open();
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const action = async () => await this.buildAndOpenModal(file, indexedPath);
    if (AbstractFileBasedField.isSuggest(location)) {
      location.options.push({
        id: `update_${name}`,
        actionLabel: `<span>Update <b>${name}</b></span>`,
        action,
        icon: FieldIcon["File" /* File */]
      });
    } else if (AbstractFileBasedField.isFieldOptions(location)) {
      location.addOption(FieldIcon["File" /* File */], action, `Update ${name}'s value`);
    }
    ;
  }
  createFileContainer(container) {
    const dvQueryStringTopContainer = container.createDiv({ cls: "vstacked" });
    dvQueryStringTopContainer.createEl("span", { text: "Dataview Query (optional)", cls: "field-option" });
    const dvQueryStringContainer = dvQueryStringTopContainer.createDiv({ cls: "field-container" });
    this.dvQueryString = new import_obsidian15.TextAreaComponent(dvQueryStringContainer);
    this.dvQueryString.inputEl.cols = 50;
    this.dvQueryString.inputEl.rows = 4;
    this.dvQueryString.setValue(this.field.options.dvQueryString || "");
    this.dvQueryString.inputEl.addClass("full-width");
    this.dvQueryString.onChange((value) => {
      this.field.options.dvQueryString = value;
      FieldSettingsModal.removeValidationError(this.dvQueryString);
    });
    const customeRenderingTopContainer = container.createDiv({ cls: "vstacked" });
    customeRenderingTopContainer.createEl("span", { text: "Alias" });
    customeRenderingTopContainer.createEl("span", { text: "Personalise the rendering of your links' aliases with a function returning a string (<page> object is available)", cls: "sub-text" });
    customeRenderingTopContainer.createEl("code", {
      text: `function(page) { return <function using "page">; }`
    });
    const customeRenderingContainer = customeRenderingTopContainer.createDiv({ cls: "field-container" });
    const customRendering = new import_obsidian15.TextAreaComponent(customeRenderingContainer);
    customRendering.inputEl.cols = 50;
    customRendering.inputEl.rows = 4;
    customRendering.inputEl.addClass("full-width");
    customRendering.setValue(this.field.options.customRendering || "");
    customRendering.setPlaceholder('Javascript string, the "page" (dataview page type) variable is available\nexample 1: page.file.name\nexample 2: `${page.file.name} of gender ${page.gender}`');
    customRendering.onChange((value) => {
      this.field.options.customRendering = value;
      FieldSettingsModal.removeValidationError(customRendering);
    });
    const customSortingTopContainer = container.createDiv({ cls: "vstacked" });
    customSortingTopContainer.createEl("span", { text: "Sorting order" });
    customSortingTopContainer.createEl("span", { text: "Personalise the sorting order of your links with a instruction taking 2 files (a, b) and returning -1, 0 or 1", cls: "sub-text" });
    customSortingTopContainer.createEl("code", {
      text: `(a: TFile, b: TFile): number`
    });
    const customSortingContainer = customSortingTopContainer.createDiv({ cls: "field-container" });
    const customSorting = new import_obsidian15.TextAreaComponent(customSortingContainer);
    customSorting.inputEl.cols = 50;
    customSorting.inputEl.rows = 4;
    customSorting.inputEl.addClass("full-width");
    customSorting.setValue(this.field.options.customSorting || "");
    customSorting.setPlaceholder("Javascript instruction, (a: TFile, b: TFile): number\nexample 1 (alphabetical order): a.basename < b.basename ? 1 : -1 \nexample 2 (creation time newer to older): b.stat.ctime - b.stat.ctime");
    customSorting.onChange((value) => {
      this.field.options.customSorting = value;
      FieldSettingsModal.removeValidationError(customSorting);
    });
  }
  createSettingContainer(parentContainer, plugin, location) {
    this.createFileContainer(parentContainer);
  }
  getOptionsStr() {
    return this.field.options.dvQueryString || "";
  }
  validateOptions() {
    return true;
  }
  createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = this.modalFactory(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.titleEl.setText(`Enter value for ${selectedFieldName}`);
    fieldModal.open();
  }
  createDvField(dv, p, fieldContainer, attrs = {}) {
    var _a;
    attrs.cls = "value-container";
    fieldContainer.appendChild(dv.el("span", p[this.field.name] || "", attrs));
    const searchBtn = fieldContainer.createEl("button");
    (0, import_obsidian15.setIcon)(searchBtn, FieldIcon["File" /* File */]);
    const spacer = fieldContainer.createEl("div", { cls: "spacer-1" });
    const file = this.plugin.app.vault.getAbstractFileByPath(p["file"]["path"]);
    if (file instanceof import_obsidian15.TFile && file.extension == "md") {
      searchBtn.onclick = async () => await this.buildAndOpenModal(file);
    } else {
      searchBtn.onclick = async () => {
      };
    }
    if (!((_a = attrs == null ? void 0 : attrs.options) == null ? void 0 : _a.alwaysOn)) {
      searchBtn.hide();
      spacer.show();
      fieldContainer.onmouseover = () => {
        searchBtn.show();
        spacer.hide();
      };
      fieldContainer.onmouseout = () => {
        searchBtn.hide();
        spacer.show();
      };
    }
  }
};

// src/modals/fields/SingleFileModal.ts
var import_obsidian16 = require("obsidian");
var FileFuzzySuggester = class extends import_obsidian16.FuzzySuggestModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    var _a;
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    const initialValueObject = ((_a = this.eF) == null ? void 0 : _a.value) || "";
    const link = getLink(initialValueObject, this.file);
    if (link) {
      const file2 = this.plugin.app.vault.getAbstractFileByPath(link.path);
      if (file2 instanceof import_obsidian16.TFile)
        this.selectedFile = file2;
    }
    this.containerEl.addClass("metadata-menu");
  }
  onClose() {
    var _a;
    (_a = this.previousModal) == null ? void 0 : _a.open();
  }
  getItems() {
    const sortingMethod = new Function("a", "b", `return ${this.field.options.customSorting}`) || function(a, b) {
      return a.basename < b.basename ? -1 : 1;
    };
    try {
      const fileManager = new FieldManager[this.field.type](this.plugin, this.field);
      return fileManager.getFiles(this.file).sort(sortingMethod);
    } catch (error) {
      this.close();
      throw error;
    }
  }
  getItemText(item) {
    return item.basename;
  }
  renderSuggestion(value, el) {
    var _a, _b;
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    if (dvApi && this.field.options.customRendering) {
      const suggestionContainer = el.createDiv({ cls: "item-with-add-on" });
      suggestionContainer.createDiv({
        text: new Function("page", `return ${this.field.options.customRendering}`)(dvApi.page(value.item.path))
      });
      const filePath = suggestionContainer.createDiv({ cls: "add-on" });
      filePath.setText(value.item.path);
    } else {
      el.setText(value.item.basename);
    }
    el.addClass("value-container");
    const spacer = this.containerEl.createDiv({ cls: "spacer" });
    el.appendChild(spacer);
    if (((_b = this.selectedFile) == null ? void 0 : _b.path) === value.item.path) {
      el.addClass("value-checked");
      const iconContainer = el.createDiv({ cls: "icon-container" });
      (0, import_obsidian16.setIcon)(iconContainer, "check-circle");
    }
    this.inputEl.focus();
  }
  async onChooseItem(item) {
    var _a, _b;
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    let alias = void 0;
    if (dvApi && this.field.options.customRendering) {
      alias = new Function("page", `return ${this.field.options.customRendering}`)(dvApi.page(item.path));
    }
    const value = FileField.buildMarkDownLink(this.plugin, this.file, item.basename, void 0, alias);
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
    (_b = this.previousModal) == null ? void 0 : _b.open();
  }
};

// src/fields/fieldManagers/FileField.ts
var FileField = class extends AbstractFileBasedField {
  constructor(plugin, field) {
    super(plugin, field, "File" /* File */);
  }
  modalFactory(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    return new FileFuzzySuggester(plugin, file, field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
  }
  displayValue(container, file, value, onClicked) {
    const link = getLink(value, file);
    if (link == null ? void 0 : link.path) {
      const linkText = link.path.split("/").last() || "";
      const linkEl = container.createEl("a", { text: linkText.replace(/(.*).md/, "$1") });
      linkEl.onclick = () => {
        this.plugin.app.workspace.openLinkText(link.path, file.path, true);
        onClicked();
      };
    } else {
      container.createDiv({ text: value });
    }
    container.createDiv();
  }
};

// src/fileClass/views/tableViewComponents/OptionsMultiSelectModal.ts
var fieldStates = /* @__PURE__ */ ((fieldStates2) => {
  fieldStates2["__empty__"] = "__empty__";
  fieldStates2["__notEmpty__"] = "__notEmpty__";
  fieldStates2["__notFound__"] = "__notFound__";
  fieldStates2["__existing__"] = "__existing__";
  return fieldStates2;
})(fieldStates || {});
var displayValue = {
  __empty__: "Empty Fields",
  __notEmpty__: "Not Empty Fields",
  __notFound__: "Not Found Fields",
  __existing__: "Existing Fields"
};
var displayIcon = {
  __empty__: "box-select",
  __notEmpty__: "plus-square",
  __notFound__: "x-circle",
  __existing__: "circle-dot"
};
var OptionsMultiSelectModal = class extends import_obsidian17.SuggestModal {
  constructor(plugin, fileClassFile, field, parentFieldSet) {
    super(plugin.app);
    this.plugin = plugin;
    this.fileClassFile = fileClassFile;
    this.field = field;
    this.parentFieldSet = parentFieldSet;
    this.containerEl.addClass("metadata-menu");
    const inputContainer = this.containerEl.createDiv({ cls: "suggester-input" });
    inputContainer.appendChild(this.inputEl);
    this.containerEl.find(".prompt").prepend(inputContainer);
    cleanActions(this.containerEl, ".footer-actions");
    const footerActionsContainer = this.containerEl.createDiv({ cls: "footer-actions" });
    this.buildFooterActions(footerActionsContainer);
    const id = this.field === "file" ? "file" : `${this.fileClassFile.basename.replace(/.md$/, "")}____${this.field.name}`;
    this.input = this.parentFieldSet.filters[id].filter;
    const initialOptions = this.input.getValue();
    if (initialOptions) {
      if (Array.isArray(initialOptions)) {
        this.selectedOptions = initialOptions.map((item) => {
          const link = getLink(item, fileClassFile);
          if (link) {
            return FileField.buildMarkDownLink(this.plugin, fileClassFile, link.path);
          } else {
            return item.toString();
          }
        });
        this.selectedOptions = initialOptions.map((item) => item.toString());
      } else if (typeof initialOptions === "string" && initialOptions.toString().startsWith("[[")) {
        this.selectedOptions = initialOptions.split(",").map((item) => item.trim());
      } else {
        const link = getLink(initialOptions, fileClassFile);
        if (link) {
          this.selectedOptions = [`[[${link.path.replace(".md", "")}]]`];
        } else if (typeof initialOptions === "string") {
          this.selectedOptions = initialOptions.toString().replace(/^\[(.*)\]$/, "$1").split(",").map((item) => item.trim());
        }
      }
    } else {
      this.selectedOptions = [];
    }
    this.containerEl.onkeydown = async (e) => {
      if (e.key == "Enter" && e.altKey) {
        await this.replaceValues();
        this.close();
      }
    };
  }
  getSuggestions(query) {
    if (this.field === "file") {
      return [];
    } else {
      const commonStates = Object.keys(fieldStates);
      const field = this.field;
      switch (field.type) {
        case "Boolean" /* Boolean */: {
          return [...commonStates, "true", "false"];
        }
        case "Multi" /* Multi */:
        case "Select" /* Select */: {
          const fieldManager = new FieldManager[field.type](this.plugin, this.field);
          const values = fieldManager.getOptionsList().filter((o) => String(o).toLowerCase().includes(query.toLowerCase()));
          return [...commonStates, ...values];
        }
        case "MultiFile" /* MultiFile */:
        case "File" /* File */: {
          const sortingMethod = new Function("a", "b", `return ${field.options.customSorting}`) || function(a, b) {
            return a.basename < b.basename ? -1 : 1;
          };
          try {
            const fileManager = new FieldManager[field.type](this.plugin, this.field);
            const values = fileManager.getFiles().sort(sortingMethod).map((item) => item.basename.trim().replace(/\[\[|\]\]/g, "")).filter((o) => String(o).toLowerCase().includes(query.toLowerCase()));
            return ["__empty__", "__notEmpty__", ...values];
          } catch (error) {
            return [];
          }
        }
        case "Lookup" /* Lookup */: {
          const _values = [...this.plugin.fieldIndex.fileLookupFieldLastValue.entries()].filter(([fieldId, lookupFiles]) => {
            return fieldId.endsWith(`__related__${this.fileClassFile.basename}___${this.field.name}`) && lookupFiles !== "";
          }).map(([fieldId, lookupFiles]) => lookupFiles).join(",");
          const values = [...new Set(
            _values.split(",").map((item) => item.trim().replace(/\[\[|\]\]/g, "")).filter((o) => String(o).toLowerCase().includes(query.toLowerCase()))
          )];
          return [...commonStates, ...values];
        }
        default:
          return [...commonStates];
      }
    }
  }
  buildFooterActions(footerActionsContainer) {
    footerActionsContainer.createDiv({ cls: "spacer" });
    this.buildConfirm(footerActionsContainer);
    const cancelButton = new import_obsidian17.ButtonComponent(footerActionsContainer);
    cancelButton.setIcon("cross");
    cancelButton.onClick(() => this.close());
    cancelButton.setTooltip("Cancel");
    const clearButton = new import_obsidian17.ButtonComponent(footerActionsContainer);
    clearButton.setIcon("filter-x");
    clearButton.setTooltip("Clear filtered value(s)");
    clearButton.onClick(async () => {
      this.input.setValue("");
      this.parentFieldSet.tableView.update();
      this.parentFieldSet.tableView.saveViewBtn.setCta();
      this.close();
    });
    clearButton.buttonEl.addClass("danger");
    this.modalEl.appendChild(footerActionsContainer);
  }
  buildConfirm(footerActionsContainer) {
    const infoContainer = footerActionsContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    const confirmButton = new import_obsidian17.ButtonComponent(footerActionsContainer);
    confirmButton.setIcon("checkmark");
    confirmButton.onClick(async () => {
      await this.replaceValues();
      this.close();
    });
  }
  async replaceValues() {
    const options2 = this.selectedOptions;
    this.input.inputEl.value = options2.join(", ");
    this.parentFieldSet.tableView.update();
    this.parentFieldSet.tableView.saveViewBtn.setCta();
    this.close();
  }
  renderSelected() {
    const chooser = this.chooser;
    const suggestions = chooser.suggestions;
    const values = chooser.values;
    suggestions.forEach((s, i) => {
      if (this.selectedOptions.includes(values[i].toString())) {
        s.addClass("value-checked");
        if (s.querySelectorAll(".icon-container").length == 0) {
          const iconContainer = s.createDiv({ cls: "icon-container" });
          (0, import_obsidian17.setIcon)(iconContainer, "check-circle");
        }
      } else {
        s.removeClass("value-checked");
        s.querySelectorAll(".icon-container").forEach((icon) => icon.remove());
      }
    });
  }
  renderSuggestion(value, el) {
    const labelContainer = el.createDiv({ cls: "label-with-icon-container" });
    const icon = labelContainer.createDiv({ cls: "icon" });
    if (Object.keys(fieldStates).includes(value)) {
      (0, import_obsidian17.setIcon)(icon, displayIcon[value]);
    }
    const label = labelContainer.createDiv({ cls: "label" });
    let labelText = "";
    if (Object.keys(fieldStates).includes(value)) {
      labelText = displayValue[value];
    } else {
      labelText = `${value.slice(0, 50)}${value.length > 50 ? "..." : ""}`;
    }
    label.setText(labelText);
    el.addClass("value-container");
    const spacer = this.containerEl.createDiv({ cls: "spacer" });
    el.appendChild(spacer);
    if (this.selectedOptions.includes(value.toString())) {
      el.addClass("value-checked");
      const iconContainer = el.createDiv({ cls: "icon-container" });
      (0, import_obsidian17.setIcon)(iconContainer, "check-circle");
    }
    this.inputEl.focus();
  }
  selectSuggestion(value, evt) {
    if (this.selectedOptions.includes(value.toString())) {
      this.selectedOptions.remove(value.toString());
    } else {
      if (Object.keys(fieldStates).includes(value)) {
        this.selectedOptions = [value];
      } else {
        this.selectedOptions = [...this.selectedOptions.filter((o) => !Object.keys(fieldStates).includes(o))];
        this.selectedOptions.push(value.toString());
      }
    }
    this.renderSelected();
  }
  onChooseSuggestion(item, evt) {
  }
};

// src/fileClass/views/tableViewComponents/CustomFilterModal.ts
var import_obsidian18 = require("obsidian");
var CustomFilterModal = class extends import_obsidian18.Modal {
  constructor(plugin, parentFieldSet, filterComponent) {
    super(plugin.app);
    this.plugin = plugin;
    this.parentFieldSet = parentFieldSet;
    this.filterComponent = filterComponent;
    this.containerEl.addClass("metadata-menu");
    this.titleEl.setText("Enter a custom filtering function");
    this.buildInput();
    cleanActions(this.containerEl, ".footer-actions");
    const footerActionsContainer = this.containerEl.createDiv({ cls: "footer-actions" });
    this.buildFooterActions(footerActionsContainer);
  }
  buildInput() {
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: `(value: string, current: Object): boolean => {` });
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: `/*` });
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: `value is the value of the file's ${this.filterComponent.name} field` });
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: `current is the current page (dv.page) if this view is embedded in a codeblock` });
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: `returns a boolean, ` });
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: `double quote have to be escaped like this \\", ` });
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: `example:` });
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: `return value < current.priority;` });
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: `*/` });
    const subContent = this.contentEl.createDiv({ cls: "field-container" });
    this.filterFunctionInput = new import_obsidian18.TextAreaComponent(subContent).setValue(this.filterComponent.customFilter || "").onChange(() => {
      this.confirmButton.setCta();
    });
    this.filterFunctionInput.inputEl.rows = 6;
    this.filterFunctionInput.inputEl.addClass("full-width");
    this.contentEl.createDiv({ cls: "info-code" }).createEl("code", { text: "};" });
  }
  updateCustomFilter() {
    this.filterComponent.customFilter = this.filterFunctionInput.getValue();
    this.filterComponent.toggleCustomFilterState();
    this.parentFieldSet.tableView.update();
    this.parentFieldSet.tableView.saveViewBtn.setCta();
  }
  buildConfirm(footerActionsContainer) {
    const infoContainer = footerActionsContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    this.confirmButton = new import_obsidian18.ButtonComponent(footerActionsContainer);
    this.confirmButton.setIcon("checkmark");
    this.confirmButton.onClick(() => {
      if (true)
        this.updateCustomFilter();
      this.close();
    });
  }
  buildFooterActions(footerActionsContainer) {
    footerActionsContainer.createDiv({ cls: "spacer" });
    this.buildConfirm(footerActionsContainer);
    const cancelButton = new import_obsidian18.ButtonComponent(footerActionsContainer);
    cancelButton.setIcon("cross");
    cancelButton.onClick(() => this.close());
    cancelButton.setTooltip("Cancel");
    const refreshButton = new import_obsidian18.ButtonComponent(footerActionsContainer);
    refreshButton.setIcon("refresh-ccw");
    refreshButton.setTooltip("Cancel changes");
    refreshButton.onClick(async () => {
      this.filterFunctionInput.setValue(this.filterComponent.customFilter);
      this.confirmButton.removeCta();
    });
    const resetButton = new import_obsidian18.ButtonComponent(footerActionsContainer);
    resetButton.setIcon("eraser");
    resetButton.setTooltip("Reset initial ordering");
    resetButton.onClick(async () => {
      this.filterFunctionInput.setValue("");
      this.filterComponent.toggleCustomFilterState();
      this.confirmButton.setCta();
    });
    this.modalEl.appendChild(footerActionsContainer);
  }
};

// src/fileClass/views/tableViewComponents/FilterComponent.ts
var FilterComponent = class {
  constructor(fileClass, container, name, parentFieldSet, debounced) {
    this.fileClass = fileClass;
    this.container = container;
    this.name = name;
    this.parentFieldSet = parentFieldSet;
    this.debounced = debounced;
    this.id = `${fileClass.name}____${this.name}`;
    this.build();
  }
  build() {
    this.filter = new import_obsidian19.TextComponent(this.container);
    this.container.addClass("filter-with-dropdown");
    this.filter.setValue("");
    this.filter.onChange((value) => {
      this.filter.inputEl.value = value;
      this.debounced(this.parentFieldSet);
    });
    if (this.name !== "file") {
      this.buildDropdownBtn();
    }
    this.buildCustomFilterBtn();
  }
  buildDropdownBtn() {
    var _a;
    const button = this.container.createEl("button", { cls: "infield-button" });
    (_a = this.filter.inputEl.parentElement) == null ? void 0 : _a.appendChild(button);
    (0, import_obsidian19.setIcon)(button, "chevron-down");
    button.onclick = () => {
      var _a2;
      const plugin = this.parentFieldSet.plugin;
      const fileClassFile = this.fileClass.getClassFile();
      const field = (_a2 = plugin.fieldIndex.fileClassesFields.get(this.fileClass.name)) == null ? void 0 : _a2.find((f) => f.isRoot() && f.name === this.name);
      new OptionsMultiSelectModal(plugin, fileClassFile, field || "file", this.parentFieldSet).open();
    };
  }
  toggleCustomFilterState() {
    if (this.customFilter)
      this.filterBtn.buttonEl.addClass("active");
    else
      this.filterBtn.buttonEl.removeClass("active");
  }
  buildCustomFilterBtn() {
    var _a;
    this.filterBtn = new import_obsidian19.ButtonComponent(this.container);
    this.filterBtn.buttonEl.addClass("infield-button");
    (_a = this.filter.inputEl.parentElement) == null ? void 0 : _a.appendChild(this.filterBtn.buttonEl);
    this.filterBtn.setIcon("code-2");
    this.filterBtn.onClick(() => {
      const plugin = this.parentFieldSet.plugin;
      new CustomFilterModal(plugin, this.parentFieldSet, this).open();
    });
  }
};

// src/fileClass/views/tableViewComponents/FieldComponent.ts
var FieldComponent = class {
  constructor(fileClass, container, parentFieldSet, name, label, columnPosition, rowPriority, isColumnHidden = false, rowSortingDirection = void 0, query = "", customOrder = []) {
    this.fileClass = fileClass;
    this.container = container;
    this.parentFieldSet = parentFieldSet;
    this.name = name;
    this.label = label;
    this.columnPosition = columnPosition;
    this.rowPriority = rowPriority;
    this.isColumnHidden = isColumnHidden;
    this.rowSortingDirection = rowSortingDirection;
    this.query = query;
    this.customOrder = customOrder;
    this.id = `${this.fileClass.name}____${this.name}`;
    this.buildFieldHeaderComponent();
    this.buildFieldComponent();
  }
  canMove(direction) {
    return !(this.columnPosition === 0 && direction === "left" || this.columnPosition === this.parentFieldSet.fieldComponents.length - 1 && direction === "right");
  }
  buildColumnMoverBtn(component) {
    const buildBtn = (direction) => {
      const btn = new import_obsidian20.ButtonComponent(component);
      btn.setIcon(btnIcons[direction]);
      btn.onClick(() => {
        if (this.canMove(direction)) {
          this.parentFieldSet.moveColumn(this.id, direction);
          this.parentFieldSet.reorderFields();
          this.parentFieldSet.tableView.update();
          this.parentFieldSet.tableView.saveViewBtn.setCta();
        }
      });
      return btn;
    };
    const leftBtn = buildBtn("left");
    const rightBtn = buildBtn("right");
    this.parentFieldSet.columnManagers[this.id] = {
      id: this.id,
      name: this.name,
      hidden: false,
      leftBtn,
      rightBtn,
      position: this.columnPosition
    };
  }
  buildRowSorterComponent(fileClass, fieldHeader) {
    const rowSorterComponent = new RowSorterComponent(
      this.parentFieldSet,
      fileClass,
      fieldHeader,
      this.name,
      this.rowSortingDirection,
      this.rowPriority,
      this.customOrder
    );
    this.parentFieldSet.rowSorters[this.id] = rowSorterComponent;
  }
  setVisibilityButtonState(isHidden) {
    this.isColumnHidden = isHidden;
    this.parentFieldSet.columnManagers[this.id].hidden = this.isColumnHidden;
    this.visibilityButton.setIcon(this.isColumnHidden ? "eye-off" : "eye");
  }
  buildVisibilityBtn(component) {
    this.visibilityButton = new import_obsidian20.ButtonComponent(component).setIcon(this.isColumnHidden ? "eye-off" : "eye").onClick(() => {
      this.setVisibilityButtonState(!this.isColumnHidden);
      this.parentFieldSet.tableView.update();
      this.parentFieldSet.tableView.saveViewBtn.setCta();
    });
  }
  buildFieldHeaderComponent() {
    var _a;
    if (this.parentFieldSet.children.length) {
      this.container.createDiv({
        text: this.fileClass.name,
        cls: "field-fileclass-header"
      });
    }
    const container = this.container.createDiv({ cls: "field-header" });
    this.buildRowSorterComponent(this.fileClass, container);
    const prioAndLabelContainer = container.createDiv({ cls: "label-container" });
    prioAndLabelContainer.createDiv({ text: this.label, cls: "field-name" });
    const priorityLabel = ((_a = this.parentFieldSet.rowSorters[this.id]) == null ? void 0 : _a.priority) ? `(${this.parentFieldSet.rowSorters[this.id].priority})` : "";
    this.priorityLabelContainer = prioAndLabelContainer.createDiv({ cls: "priority", text: priorityLabel });
    this.buildVisibilityBtn(container);
    this.buildColumnMoverBtn(container);
  }
  buildFilter(name, debounced) {
    const fieldFilterContainer = this.container.createDiv({ cls: "filter-input" });
    const filterComponent = new FilterComponent(this.fileClass, fieldFilterContainer, name, this.parentFieldSet, debounced);
    this.parentFieldSet.filters[filterComponent.id] = filterComponent;
  }
  buildFieldComponent() {
    var _a;
    const field = (_a = this.parentFieldSet.plugin.fieldIndex.fileClassesFields.get(this.parentFieldSet.fileClass.name)) == null ? void 0 : _a.find((f) => f.name === this.name);
    const debounced = (0, import_obsidian20.debounce)((fieldset) => {
      fieldset.tableView.update();
      this.parentFieldSet.tableView.saveViewBtn.setCta();
    }, 1e3, true);
    this.buildFilter((field == null ? void 0 : field.name) || "file", debounced);
  }
};

// src/fileClass/views/tableViewComponents/tableViewFieldSet.ts
var btnIcons = {
  "asc": "chevron-up",
  "desc": "chevron-down",
  "left": "chevron-left",
  "right": "chevron-right"
};
var FieldSet4 = class {
  constructor(tableView, container) {
    this.tableView = tableView;
    this.container = container;
    this.fieldComponents = [];
    this.filters = {};
    this.rowSorters = {};
    this.columnManagers = {};
    this.plugin = tableView.plugin;
    this.build();
  }
  build(children) {
    this.fileClass = this.plugin.fieldIndex.fileClassesName.get(this.tableView.fileClass.name);
    this.children = children || this.fileClass.getViewChildren(this.tableView.manager.selectedView);
    this.fileClasses = [this.fileClass, ...this.children.map((c) => c.fileClass)];
    this.container.replaceChildren();
    this.fieldComponents = [];
    const fileFieldContainer = this.container.createDiv({ cls: "field-container" });
    const fieldComponent = new FieldComponent(this.fileClass, fileFieldContainer, this, "file", "File Name", 0);
    this.fieldComponents.push(fieldComponent);
    let index = 0;
    [this.fileClass, ...this.children.map((c) => c.fileClass)].forEach((_fC) => {
      var _a;
      const fields = ((_a = this.plugin.fieldIndex.fileClassesFields.get(_fC.name)) == null ? void 0 : _a.filter((_f) => _f.isRoot())) || [];
      for (const [_index, field] of fields.entries()) {
        const fieldContainer = this.container.createDiv({ cls: "field-container" });
        this.fieldComponents.push(new FieldComponent(_fC, fieldContainer, this, field.name, field.name, _index + index + 1));
      }
      index += fields.length;
    });
  }
  reorderFields() {
    this.fieldComponents.sort((f1, f2) => f1.columnPosition - f2.columnPosition).forEach((field) => this.container.appendChild(field.container));
  }
  moveColumn(id, direction) {
    const currentPosition = this.columnManagers[id].position;
    Object.keys(this.columnManagers).forEach((_id) => {
      const mover = this.columnManagers[_id];
      const field = this.fieldComponents.find((f) => f.id === _id);
      switch (direction) {
        case "left":
          if (mover.position === currentPosition - 1) {
            mover.position++;
            field.columnPosition++;
            break;
          }
          if (mover.position === currentPosition) {
            mover.position--;
            field.columnPosition--;
            break;
          }
          break;
        case "right":
          if (mover.position === currentPosition + 1) {
            mover.position--;
            field.columnPosition--;
            break;
          }
          if (mover.position === currentPosition) {
            mover.position++;
            field.columnPosition++;
            break;
          }
          break;
      }
    });
  }
  reset(children, updateNeeded = true) {
    this.rowSorters = {};
    this.filters = {};
    this.columnManagers = {};
    this.build(children);
    if (updateNeeded)
      this.tableView.update();
    this.tableView.saveViewBtn.setCta();
  }
  getParams() {
    const children = this.children;
    const filters = Object.entries(this.filters).map(([id, filterComponent]) => {
      return {
        id,
        name: filterComponent.name,
        query: filterComponent.filter.getValue(),
        customFilter: filterComponent.customFilter
      };
    });
    const sorters = Object.entries(this.rowSorters).filter(([id, s]) => {
      var _a;
      return s.direction !== void 0 || ((_a = s.customOrder) == null ? void 0 : _a.length);
    }).map(([id, sorter]) => {
      return {
        id,
        name: sorter.name,
        direction: sorter.direction || "asc",
        priority: sorter.priority || 0,
        customOrder: sorter.customOrder || []
      };
    });
    const columns = Object.entries(this.columnManagers).map(([id, columnManager]) => {
      return {
        id,
        name: columnManager.name,
        hidden: columnManager.hidden,
        position: columnManager.position
      };
    });
    return {
      children: children.map((c) => c.name),
      filters,
      sorters,
      columns
    };
  }
  resetColumnManagers() {
    Object.keys(this.columnManagers).forEach((id) => {
      const fCFields = [];
      this.fileClasses.forEach((fC) => {
        var _a, _b;
        (_b = (_a = this.plugin.fieldIndex.fileClassesFields.get(this.fileClass.name)) == null ? void 0 : _a.filter((_f) => _f.isRoot())) == null ? void 0 : _b.forEach((_f) => {
          fCFields.push(_f);
        });
      });
      for (const [_index, _field] of fCFields.entries()) {
        const field = this.fieldComponents.find((f) => f.name === _field.name && f.fileClass.name === _field.fileClassName);
        if (field && field.id === id) {
          field.columnPosition = _index + 1;
          field.setVisibilityButtonState(false);
          this.columnManagers[id].position = _index + 1;
        }
      }
      if (id === "file") {
        const field = this.fieldComponents.find((f) => f.name === "file");
        if (field) {
          field.columnPosition = 0;
          field.setVisibilityButtonState(false);
          this.columnManagers[id].position = 0;
        }
      }
    });
  }
  changeView(_name, updateNeeded = true) {
    const options2 = this.fileClass.getFileClassOptions();
    const savedViews = options2.savedViews || [];
    this.tableView.manager.selectedView = _name || "";
    this.reset(void 0, updateNeeded);
    if (_name && savedViews.find((view) => view.name === _name)) {
      const savedView = savedViews.find((view) => view.name === _name);
      Object.keys(this.filters).forEach((id) => {
        const filterComponent = this.filters[id];
        const savedFilter = savedView == null ? void 0 : savedView.filters.find((f) => f.id === id || !f.id && f.name === filterComponent.name);
        filterComponent.filter.inputEl.value = (savedFilter == null ? void 0 : savedFilter.query) || "";
        filterComponent.customFilter = (savedFilter == null ? void 0 : savedFilter.customFilter) || "";
        filterComponent.toggleCustomFilterState();
      });
      Object.keys(this.rowSorters).forEach((id) => {
        var _a;
        const rowSorter = this.rowSorters[id];
        const savedSorter = (_a = savedView == null ? void 0 : savedView.sorters) == null ? void 0 : _a.find((f) => f.id === id || !f.id && f.name === rowSorter.name);
        if (savedSorter) {
          rowSorter.priority = savedSorter.priority;
          rowSorter.customOrder = savedSorter.customOrder;
          rowSorter.toggleRowSorterButtonsState(savedSorter.direction);
          const field = this.fieldComponents.find((f) => f.id === id);
          field.priorityLabelContainer.textContent = `(${savedSorter.priority})`;
        } else {
          rowSorter.direction = void 0;
          rowSorter.ascBtn.buttonEl.removeClass("active");
          rowSorter.descBtn.buttonEl.removeClass("active");
        }
      });
      Object.keys(this.columnManagers).forEach((id) => {
        const mover = this.columnManagers[id];
        const field = this.fieldComponents.find((f) => f.id === id || !f.id && f.name === mover.name);
        for (const column of savedView.columns || []) {
          if (column.id === id) {
            mover.position = column.position;
            field.columnPosition = column.position;
            field.setVisibilityButtonState(column.hidden);
          }
        }
      });
    }
    this.reorderFields();
  }
};

// src/fileClass/views/tableViewComponents/saveViewModal.ts
var import_obsidian21 = require("obsidian");
var SavedView = class {
  constructor(name) {
    this.name = name;
    this.children = [];
    this.sorters = [];
    this.filters = [];
    this.columns = [];
  }
  buildFilters(filters) {
    Object.entries(filters).forEach(([id, filterComponent]) => {
      this.filters.push({
        id,
        name: filterComponent.name,
        query: filterComponent.filter.inputEl.value,
        customFilter: filterComponent.customFilter
      });
    });
  }
  buildRowSorters(rowSorters) {
    Object.keys(rowSorters).forEach((id) => {
      var _a;
      const sorter = rowSorters[id];
      if (sorter.direction || ((_a = sorter.customOrder) == null ? void 0 : _a.length)) {
        this.sorters.push({
          id,
          name: sorter.name,
          direction: sorter.direction || "asc",
          priority: sorter.priority || 0,
          customOrder: sorter.customOrder || []
        });
      }
    });
  }
  buildColumnManagers(columnManagers) {
    Object.entries(columnManagers).forEach(([id, column]) => {
      this.columns.push({
        id,
        name: column.name,
        hidden: column.hidden,
        position: column.position
      });
    });
  }
};
var CreateSavedViewModal = class extends import_obsidian21.Modal {
  constructor(plugin, view) {
    super(plugin.app);
    this.view = view;
    this.containerEl.onkeydown = (e) => {
      if (e.key == "Enter" && e.altKey) {
        e.preventDefault();
        this.save();
      }
      if (e.key === "Escape" && e.altKey) {
        this.close();
      }
    };
    this.savedView = new SavedView("");
    this.savedView.children = view.fieldSet.children.map((c) => c.name);
    this.savedView.buildFilters(view.fieldSet.filters);
    this.savedView.buildRowSorters(view.fieldSet.rowSorters);
    this.savedView.buildColumnManagers(view.fieldSet.columnManagers);
    this.buildModal();
    this.containerEl.addClass("metadata-menu");
  }
  buildModal() {
    const nameContainer = this.contentEl.createDiv({ cls: "field-container" });
    nameContainer.createDiv({ text: `Saved view name`, cls: "label" });
    const nameInput = new import_obsidian21.TextComponent(nameContainer);
    nameInput.inputEl.addClass("with-label");
    nameInput.inputEl.addClass("full-width");
    const nameErrorContainer = this.contentEl.createDiv({ cls: "field-error", text: `This ${this.savedView.name} view name already exists` });
    cleanActions(this.contentEl, ".footer-actions");
    const actionsContainer = this.contentEl.createDiv({ cls: "footer-actions" });
    actionsContainer.createDiv({ cls: "spacer" });
    const infoContainer = actionsContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    const saveBtn = new import_obsidian21.ButtonComponent(actionsContainer);
    saveBtn.setDisabled(true);
    saveBtn.setIcon("file-plus-2");
    nameErrorContainer.hide();
    nameInput.onChange(async (value) => {
      this.savedView.name = value;
      nameErrorContainer.hide();
      saveBtn.setDisabled(false);
      saveBtn.setCta();
    });
    saveBtn.onClick(async () => {
      await this.save();
    });
    if (this.view.selectedView) {
      nameInput.setValue(this.view.selectedView);
      this.savedView.name = this.view.selectedView;
      saveBtn.setDisabled(false);
      saveBtn.setCta();
    }
  }
  async save() {
    var _a;
    const options2 = this.view.fileClass.getFileClassOptions();
    options2.savedViews = [...((_a = options2.savedViews) == null ? void 0 : _a.filter((v) => v.name !== this.savedView.name)) || [], this.savedView];
    await this.view.fileClass.updateOptions(options2);
    this.view.selectedView = this.savedView.name;
    this.view.favoriteBtn.buttonEl.disabled = false;
    this.view.update();
    this.view.saveViewBtn.removeCta();
    this.close();
  }
};

// src/fileClass/views/tableViewComponents/fileClassDataviewTable.ts
var import_obsidian22 = require("obsidian");
var FileClassDataviewTable = class {
  constructor(viewConfiguration, view, fileClass, maxRow, sliceStart = 0, ctx) {
    this.viewConfiguration = viewConfiguration;
    this.view = view;
    this.fileClass = fileClass;
    this.sliceStart = sliceStart;
    this.ctx = ctx;
    this.ranges = [];
    this.limitWrapped = false;
    this.plugin = this.view.manager.plugin;
    this.limit = maxRow || this.fileClass.options.limit || this.plugin.settings.tableViewMaxRecords;
  }
  buildPaginationManager(container) {
    var _a;
    container.replaceChildren();
    this.ranges = [];
    const toggleRanges = (rangesCount) => {
      for (const [index, rangeComponent] of this.ranges.entries()) {
        if (rangesCount >= 5 && index > 2 && index < rangesCount - 2) {
          if (this.limitWrapped)
            rangeComponent.show();
          else
            rangeComponent.hide();
        }
      }
      this.limitWrapped = !this.limitWrapped;
    };
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    if (dvApi) {
      try {
        const current = this.ctx ? dvApi.page(this.ctx.sourcePath) : {};
        const fFC = this.plugin.fieldIndex.filesFileClasses;
        const fileClassesNames = [this.fileClass.name, ...this.viewConfiguration.children];
        const fileClassFiles = [...fFC.keys()].filter((path) => {
          var _a2;
          return (_a2 = fFC.get(path)) == null ? void 0 : _a2.some((_fileClass) => fileClassesNames.includes(_fileClass.name));
        });
        const fileFileClasses = (path) => {
          var _a2;
          return ((_a2 = this.plugin.fieldIndex.filesFileClasses.get(path)) == null ? void 0 : _a2.map((_fC) => _fC.name)) || [];
        };
        const hasFileClass = (path, id) => {
          const fileClassName = id.split("____")[0];
          return fileFileClasses(path).includes(fileClassName);
        };
        const query = new Function(
          "dv",
          "current",
          "fileClassFiles",
          "hasFileClass",
          `return ${this.buildDvJSQuery()}`
        )(dvApi, current, fileClassFiles, hasFileClass);
        const values = query.values;
        const count = values.length;
        const rangesCount = Math.floor(count / this.limit) + 1;
        if (rangesCount < 2)
          return;
        for (let i = 0; i < rangesCount; i++) {
          if (i * this.limit < count) {
            const rangeComponent = container.createDiv({
              cls: `range ${i === this.sliceStart / this.limit ? "active" : ""}`,
              text: `${i * this.limit + 1} - ${Math.min((i + 1) * this.limit, count)}`
            });
            rangeComponent.onclick = () => {
              this.sliceStart = i * this.limit;
              this.view.update(this.limit, this.sliceStart);
            };
            this.ranges.push(rangeComponent);
          }
          if (rangesCount >= 5 && i === 2) {
            const rangeExpander = container.createDiv({
              cls: `range`,
              text: `< ... >`
            });
            rangeExpander.onclick = () => {
              if (rangeExpander.hasClass("active")) {
                rangeExpander.removeClass("active");
                rangeExpander.setText("< ... >");
              } else {
                rangeExpander.addClass("active");
                rangeExpander.setText("> ... <");
              }
              toggleRanges(rangesCount);
            };
          }
        }
        const activeRange = this.ranges.find((r) => r.hasClass("active"));
        if (activeRange && this.ranges.indexOf(activeRange) < 2)
          toggleRanges(rangesCount);
      } catch (e) {
        console.log(e);
        console.error("unable to build the list of files");
      }
    }
  }
  buildTable(tableContainer) {
    var _a;
    tableContainer.onscroll = (e) => {
      var _a2;
      const table = tableContainer;
      const firstColl = tableContainer.querySelectorAll("tbody > tr > td:first-child");
      const firstFileLink = (_a2 = firstColl[0]) == null ? void 0 : _a2.querySelector("a.internal-link");
      if (firstColl && firstFileLink) {
        if (!this.firstCollWidth)
          this.firstCollWidth = parseFloat(getComputedStyle(firstColl[0]).width);
        if (!this.tableFontSize)
          this.tableFontSize = parseFloat(getComputedStyle(firstFileLink).width);
        const position = e.target.scrollLeft;
        if (window.matchMedia("(max-width: 400px)").matches) {
          if (position !== 0) {
            table.addClass("scrolled");
            table.querySelectorAll("tbody > tr > td:first-child").forEach((item) => {
              item.querySelector("a:first-child").style.maxWidth = `${Math.max(
                3 * this.tableFontSize,
                this.firstCollWidth - this.tableFontSize - position
              )}px`;
            });
          } else {
            tableContainer.removeClass("scrolled");
            table.querySelectorAll("tbody > tr > td:first-child").forEach((item) => {
              item.querySelector("a:first-child").style.maxWidth = "100%";
            });
          }
        }
      }
    };
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    if (dvApi) {
      dvApi.executeJs(this.buildDvJSRendering(), tableContainer, this.view.manager, this.fileClass.getClassFile().path);
    }
    if (this.view instanceof FileClassTableView)
      this.addClickEventToLink(tableContainer);
  }
  buidFileClassViewBtn() {
    const id = this.view.tableId;
    if (document.querySelector(`#${id} thead th .fileclass-icon`))
      return;
    const firstColHeader = document.querySelector(`#${id} thead th`);
    if (firstColHeader) {
      const firstColHeaderContainer = firstColHeader.createDiv({ cls: "first-col-header-container" });
      [...firstColHeader.children].forEach((child) => {
        if (!child.hasClass("first-col-header-container")) {
          firstColHeaderContainer == null ? void 0 : firstColHeaderContainer.append(child);
        }
      });
      const button = firstColHeaderContainer.createDiv({ cls: "fileclass-icon" });
      (0, import_obsidian22.setIcon)(button, this.fileClass.getIcon());
      button.onclick = () => {
        const fileClassViewManager = new FileClassViewManager(this.plugin, this.fileClass, "tableOption", true, this.view.selectedView);
        this.plugin.addChild(fileClassViewManager);
        fileClassViewManager.build();
      };
      firstColHeaderContainer == null ? void 0 : firstColHeaderContainer.prepend(button);
    }
  }
  addClickEventToLink(tableContainer) {
    tableContainer.querySelectorAll("a.internal-link").forEach((link) => {
      link.addEventListener("click", () => {
        var _a;
        return this.plugin.app.workspace.openLinkText(
          //@ts-ignore
          (_a = link.getAttr("data-href")) == null ? void 0 : _a.replace(/(.*).md/, "$1"),
          this.fileClass.getClassFile().path,
          "tab"
        );
      });
    });
  }
  buildFilterQuery() {
    return Object.entries(this.viewConfiguration.filters).map(([index, filter]) => {
      var _a;
      const valueGetter = filter.name === "file" ? `p.file.name` : `p["${filter.name}"]`;
      const current = this.ctx ? `dv.page("${this.ctx.sourcePath}")` : "{}";
      if (filter.customFilter) {
        return `    .filter(p => (new Function("value","current", "dv", "${filter.customFilter}"))(${valueGetter}, ${current}, dv))`;
      }
      if (filter.query) {
        const value = filter.query;
        if (!value.startsWith("/")) {
          let values = value.split(",").map((item) => item.trim());
          const empty = values.find((v) => v === "__empty__");
          const notEmpty = values.find((v) => v === "__notEmpty__");
          const notFound = values.find((v) => v === "__notFound__");
          const existing = values.find((v) => v === "__existing__");
          values = values.filter((v) => !Object.keys(fieldStates).includes(v));
          if (empty) {
            return `    .filter(p => hasFileClass(p.file.path, "${filter.id}") && ${valueGetter} === null)
`;
          } else if (notEmpty) {
            return `    .filter(p => hasFileClass(p.file.path, "${filter.id}") && ${valueGetter} !== null)
`;
          } else if (notFound) {
            return `    .filter(p => hasFileClass(p.file.path, "${filter.id}") && ${valueGetter} === undefined)
`;
          } else if (existing) {
            return `    .filter(p => hasFileClass(p.file.path, "${filter.id}") && ${valueGetter} !== undefined)
`;
          } else if (values.length) {
            const fCField = filter.name !== "file" ? (_a = this.plugin.fieldIndex.fileClassesFields.get(this.fileClass.name)) == null ? void 0 : _a.find((f) => f.name === filter.name) : void 0;
            if ((fCField == null ? void 0 : fCField.type) === "Boolean" /* Boolean */) {
              switch (value) {
                case "true":
                  return `    .filter(p => hasFileClass(p.file.path, "${filter.id}") && ${valueGetter} === true)
`;
                case "false":
                  return `    .filter(p => hasFileClass(p.file.path, "${filter.id}") && ${valueGetter} === false)
`;
                case "false, true":
                case "true, false":
                  return `    .filter(p => hasFileClass(p.file.path, "${filter.id}") && [true, false].some(b => ${valueGetter} === b))
`;
                default:
                  return "";
              }
            } else {
              const valuesQueries = values.map((val) => `${valueGetter}.toString().toLowerCase().includes("${val}".toLowerCase())`);
              return `    .filter(p => hasFileClass(p.file.path, "${filter.id}") && ${valueGetter} && (${valuesQueries.join(" || ")}))
`;
            }
          } else {
            return "";
          }
        } else {
          const cleaned = value.replace(/^\//, "").replace(/\/$/, "");
          let isValid = true;
          try {
            new RegExp(cleaned);
          } catch (error) {
            isValid = false;
          }
          if (isValid)
            return `    .filter(p => ${valueGetter} && new RegExp("${cleaned}").test(${valueGetter}))
`;
          else
            return "";
        }
      } else {
        return "";
      }
    }).join("");
  }
  buildSorterQuery() {
    const buildCOp = (fieldKey, cO, index, dir) => {
      return `rank(basename(p${index}${fieldKey}),[${cO}], ${dir})`;
    };
    const buildOp = (fieldKey, index) => {
      return `basename(p${index}${fieldKey})`;
    };
    const sorters = Object.entries(this.viewConfiguration.sorters).sort((s1, s2) => (s1[1].priority || 0) < (s2[1].priority || 0) ? -1 : 1).filter((s) => s[1].direction).map((s) => {
      var _a;
      const fieldKey = s[1].name === "file" ? `["file"]["name"]` : `["${s[1].name}"]`;
      const dir = s[1].direction === "asc" ? 1 : -1;
      if ((_a = s[1].customOrder) == null ? void 0 : _a.length) {
        const cO = s[1].customOrder.map((item) => `"${item}"`).join(",");
        return `        if(${buildCOp(fieldKey, cO, 1, dir)} > ${buildCOp(fieldKey, cO, 2, dir)}) return ${dir}
        if(${buildCOp(fieldKey, cO, 1, dir)} < ${buildCOp(fieldKey, cO, 2, dir)}) return ${-1 * dir}
`;
      } else {
        return `        if(${buildOp(fieldKey, 1)} > ${buildOp(fieldKey, 2)}) return ${dir}
        if(${buildOp(fieldKey, 1)} < ${buildOp(fieldKey, 2)}) return ${-1 * dir}
`;
      }
    });
    const sortingQuery = `    .array().sort((p1, p2) => {
${sorters.join("")}
    })
`;
    return sortingQuery;
  }
  buildDvJSQuery() {
    var _a;
    let dvQuery = "";
    const classFilesPath = this.plugin.settings.classFilesPath;
    const templatesFolder = (_a = this.plugin.app.plugins.plugins["templater-obsidian"]) == null ? void 0 : _a.settings["templates_folder"];
    dvQuery += `dv.pages()
`;
    dvQuery += `    .filter(p => fileClassFiles.includes(p.file.path)
        ${!!classFilesPath ? "        && !p.file.path.includes('" + classFilesPath + "')\n" : ""}
        ${templatesFolder ? "        && !p.file.path.includes('" + templatesFolder + "')\n" : ""}
        )
`;
    dvQuery += this.buildFilterQuery();
    return dvQuery;
  }
  buildDvJSRendering() {
    const buildColumnName = (column) => {
      if (column.name === "file")
        return this.fileClass.name;
      if (this.viewConfiguration.children.length)
        return column.id.replace("____", ": ");
      else
        return column.name;
    };
    const columns = this.viewConfiguration.columns.filter((f) => {
      var _a;
      return !((_a = this.viewConfiguration.columns.find((_f) => _f.id === f.id)) == null ? void 0 : _a.hidden);
    }).sort((f1, f2) => f1.position < f2.position ? -1 : 1);
    let dvJS = `const {fieldModifier: f} = MetadataMenu.api;
const fFC = MetadataMenu.fieldIndex.filesFileClasses
const fileClassesNames = ["${this.fileClass.name}", ...[${this.viewConfiguration.children.map((c) => "'" + c + "'").join(", ")}]];
const fileClassFiles = [...fFC.keys()].filter(path => fFC.get(path)?.some(_fileClass => fileClassesNames.includes(_fileClass.name)))
const basename = (item) => {
    if(item && item.hasOwnProperty('path')){
        return /([^/]*).md/.exec(item.path)?.[1] || item.path
    }else if(typeof item === 'string'){
        return item
    }else{
        return item?.toString() || '' 
    }
}
const fileFileClasses = (path) => {
    return MetadataMenu.fieldIndex.filesFileClasses.get(path)?.map(_fC => _fC.name) || [] 
}
const hasFileClass = (path, id) => {
    if(id.includes('____')){
        const fileClassName = id.split('____')[0]
        return fileFileClasses(path).includes(fileClassName)
    } else {
        return true    }
}
const rank = (item, options, dir) => {
    const indexInOptions = options.indexOf(basename(item));
    if(dir === 1){
        if(indexInOptions === -1) return Infinity
    }
    return indexInOptions
}
dv.table([
`;
    dvJS += columns.map((column) => `"${buildColumnName(column)}"`).join(",");
    dvJS += `], 
`;
    dvJS += this.buildDvJSQuery();
    dvJS += this.buildSorterQuery();
    dvJS += `    .slice(${this.sliceStart}, ${this.sliceStart + this.limit})
`;
    dvJS += "    .map(p => [\n";
    dvJS += columns.map((column) => {
      if (column.name === "file") {
        return '        dv.el("div", p.file.link, {cls: "field-name"})';
      } else {
        return `        hasFileClass(p.file.path, "${column.id}") ? f(dv, p, "${column.name}", {options: {alwaysOn: false, showAddField: ${this.view.manager.showAddField}}}) : ""`;
      }
    }).join(",\n");
    dvJS += "    \n])";
    dvJS += "\n);";
    return dvJS;
  }
};

// src/fileClass/views/tableViewComponents/ChildrenMultiSelectModal.ts
var import_obsidian23 = require("obsidian");
var ChildrenMultiSelectModal = class extends import_obsidian23.SuggestModal {
  constructor(plugin, fileClass, parentFieldSet) {
    super(plugin.app);
    this.plugin = plugin;
    this.fileClass = fileClass;
    this.parentFieldSet = parentFieldSet;
    this.containerEl.addClass("metadata-menu");
    const inputContainer = this.containerEl.createDiv({ cls: "suggester-input" });
    inputContainer.appendChild(this.inputEl);
    this.containerEl.find(".prompt").prepend(inputContainer);
    cleanActions(this.containerEl, ".footer-actions");
    const footerActionsContainer = this.containerEl.createDiv({ cls: "footer-actions" });
    this.buildFooterActions(footerActionsContainer);
    const initialOptions = this.parentFieldSet.children;
    if (initialOptions)
      this.selectedChildren = [...initialOptions];
    this.containerEl.onkeydown = (e) => {
      if (e.key == "Enter" && e.altKey) {
        this.parentFieldSet.reset(this.selectedChildren);
        this.close();
      }
    };
  }
  isSelected(value) {
    return this.selectedChildren.map((c) => c.fileClass.name).includes(value.fileClass.name);
  }
  getSuggestions(query) {
    const children = this.fileClass.getChildren().filter((c) => !query || c.name.toLocaleLowerCase() === query.toLocaleLowerCase());
    const sortedChildren = children.sort((c1, c2) => c1.path.join(" > ") < c2.path.join(" > ") ? -1 : 1);
    return sortedChildren;
  }
  buildFooterActions(footerActionsContainer) {
    footerActionsContainer.createDiv({ cls: "spacer" });
    this.buildConfirm(footerActionsContainer);
    const cancelButton = new import_obsidian23.ButtonComponent(footerActionsContainer);
    cancelButton.setIcon("cross");
    cancelButton.onClick(() => this.close());
    cancelButton.setTooltip("Cancel");
    const clearButton = new import_obsidian23.ButtonComponent(footerActionsContainer);
    clearButton.setIcon("filter-x");
    clearButton.setTooltip("Clear filtered value(s)");
    clearButton.onClick(async () => {
      const fieldSet = this.parentFieldSet;
      const view = fieldSet.tableView;
      fieldSet.children = [];
      view.build();
      view.update();
      view.saveViewBtn.setCta();
      this.close();
    });
    clearButton.buttonEl.addClass("danger");
    this.modalEl.appendChild(footerActionsContainer);
  }
  buildConfirm(footerActionsContainer) {
    const infoContainer = footerActionsContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    const confirmButton = new import_obsidian23.ButtonComponent(footerActionsContainer);
    confirmButton.setIcon("checkmark");
    confirmButton.onClick(async () => {
      this.parentFieldSet.reset(this.selectedChildren);
      this.close();
    });
  }
  renderSelected() {
    const chooser = this.chooser;
    const suggestions = chooser.suggestions;
    const values = chooser.values;
    suggestions.forEach((s, i) => {
      if (this.isSelected(values[i])) {
        s.addClass("value-checked");
        if (s.querySelectorAll(".icon-container").length == 0) {
          const iconContainer = s.createDiv({ cls: "icon-container" });
          (0, import_obsidian23.setIcon)(iconContainer, "check-circle");
        }
      } else {
        s.removeClass("value-checked");
        s.querySelectorAll(".icon-container").forEach((icon) => icon.remove());
      }
    });
  }
  renderSuggestion(value, el) {
    const labelContainer = el.createDiv({ cls: "label-with-icon-container" });
    const icon = labelContainer.createDiv({ cls: "icon" });
    (0, import_obsidian23.setIcon)(icon, value.fileClass.getIcon());
    const label = labelContainer.createDiv({ cls: "label" });
    label.setText(`${value.path.join(" > ")}`);
    el.addClass("value-container");
    const spacer = this.containerEl.createDiv({ cls: "spacer" });
    el.appendChild(spacer);
    if (this.isSelected(value)) {
      el.addClass("value-checked");
      const iconContainer = el.createDiv({ cls: "icon-container" });
      (0, import_obsidian23.setIcon)(iconContainer, "check-circle");
    }
    this.inputEl.focus();
  }
  selectSuggestion(value, evt) {
    if (this.isSelected(value)) {
      const child = this.selectedChildren.find((c) => c.fileClass.name === value.fileClass.name);
      if (child)
        this.selectedChildren.remove(child);
    } else {
      this.selectedChildren.push(value);
    }
    this.renderSelected();
  }
  onChooseSuggestion(item, evt) {
  }
};

// src/fileClass/views/fileClassTableView.ts
var FileClassTableView = class {
  constructor(manager, viewContainer, tableId, fileClass, selectedView) {
    this.manager = manager;
    this.viewContainer = viewContainer;
    this.tableId = tableId;
    this.fileClass = fileClass;
    this.selectedView = selectedView;
    this.limitWrapped = false;
    this.ranges = [];
    this.plugin = manager.plugin;
    this.container = this.viewContainer.createDiv({ cls: "fv-table" });
    this.build();
  }
  build() {
    this.limit = this.fileClass.getFileClassOptions().limit;
    this.container.replaceChildren();
    this.createHeader();
    this.changeView(this.selectedView, false);
  }
  createHeader() {
    const header = this.container.createDiv({ cls: "options" });
    const limitContainer = header.createDiv({ cls: "limit" });
    this.paginationContainer = header.createDiv({ cls: "pagination" });
    this.fieldsContainer = header.createDiv({ cls: "fields" });
    const applyContainer = header.createDiv({ cls: "footer" });
    this.viewSelectContainer = applyContainer.createDiv({ cls: "cell" });
    this.buildLimitManager(limitContainer);
    this.buildFields(this.fieldsContainer);
    this.buildViewSelector();
    this.buildFavoriteViewManager(applyContainer);
    this.buildCleanFields(applyContainer);
    this.buildSaveView(applyContainer);
    this.buildSavedViewRemoveButton(applyContainer);
    if (this.fileClass.getChildren().length)
      this.buildChildrenSelector(applyContainer);
    this.buildHideInsertFieldBtn(applyContainer);
    this.buildRefreshBtn(applyContainer);
    this.buildHideFilters(applyContainer);
  }
  update(maxRows, sliceStart = 0) {
    this.manager._children.forEach((child) => this.manager.removeChild(child));
    this.fileClassDataviewTable = new FileClassDataviewTable(
      this.fieldSet.getParams(),
      this,
      this.fileClass,
      maxRows,
      sliceStart
    );
    this.buildTable();
    this.buildPaginationManager(this.paginationContainer);
    this.buildViewSelector();
  }
  /*
  ** Max rows
  */
  buildLimitManager(container) {
    container.replaceChildren();
    container.createDiv({ text: "Results per page: ", cls: "label" });
    const limitInput = new import_obsidian24.TextComponent(container);
    limitInput.setValue(`${this.limit}`);
    const debounced = (0, import_obsidian24.debounce)((fieldset) => fieldset.tableView.update(this.limit), 1e3, true);
    limitInput.onChange((value) => {
      this.limit = parseInt(value) || this.limit;
      this.saveViewBtn.setCta();
      debounced(this.fieldSet);
    });
  }
  /*
  ** Pagination
  */
  buildPaginationManager(container) {
    this.fileClassDataviewTable.buildPaginationManager(container);
  }
  /*
  ** Fields
  */
  buildFields(container) {
    container.replaceChildren();
    this.fieldSet = new FieldSet4(this, container);
  }
  /*
  ** Actions
  */
  /* view selection */
  changeView(name, updateNeeded = true) {
    this.fieldSet.changeView(name, updateNeeded);
    this.selectedView = name;
    this.toggleFavoriteBtnState();
    this.viewSelect.setValue(name || "");
    this.viewRemoveBtn.setDisabled(!this.selectedView);
    this.viewRemoveBtn.setTooltip(`Remove ${this.selectedView} view from the saved views`);
    this.update();
    this.saveViewBtn.removeCta();
  }
  buildViewSelector() {
    this.viewSelectContainer.replaceChildren();
    const options2 = this.fileClass.getFileClassOptions();
    const savedViews = options2.savedViews || [];
    this.viewSelect = new import_obsidian24.DropdownComponent(this.viewSelectContainer);
    if (!savedViews.length) {
      this.viewSelect.addOption("", "No saved view");
      this.viewSelect.setDisabled(true);
    } else {
      this.viewSelect.addOption("", "--None--");
      savedViews.sort((a, b) => a.name < b.name ? -1 : 1).forEach((view) => this.viewSelect.addOption(view.name, view.name));
      this.viewSelect.onChange((value) => this.changeView(value, false));
      this.viewSelect.setValue(this.selectedView || "");
    }
  }
  buildSavedViewRemoveButton(container) {
    const btnContainer = container.createDiv({ cls: "cell" });
    this.viewRemoveBtn = new import_obsidian24.ButtonComponent(btnContainer).setIcon("trash").setClass("remove-button").setDisabled(!this.selectedView).setTooltip(`Remove ${this.selectedView} view from the saved views`).onClick(async () => {
      var _a;
      const options2 = this.fileClass.getFileClassOptions();
      if (options2.favoriteView === this.selectedView)
        options2.favoriteView = null;
      options2.savedViews = (_a = options2.savedViews) == null ? void 0 : _a.filter((view) => view.name !== this.selectedView);
      await this.fileClass.updateOptions(options2);
      this.changeView();
      this.viewRemoveBtn.setDisabled(true);
      this.update();
    });
  }
  toggleFavoriteBtnState() {
    var _a;
    const options2 = this.fileClass.getFileClassOptions();
    const favoriteView = options2.favoriteView || null;
    if ((_a = options2.savedViews) == null ? void 0 : _a.length) {
      this.favoriteBtn.setDisabled(false);
      if (this.selectedView === favoriteView && !!favoriteView) {
        this.favoriteBtn.setTooltip("Unselect this view as your favorite view");
        this.favoriteBtn.buttonEl.addClass("favorite");
      } else if (this.selectedView !== void 0) {
        this.favoriteBtn.setTooltip("Select this view as your favorite view");
        this.favoriteBtn.buttonEl.removeClass("favorite");
      } else {
        this.favoriteBtn.setDisabled(true);
        this.favoriteBtn.buttonEl.removeClass("favorite");
      }
    } else {
      this.favoriteBtn.setDisabled(true);
      this.favoriteBtn.setTooltip("You don't have any saved view yet");
    }
  }
  buildFavoriteViewManager(container) {
    const btnContainer = container.createDiv({ cls: "cell" });
    this.favoriteBtn = new import_obsidian24.ButtonComponent(btnContainer);
    this.favoriteBtn.setClass("favorite-button");
    this.favoriteBtn.setIcon("star");
    this.toggleFavoriteBtnState();
    this.favoriteBtn.onClick(async () => {
      const options2 = this.fileClass.getFileClassOptions();
      const favoriteView = options2.favoriteView || null;
      if (this.selectedView === favoriteView) {
        options2.favoriteView = null;
        this.favoriteBtn.buttonEl.removeClass("favorite");
      } else if (this.selectedView !== void 0) {
        options2.favoriteView = this.selectedView;
        this.favoriteBtn.buttonEl.addClass("favorite");
      }
      await this.fileClass.updateOptions(options2);
      this.saveViewBtn.setCta();
      this.toggleFavoriteBtnState();
    });
  }
  buildCleanFields(container) {
    const btnContainer = container.createDiv({ cls: "cell" });
    const cleanFilterBtn = new import_obsidian24.ButtonComponent(btnContainer);
    cleanFilterBtn.setIcon("eraser");
    cleanFilterBtn.setTooltip("Clear all filters, sorters and ordering");
    cleanFilterBtn.onClick(() => this.fieldSet.reset());
  }
  buildSaveView(container) {
    const btnContainer = container.createDiv({ cls: "cell" });
    this.saveViewBtn = new import_obsidian24.ButtonComponent(btnContainer).setIcon("save").setTooltip("Save current view (filters and sorters)").onClick(() => new CreateSavedViewModal(this.plugin, this).open());
  }
  buildHideFilters(container) {
    const btnContainer = container.createDiv({ cls: "cell" });
    const hideFilterBtn = new import_obsidian24.ButtonComponent(btnContainer);
    this.fieldsContainer.style.display = "none";
    hideFilterBtn.setIcon("list-end");
    hideFilterBtn.setTooltip("display filters");
    const toggleState = () => {
      if (this.fieldsContainer.getCssPropertyValue("display") !== "none") {
        this.fieldsContainer.style.display = "none";
        hideFilterBtn.setIcon("list-end");
        hideFilterBtn.setTooltip("display filters");
      } else {
        this.fieldsContainer.style.display = "flex";
        hideFilterBtn.setIcon("list-start");
        hideFilterBtn.setTooltip("collapse filters");
      }
    };
    hideFilterBtn.onClick(() => toggleState());
  }
  buildHideInsertFieldBtn(container) {
    const btnContainer = container.createDiv({ cls: "cell" });
    const hideInsertBtn = new import_obsidian24.ButtonComponent(btnContainer);
    hideInsertBtn.setIcon("plus-circle");
    hideInsertBtn.setTooltip("Show insert field button in each cell (slower)");
    const toggleState = () => {
      if (this.manager.showAddField) {
        hideInsertBtn.removeCta();
        this.manager.showAddField = false;
      } else {
        hideInsertBtn.setCta();
        this.manager.showAddField = true;
      }
    };
    hideInsertBtn.onClick(() => {
      toggleState();
      this.update();
    });
  }
  triggerRefreshNeeded() {
    this.refreshBtn.buttonEl.show();
    this.refreshBtn.setCta();
  }
  buildRefreshBtn(container) {
    const btnContainer = container.createDiv({ cls: "cell" });
    this.refreshBtn = new import_obsidian24.ButtonComponent(btnContainer);
    this.refreshBtn.setIcon("refresh-cw");
    this.refreshBtn.setTooltip("Refresh table results");
    this.refreshBtn.buttonEl.hide();
    this.refreshBtn.onClick(() => {
      this.refreshBtn.removeCta();
      this.update();
      this.refreshBtn.buttonEl.hide();
    });
  }
  /*
  ** Children selector
  */
  buildChildrenSelector(container) {
    const btnContainer = container.createDiv({ cls: "cell" });
    const childrenBtn = new import_obsidian24.ButtonComponent(btnContainer);
    childrenBtn.setIcon("network");
    childrenBtn.setTooltip("display children selector");
    childrenBtn.onClick(() => {
      new ChildrenMultiSelectModal(this.plugin, this.fileClass, this.fieldSet).open();
    });
  }
  /*
  ** Table
  */
  buildTable() {
    if (this.tableContainer) {
      this.tableContainer.remove();
    }
    ;
    this.tableContainer = this.container.createDiv({ attr: { id: this.tableId } });
    this.fileClassDataviewTable.buildTable(this.tableContainer);
  }
};

// src/fileClass/views/fileClassView.ts
var FILECLASS_VIEW_TYPE = "FileClassView";
var MenuOption = class {
  constructor(menu, id, name, relatedView, view) {
    this.menu = menu;
    this.id = id;
    this.name = name;
    this.relatedView = relatedView;
    this.view = view;
    this.itemContainer = this.menu.createDiv({ cls: "fv-menu-item", attr: { id: this.id } });
    this.itemContainer.createEl("h2", { text: this.name });
    this.itemContainer.onclick = () => {
      this.view.updateDisplayView(this.id);
    };
  }
  toggleInactive() {
    this.itemContainer.removeClass("active");
    this.relatedView.hide();
  }
  toggleActive() {
    this.itemContainer.addClass("active");
    this.relatedView.show();
  }
};
var FileClassView = class extends import_obsidian25.ItemView {
  constructor(leaf, plugin, tableId, component, name, fileClass, onOpenTabDisplay = "tableOption", selectedView) {
    super(leaf);
    this.leaf = leaf;
    this.plugin = plugin;
    this.tableId = tableId;
    this.component = component;
    this.name = name;
    this.fileClass = fileClass;
    this.onOpenTabDisplay = onOpenTabDisplay;
    this.selectedView = selectedView;
    this.menuOptions = [];
    this.views = [];
    this.containerEl.addClass("metadata-menu");
    this.containerEl.addClass("fileclass-view");
    this.contentEl.addClass("fileclass-view-content");
    this.navigation = false;
    this.icon = "file-spreadsheet";
    this.onunload = () => {
      this.plugin.app.viewRegistry.unregisterView(FILECLASS_VIEW_TYPE + "__" + this.fileClass.name);
      this.plugin.removeChild(this.component);
      this.unload();
    };
    this.buildLayout();
  }
  updateDisplayView(id) {
    [...this.viewContainer.children].forEach((view) => view.hide());
    this.menuOptions.forEach((option) => option.id === id ? option.toggleActive() : option.toggleInactive());
  }
  buildLayout() {
    this.menu = this.contentEl.createDiv({ cls: "fv-menu" });
    this.viewContainer = this.contentEl.createDiv({ cls: "view-container" });
    this.buildSettingsView();
    this.buildFieldsView();
    this.buildTableView();
    this.buildMenu();
    this.updateDisplayView(this.onOpenTabDisplay);
  }
  buildMenu() {
    this.menuOptions.push(new MenuOption(this.menu, "tableOption", "Table view", this.tableView.container, this));
    this.menuOptions.push(new MenuOption(this.menu, "fieldsOption", "Fileclass fields", this.fieldsView.container, this));
    this.menuOptions.push(new MenuOption(this.menu, "settingsOption", "Fileclass settings", this.settingsView.container, this));
  }
  buildSettingsView() {
    this.settingsView = new FileClassSettingsView(this.plugin, this.viewContainer, this.fileClass);
    this.views.push(this.settingsView.container);
  }
  buildFieldsView() {
    this.fieldsView = new FileClassFieldsView(this.plugin, this.viewContainer, this.fileClass);
    this.views.push(this.fieldsView.container);
  }
  buildTableView() {
    const favoriteView = this.fileClass.options.favoriteView || void 0;
    this.tableView = new FileClassTableView(this.component, this.viewContainer, this.tableId, this.fileClass, this.selectedView || favoriteView);
    this.views.push(this.tableView.container);
  }
  getDisplayText() {
    return this.name || "FileClass";
  }
  getViewType() {
    return this.fileClass ? FILECLASS_VIEW_TYPE + "__" + this.fileClass.name : FILECLASS_VIEW_TYPE;
  }
  updateFieldsView() {
    this.fileClass.getAttributes();
    this.fieldsView.buildSettings();
  }
  updateSettingsView() {
    this.settingsView.buildSettings();
  }
  async onOpen() {
    var _a;
    this.icon = (_a = this.fileClass) == null ? void 0 : _a.getIcon();
  }
};

// src/fileClass/fileClassChoiceModal.ts
var import_obsidian26 = require("obsidian");
var FileClassChoiceModal = class extends import_obsidian26.SuggestModal {
  constructor(plugin, fileClassManager, tagsAndFileClasses) {
    super(plugin.app);
    this.plugin = plugin;
    this.fileClassManager = fileClassManager;
    this.tagsAndFileClasses = tagsAndFileClasses;
    this.containerEl.addClass("metadata-menu");
  }
  getSuggestions(query) {
    const index = this.plugin.fieldIndex;
    const values = [.../* @__PURE__ */ new Set(
      [...index.fileClassesName.keys(), ...index.tagsMatchingFileClasses.keys()]
    )].filter((name) => name.toLowerCase().includes(query.toLowerCase())).sort((a, b) => a.localeCompare(b));
    if (this.tagsAndFileClasses.length) {
      return values.filter((value) => this.tagsAndFileClasses.includes(value));
    } else {
      return values;
    }
  }
  renderSuggestion(value, el) {
    el.setText(value);
    el.addClass("value-container");
  }
  async onChooseSuggestion(item, evt) {
    var _a;
    const index = this.plugin.fieldIndex;
    const fileClass = index.fileClassesName.get(item) || index.tagsMatchingFileClasses.get(item);
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    if (fileClass && dvApi) {
      this.fileClassManager.name = item;
      this.fileClassManager.fileClass = fileClass;
      const viewType = FILECLASS_VIEW_TYPE + "__" + fileClass.name;
      this.fileClassManager.fileClassViewType = viewType;
      await this.fileClassManager.openFileClassView();
      this.plugin.indexDB.fileClassViews.editElement(
        viewType,
        {
          id: viewType,
          leafId: this.fileClassManager.fileClassView.leaf.id
        }
      );
    }
    this.close();
  }
};

// src/components/FileClassViewManager.ts
var FileClassViewManager = class extends import_obsidian27.Component {
  constructor(plugin, fileClass, onOpenTabDisplay = "tableOption", revealAfterOpen = true, selectedView) {
    super();
    this.plugin = plugin;
    this.fileClass = fileClass;
    this.onOpenTabDisplay = onOpenTabDisplay;
    this.revealAfterOpen = revealAfterOpen;
    this.selectedView = selectedView;
    this.showAddField = false;
    if (!this.fileClass) {
      this.fileClassViewType = FILECLASS_VIEW_TYPE;
    } else {
      this.fileClassViewType = FILECLASS_VIEW_TYPE + "__" + this.fileClass.name;
    }
  }
  async openRegisterAndIndexView(fileClass) {
    var _a;
    this.fileClass = fileClass;
    this.name = this.fileClass.name;
    this.fileClassViewType = FILECLASS_VIEW_TYPE + "__" + this.fileClass.name;
    await this.openFileClassView();
    this.registerEvent(this.plugin.app.workspace.on("metadata-menu:fileclass-indexed", () => {
      var _a2;
      const view = (_a2 = this.plugin.app.workspace.getLeavesOfType(this.fileClassViewType)[0]) == null ? void 0 : _a2.view;
      if (view) {
        view.updateFieldsView();
        view.updateSettingsView();
        view.tableView.triggerRefreshNeeded();
      }
    }));
    this.plugin.indexDB.fileClassViews.editElement(this.fileClassViewType, {
      id: this.fileClassViewType,
      leafId: (_a = this.fileClassView) == null ? void 0 : _a.leaf.id
    });
  }
  async build() {
    if (this.fileClass)
      this.openRegisterAndIndexView(this.fileClass);
    else {
      const tagsAndFileClasses = this.getActiveFileTagsAndFileClasses();
      if (tagsAndFileClasses.length === 1) {
        const index = this.plugin.fieldIndex;
        const fileClassName = tagsAndFileClasses[0];
        const fileClass = index.fileClassesName.get(fileClassName) || index.tagsMatchingFileClasses.get(fileClassName);
        if (fileClass)
          this.openRegisterAndIndexView(fileClass);
        else {
          this.plugin.removeChild(this);
          this.unload();
        }
      } else {
        const choiceModal = new FileClassChoiceModal(this.plugin, this, tagsAndFileClasses);
        choiceModal.onClose = () => {
          if (!this.fileClass) {
            this.plugin.removeChild(this);
            this.unload();
          }
        };
        choiceModal.open();
      }
    }
  }
  async openFileClassView() {
    if (this.fileClass) {
      const fileClass = this.fileClass;
      this.plugin.app.workspace.detachLeavesOfType(this.fileClassViewType);
      this.plugin.registerView(
        this.fileClassViewType,
        (leaf) => {
          this.tableId = `table-container-${Math.floor(Date.now())}`;
          const fileClassView = new FileClassView(leaf, this.plugin, this.tableId, this, this.name, fileClass, this.onOpenTabDisplay, this.selectedView);
          this.fileClassView = fileClassView;
          return fileClassView;
        }
      );
      try {
        await this.plugin.app.workspace.getLeaf("tab", "vertical").setViewState({
          type: this.fileClassViewType,
          active: true
        });
        if (this.revealAfterOpen) {
          this.plugin.app.workspace.revealLeaf(
            this.plugin.app.workspace.getLeavesOfType(this.fileClassViewType).last()
          );
        }
      } catch (e) {
        console.log(e);
        this.unload();
        console.warn("Fileclass view couldn't load because of a conflict with another plugin");
      }
    }
  }
  getActiveFileTagsAndFileClasses() {
    var _a, _b, _c;
    const index = this.plugin.fieldIndex;
    const activeFilePath = (_a = this.plugin.app.workspace.getActiveFile()) == null ? void 0 : _a.path;
    const tagsAndFileClasses = [];
    const dvApi = (_b = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _b.api;
    if (activeFilePath && activeFilePath.endsWith(".md") && dvApi) {
      tagsAndFileClasses.push(...((_c = dvApi.page(activeFilePath).etags) == null ? void 0 : _c.filter((tag) => [...index.tagsMatchingFileClasses.keys()].includes(tag))) || []);
      tagsAndFileClasses.push(...index.filesFileClassesNames.get(activeFilePath) || []);
    }
    return [...new Set(tagsAndFileClasses)];
  }
  onunload() {
    this.plugin.app.workspace.detachLeavesOfType(this.fileClassViewType);
    this.plugin.app.viewRegistry.unregisterView(this.fileClassViewType);
    this.plugin.indexDB.fileClassViews.removeElement(FILECLASS_VIEW_TYPE + "__" + this.name);
    for (const child of this._children) {
      child.unload();
      this.removeChild(child);
    }
  }
  static async reloadViews(plugin) {
    var _a;
    const registeredFileClassViews = Object.keys(plugin.app.viewRegistry.viewByType).filter((key) => key.startsWith("FileClassView__"));
    for (const view of await plugin.indexDB.fileClassViews.getElement("all") || []) {
      const fileClassName = (_a = /FileClassView__(.*)/.exec(view.id)) == null ? void 0 : _a[1];
      if (fileClassName && !registeredFileClassViews.some((viewName) => viewName.includes(fileClassName))) {
        const leaf = plugin.app.workspace.getLeafById(view.leafId);
        const fileClass = plugin.fieldIndex.fileClassesName.get(fileClassName);
        if (fileClass) {
          if (leaf && !(leaf.view.component instanceof FileClassViewManager))
            plugin.app.workspace.detachLeavesOfType(view.id);
          const fileClassManager = new FileClassViewManager(plugin, fileClass, "tableOption", false);
          plugin.addChild(fileClassManager);
          await fileClassManager.build();
        }
      }
    }
  }
};

// src/options/FileClassOptionsList.ts
function isMenu(location) {
  return location.addItem !== void 0;
}
function isInsertFieldCommand(location) {
  return location === "InsertFieldCommand";
}
function isSuggest(location) {
  return location.getItems !== void 0;
}
var FileClassOptionsList = class {
  constructor(plugin, file, location, fromFile) {
    this.plugin = plugin;
    this.file = file;
    this.location = location;
    this.fromFile = fromFile;
    this.fileClass = this.plugin.fieldIndex.fileClassesPath.get(this.file.path);
  }
  createExtraOptionList(openAfterCreate = true) {
    var _a, _b;
    const mapWithTagAction = async () => {
      this.plugin.app.fileManager.processFrontMatter(this.file, (fm) => fm.mapWithTag = true);
    };
    const openFileClassTableViewAction = () => {
      const fileClassComponent = new FileClassViewManager(this.plugin, fileClass);
      this.plugin.addChild(fileClassComponent);
    };
    if (isMenu(this.location)) {
      this.location.addSeparator();
    }
    ;
    const fileClass = this.fileClass;
    const currentFieldsNames = [];
    let addMissingFieldsAction = () => {
      new import_obsidian28.Notice("Something went wrong, please check your fileClass definitions");
    };
    if (this.fromFile) {
      const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
      if (dvApi) {
        const dvFile = dvApi.page(this.fromFile.path);
        if (dvFile) {
          currentFieldsNames.push(...genuineKeys(dvFile));
          const modal = new chooseSectionModal(
            this.plugin,
            this.fromFile,
            (lineNumber, asList, asBlockquote) => insertMissingFields(
              this.plugin,
              dvFile.file.path,
              lineNumber,
              asList,
              asBlockquote,
              fileClass == null ? void 0 : fileClass.name
            )
          );
          addMissingFieldsAction = () => {
            modal.open();
          };
        }
      }
      ;
    }
    const missingFields = fileClass && this.fromFile ? !((_b = this.plugin.fieldIndex.fileClassesFields.get(fileClass.name)) == null ? void 0 : _b.map((f) => f.name).every((fieldName) => currentFieldsNames.includes(fieldName))) : false;
    if (isInsertFieldCommand(this.location) && fileClass) {
      const modal = new FileClassAttributeModal(this.plugin, fileClass);
      modal.open();
    } else if (isSuggest(this.location)) {
      if (fileClass) {
        this.location.options.push({
          id: `display_table_view_for_${fileClass.name.replace("/", "_")}`,
          actionLabel: `Display ${fileClass.name} table view`,
          action: openFileClassTableViewAction,
          icon: "file-spreadsheet"
        });
      }
      if (fileClass && !fileClass.isMappedWithTag()) {
        this.location.options.push({
          id: "map_fileClass_with_tag",
          actionLabel: `<span>Map <b>${fileClass.name}</b> with tag of same name</span>`,
          action: mapWithTagAction,
          icon: "hash"
        });
      }
      if (fileClass && missingFields && this.fromFile) {
        this.location.options.push({
          id: `insert_missig_fields_from_${fileClass.name.replace("/", "_")}`,
          actionLabel: `<span>Insert missing fields from <b>${fileClass.name}</b></span>`,
          action: addMissingFieldsAction,
          icon: "battery-full"
        });
      }
      this.buildFieldOptions();
      if (openAfterCreate)
        this.location.open();
    } else if (isMenu(this.location)) {
      if (fileClass) {
        this.location.addItem((item) => {
          item.setTitle(`Display ${fileClass.name} table view`);
          item.onClick(openFileClassTableViewAction);
          item.setIcon("file-spreadsheet");
          item.setSection(`metadata-menu-fileclass.${fileClass.name}.fileclass-fields`);
        });
      }
      if (fileClass && !fileClass.isMappedWithTag()) {
        this.location.addItem((item) => {
          item.setTitle(`Map ${fileClass.name} with tag`);
          item.setIcon("hash");
          item.onClick(mapWithTagAction);
          item.setSection(`metadata-menu-fileclass.${fileClass.name}.fileclass-fields`);
        });
      }
      if (fileClass && missingFields && this.fromFile) {
        this.location.addItem((item) => {
          item.setTitle(`Insert missing fields from ${fileClass.name}`);
          item.setIcon("battery-full");
          item.onClick(addMissingFieldsAction);
          item.setSection(`metadata-menu-fileclass.${fileClass.name}.fileclass-fields`);
        });
      }
      this.buildFieldOptions();
    } else {
      this.buildFieldOptions;
    }
  }
  buildFieldOptions() {
    var _a;
    (_a = this.fileClass) == null ? void 0 : _a.attributes.forEach((attr) => {
      const modal2 = new FileClassAttributeModal(this.plugin, this.fileClass, attr);
      if (isMenu(this.location)) {
        this.location.addItem((item) => {
          item.setTitle(`${this.fileClass.name} - ${attr.name}`);
          item.setIcon("wrench");
          item.onClick(() => {
            modal2.open();
          });
          item.setSection(`metadata-menu-fileclass.${this.fileClass.name}.fileclass-fields`);
        });
      } else if (isSuggest(this.location)) {
        this.location.options.push({
          id: `update_${attr.name}`,
          actionLabel: `<span>${attr.name}</span>`,
          action: () => modal2.open(),
          icon: "gear"
        });
      }
    });
    const modal = new FileClassAttributeModal(this.plugin, this.fileClass);
    const action = () => modal.open();
    if (isMenu(this.location) && this.fileClass) {
      this.location.addItem((item) => {
        item.setTitle("Add new field");
        item.setIcon("plus-circle");
        item.onClick(action);
        item.setSection(`metadata-menu-fileclass.${this.fileClass.name}.fileclass-fields`);
      });
    } else if (isSuggest(this.location) && this.fileClass) {
      this.location.options.push({
        id: "add_fileClass_attribute",
        actionLabel: `<span>Insert an attribute for <b>${this.fileClass.name}</b> fileClass</span>`,
        action,
        icon: "plus-circle"
      });
    }
  }
};

// src/options/OptionsList.ts
function isMenu2(location) {
  return location.addItem !== void 0;
}
function isInsertFieldCommand2(location) {
  return location === "InsertFieldCommand";
}
function isSuggest2(location) {
  return location.getItems !== void 0;
}
var OptionsList = class {
  constructor(plugin, file, location, path = "") {
    this.plugin = plugin;
    this.file = file;
    this.location = location;
    this.path = path;
    this.file = file;
    this.location = location;
  }
  async build() {
    if (this.plugin.fieldIndex.isIndexed(this.file)) {
      this.note = await Note.buildNote(this.plugin, this.file);
    }
  }
  createAndOpenFieldModal(node) {
    var _a, _b;
    const { field, value } = node;
    const rootNode = (_b = (_a = node == null ? void 0 : node.line) == null ? void 0 : _a.getParentLineWithField()) == null ? void 0 : _b.nodes[0];
    const indexedPath = !field ? (rootNode == null ? void 0 : rootNode.indexedPath) || node.indexedPath : node.indexedPath;
    const rootField = rootNode == null ? void 0 : rootNode.field;
    const managedField = field || rootField;
    if (managedField) {
      const fieldManager = new FieldManager[managedField.type](this.plugin, managedField);
      switch (fieldManager.type) {
        case "Boolean" /* Boolean */:
          fieldManager.toggle(this.file, indexedPath);
          break;
        case "Cycle" /* Cycle */:
          fieldManager.next(managedField.name, this.file, indexedPath);
          break;
        default:
          const eF = node.line.note.getExistingFieldForIndexedPath(indexedPath);
          fieldManager.createAndOpenFieldModal(this.file, managedField.name, eF, indexedPath, void 0, void 0, void 0, void 0);
          break;
      }
    } else {
      new import_obsidian29.Notice("No field with definition at this position", 2e3);
    }
  }
  createContextMenuOptionsList() {
    const location = this.location;
    if (isMenu2(location)) {
      location.addSeparator();
      if (this.plugin.fieldIndex.isIndexed(this.file)) {
        this.openNoteFieldModalOption();
        this.buildFieldOptionsForMenu();
        this.addSectionSelectModalOption();
        this.addFieldAtCurrentPositionOption();
        this.addFieldAtTheEndOfFrontmatterOption();
        this.addAllMissingFieldsAtSection();
      }
      const fileClasses = this.plugin.fieldIndex.filesFileClasses.get(this.file.path) || [];
      fileClasses.forEach((fileClass) => {
        const fileClassOptionsList = new FileClassOptionsList(this.plugin, fileClass.getClassFile(), location, this.file);
        fileClassOptionsList.createExtraOptionList(false);
      });
      this.addFileClassToFileOption();
      this.addNewFileClassOption();
    }
  }
  async createExtraOptionList(openAfterCreate = true) {
    var _a;
    await this.build();
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    const location = this.location;
    const separator2 = {
      id: `__optionSeparator`,
      actionLabel: ``,
      action: () => {
      },
      icon: void 0
    };
    if (isInsertFieldCommand2(location)) {
      this.addFieldAtCurrentPositionOption();
    } else if (isSuggest2(location)) {
      if (this.plugin.fieldIndex.isIndexed(this.file)) {
        this.openNoteFieldModalOption();
        location.options.push(separator2);
        this.buildFieldOptions();
        location.options.push(separator2);
        this.addFieldAtCurrentPositionOption();
        this.addSectionSelectModalOption();
        this.addFieldAtTheEndOfFrontmatterOption();
        if (dvApi) {
          const currentFieldsNames = genuineKeys(dvApi.page(this.file.path));
          if (![...this.plugin.fieldIndex.filesFields.get(this.file.path) || []].map((field) => field.name).every((fieldName) => currentFieldsNames.includes(fieldName))) {
            this.addAllMissingFieldsAtSection();
          }
        }
      }
      const fileClasses = this.plugin.fieldIndex.filesFileClasses.get(this.file.path) || [];
      if (fileClasses.length)
        location.options.push(separator2);
      fileClasses.forEach((fileClass) => {
        const fieldCommandSuggestModal = new FieldCommandSuggestModal(this.plugin.app);
        const fileClassOptionsList = new FileClassOptionsList(this.plugin, fileClass.getClassFile(), fieldCommandSuggestModal, this.file);
        fileClassOptionsList.createExtraOptionList(false);
        location.options.push({
          id: "manage_fileClass_attributes",
          actionLabel: `<span>Manage <b>${fileClass.name}</b> fileClass fields</span>`,
          action: () => {
            fieldCommandSuggestModal.open();
          },
          icon: "wrench"
        });
      });
      this.addFileClassToFileOption();
      this.addNewFileClassOption();
      if (openAfterCreate)
        location.open();
    }
  }
  openNoteFieldModalOption() {
    var _a;
    const lastFileClassName = (_a = this.plugin.fieldIndex.filesFileClassesNames.get(this.file.path)) == null ? void 0 : _a.last();
    if (lastFileClassName) {
      const fileClass = this.plugin.fieldIndex.fileClassesName.get(lastFileClassName);
      if (fileClass) {
        const icon = fileClass.getIcon();
        const noteFieldsComponent = new NoteFieldsComponent(this.plugin, "1", () => {
        }, this.file);
        const action = () => this.plugin.addChild(noteFieldsComponent);
        if (isMenu2(this.location)) {
          this.location.addItem((item) => {
            item.setTitle(`Open fields modal`);
            item.setIcon(icon);
            item.onClick(action);
            item.setSection("metadata-menu");
          });
        } else if (isSuggest2(this.location)) {
          this.location.options.push({
            id: `open_fields_modal`,
            actionLabel: `<span>Open fields modal</span>`,
            action,
            icon
          });
        }
        ;
      }
    }
  }
  buildFieldOptionsForMenu() {
    if (isMenu2(this.location)) {
      this.location.addItem((item) => {
        item.setIcon("clipboard-list");
        item.setTitle("Manage all fields");
        item.onClick(async (evt) => {
          const fieldCommandSuggestModal = new FieldCommandSuggestModal(this.plugin.app);
          const optionsList = new OptionsList(this.plugin, this.file, fieldCommandSuggestModal);
          await optionsList.createExtraOptionList();
        });
        item.setSection("metadata-menu");
      });
      const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian29.MarkdownView);
      if (view == null ? void 0 : view.editor) {
        const action = async () => {
          if (!view.file || !(view.file instanceof import_obsidian29.TFile))
            return;
          const optionsList = new OptionsList(this.plugin, view.file, "ManageAtCursorCommand");
          const note = await Note.buildNote(this.plugin, view.file);
          const node = note.getNodeAtPosition(view.editor.getCursor());
          if (node)
            optionsList.createAndOpenFieldModal(node);
          else
            new import_obsidian29.Notice("No field with definition at this position", 2e3);
        };
        this.location.addItem((item) => {
          item.setIcon("map-pin");
          item.setTitle("Manage field at cursor");
          item.onClick(async () => await action());
          item.setSection("metadata-menu");
        });
      }
    }
  }
  buildFieldOptions() {
    var _a;
    (_a = this.note) == null ? void 0 : _a.existingFields.filter((eF) => eF.indexedPath && Field_default.upperPath(eF.indexedPath) === this.path).forEach((eF) => {
      const field = eF.field;
      if (field) {
        const fieldManager = new FieldManager[field.type](this.plugin, field);
        fieldManager.addFieldOption(this.file, this.location, eF.indexedPath);
      }
    });
  }
  addSectionSelectModalOption() {
    const modal = new chooseSectionModal(
      this.plugin,
      this.file,
      (lineNumber, asList, asBlockquote) => FieldManager2.openFieldModal(
        this.plugin,
        this.file,
        void 0,
        lineNumber,
        asList,
        asBlockquote
      )
    );
    if (isMenu2(this.location)) {
      this.location.addItem((item) => {
        item.setIcon("enter");
        item.setTitle("Add field at section...");
        item.onClick((evt) => {
          modal.open();
        });
        item.setSection("metadata-menu");
      });
    } else if (isSuggest2(this.location)) {
      this.location.options.push({
        id: "add_field_at_section",
        actionLabel: "Add field at section...",
        action: () => modal.open(),
        icon: "enter"
      });
    }
    ;
  }
  addAllMissingFieldsAtSection() {
    const modal = new chooseSectionModal(
      this.plugin,
      this.file,
      (lineNumber, asList, asBlockquote) => insertMissingFields(
        this.plugin,
        this.file.path,
        lineNumber,
        asList,
        asBlockquote
      )
    );
    if (isMenu2(this.location)) {
      this.location.addItem((item) => {
        item.setIcon("battery-full");
        item.setTitle("Add missing fields at section...");
        item.onClick((evt) => {
          modal.open();
        });
        item.setSection("metadata-menu");
      });
    } else if (isSuggest2(this.location)) {
      this.location.options.push({
        id: "add_missing_fields_at_section",
        actionLabel: "Add missing fields at section...",
        action: () => modal.open(),
        icon: "battery-full"
      });
    }
    ;
  }
  addFieldAtTheEndOfFrontmatterOption() {
    var _a;
    if ((_a = this.plugin.app.metadataCache.getCache(this.file.path)) == null ? void 0 : _a.frontmatter) {
      if (isMenu2(this.location)) {
        this.location.addItem((item) => {
          item.setIcon("align-vertical-space-around");
          item.setTitle("Add field in frontmatter");
          item.onClick(async (evt) => {
            FieldManager2.openFieldModal(this.plugin, this.file, void 0, -1, false, false);
          });
          item.setSection("metadata-menu");
        });
      } else if (isSuggest2(this.location)) {
        this.location.options.push({
          id: "add_field_in_frontmatter",
          actionLabel: "Add a field in frontmatter...",
          action: () => FieldManager2.openFieldModal(
            this.plugin,
            this.file,
            void 0,
            -1,
            false,
            false
          ),
          icon: "align-vertical-space-around"
        });
      }
    }
  }
  addFieldAtCurrentPositionOption() {
    var _a;
    const currentView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian29.MarkdownView);
    const currentLineNumber = currentView == null ? void 0 : currentView.editor.getCursor().line;
    if (currentLineNumber !== void 0 && this.file.path == (currentView == null ? void 0 : currentView.file.path)) {
      const frontmatter = (_a = this.plugin.app.metadataCache.getFileCache(this.file)) == null ? void 0 : _a.frontmatter;
      let lineNumber = currentLineNumber;
      if (frontmatter) {
        const { start: start2, end: end2 } = getFrontmatterPosition(this.plugin, this.file);
        if (currentLineNumber >= start2.line && currentLineNumber < end2.line)
          lineNumber = -1;
      }
      if (isMenu2(this.location)) {
        this.location.addItem((item) => {
          item.setIcon("list-plus");
          item.setTitle("Add field at cursor");
          item.onClick((evt) => {
            FieldManager2.openFieldModal(
              this.plugin,
              this.file,
              void 0,
              lineNumber,
              false,
              false
            );
          });
          item.setSection("metadata-menu");
        });
      } else if (isInsertFieldCommand2(this.location)) {
        FieldManager2.openFieldModal(
          this.plugin,
          this.file,
          void 0,
          lineNumber,
          false,
          false
        );
      } else if (isSuggest2(this.location)) {
        this.location.options.push({
          id: "add_field_at_cursor",
          actionLabel: "Add field at cursor...",
          action: () => FieldManager2.openFieldModal(
            this.plugin,
            this.file,
            void 0,
            lineNumber,
            false,
            false
          ),
          icon: "list-plus"
        });
      }
      ;
    }
  }
  addFileClassToFileOption() {
    const modal = new AddFileClassToFileModal(this.plugin, this.file);
    const action = () => modal.open();
    if (isMenu2(this.location)) {
      this.location.addItem((item) => {
        item.setIcon("plus-square");
        item.setTitle(`Add ${this.plugin.settings.fileClassAlias} to ${this.file.basename}`);
        item.onClick(action);
        item.setSection("metadata-menu-fileclass");
      });
    } else if (isSuggest2(this.location)) {
      this.location.options.push({
        id: "add_fileclass_to_file",
        actionLabel: `Add ${this.plugin.settings.fileClassAlias} to ${this.file.basename}`,
        action,
        icon: "package-plus"
      });
    }
    ;
  }
  addNewFileClassOption() {
    const modal = new AddNewFileClassModal(this.plugin);
    const action = () => modal.open();
    if (this.plugin.settings.classFilesPath) {
      if (isMenu2(this.location)) {
        this.location.addItem((item) => {
          item.setIcon("file-plus-2");
          item.setTitle(`Add a new ${this.plugin.settings.fileClassAlias}`);
          item.onClick(action);
          item.setSection("metadata-menu-fileclass");
        });
      } else if (isSuggest2(this.location)) {
        this.location.options.push({
          id: "add_new_fileclass",
          actionLabel: `Add a new ${this.plugin.settings.fileClassAlias}`,
          action,
          icon: "file-plus-2"
        });
      }
    }
  }
};

// src/fields/fieldManagers/ObjectField.ts
var ObjectField = class extends FieldManager2 {
  constructor(plugin, field) {
    super(plugin, field, "Object" /* Object */);
  }
  addFieldOption(file, location, indexedPath, noteField) {
    if (noteField) {
      const action = async () => await noteField.moveToObject(`${indexedPath}`);
      if (ObjectField.isFieldOptions(location)) {
        location.addOption(FieldIcon["Object" /* Object */], action, `Go to ${this.field.name}'s fields`);
      }
    } else {
      const name = this.field.name;
      const action = async () => {
        const note = await Note.buildNote(this.plugin, file);
        const _eF = note.existingFields.find((__eF) => __eF.indexedPath === indexedPath);
        if (_eF) {
          this.createAndOpenFieldModal(file, _eF.field.name, _eF, _eF.indexedPath, void 0, void 0, void 0, void 0);
        } else {
          const fieldCommandSuggestModal = new FieldCommandSuggestModal(this.plugin.app);
          const optionsList = new OptionsList(this.plugin, file, fieldCommandSuggestModal, indexedPath);
          await optionsList.createExtraOptionList();
        }
      };
      if (ObjectField.isSuggest(location)) {
        location.options.push({
          id: `update_${name}`,
          actionLabel: `<span>Update <b>${name}</b></span>`,
          action,
          icon: FieldIcon["Object" /* Object */]
        });
      }
    }
  }
  validateOptions() {
    return true;
  }
  createSettingContainer(parentContainer, plugin, location) {
  }
  createDvField(dv, p, fieldContainer, attrs) {
    const fieldValue = dv.el("span", "{...}", { ...attrs, cls: "value-container" });
    fieldContainer.appendChild(fieldValue);
    const editBtn = fieldContainer.createEl("button");
    (0, import_obsidian30.setIcon)(editBtn, FieldIcon[this.field.type]);
    editBtn.onclick = async () => {
      const file = this.plugin.app.vault.getAbstractFileByPath(p["file"]["path"]);
      const _eF = file instanceof import_obsidian30.TFile && await Note.getExistingFieldForIndexedPath(this.plugin, file, this.field.id);
      if (_eF)
        this.createAndOpenFieldModal(file, this.field.name, _eF, _eF.indexedPath);
    };
  }
  getOptionsStr() {
    return "";
  }
  static async getExistingAndMissingFields(plugin, file, indexedPath) {
    var _a;
    const existingFields = (await Note.getExistingFields(plugin, file)).filter((eF) => eF.indexedPath && Field_default.upperPath(eF.indexedPath) === indexedPath);
    const { id, index } = Field_default.getIdAndIndex(indexedPath == null ? void 0 : indexedPath.split("____").last());
    const missingFields = ((_a = plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a.filter((_f) => {
      var _a2;
      return ((_a2 = _f.getFirstAncestor()) == null ? void 0 : _a2.id) === id;
    }).filter((_f) => !existingFields.map((eF) => eF.field.id).includes(_f.id))) || [];
    return { existingFields, missingFields };
  }
  async createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = new ObjectModal(this.plugin, file, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.open();
  }
  displayValue(container, file, value, onClicked) {
    const fields = this.plugin.fieldIndex.filesFields.get(file.path);
    container.setText(`${fields == null ? void 0 : fields.filter((_f) => _f.path.endsWith(this.field.id)).map((_f) => _f.name)}`);
  }
};

// src/modals/BaseObjectModal.ts
var import_obsidian31 = require("obsidian");
var BaseSuggestModal = class extends import_obsidian31.SuggestModal {
  constructor(plugin, file, eF, indexedPath, previousModal) {
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.previousModal = previousModal;
    this.containerEl.addClass("metadata-menu");
    this.containerEl.addClass("narrow");
    const headerContainer = this.containerEl.createDiv({ cls: "suggester-input" });
    const { id, index } = Field_default.getIdAndIndex(indexedPath);
    if ((id == null ? void 0 : id.includes("____")) || index !== void 0)
      this.buildBackButton(headerContainer);
    this.buildTitle(headerContainer);
    this.inputEl.disabled = true;
    this.inputEl.addClass("input-as-title");
    this.containerEl.find(".prompt").prepend(headerContainer);
    headerContainer.appendChild(this.inputEl);
    this.buildAddButton(headerContainer);
    this.containerEl.onkeydown = async (e) => {
      if (e.key == "Enter" && e.altKey) {
        e.preventDefault();
        await this.onAdd();
      }
      if (e.key == "Escape" && e.altKey) {
        e.preventDefault();
        this.onEscape();
      }
    };
  }
  buildBackButton(container) {
    const backButton = new import_obsidian31.ButtonComponent(container);
    backButton.setIcon("left-arrow");
    backButton.onClick(async () => {
      this.onEscape();
    });
    backButton.setCta();
    backButton.setTooltip("Go to parent field");
    const infoContainer = container.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Esc to go back");
  }
  buildAddButton(container) {
  }
  async onAdd() {
  }
  onEscape() {
    var _a;
    (_a = this.previousModal) == null ? void 0 : _a.open();
    this.close();
  }
  buildTitle(container) {
    var _a;
    let title = "";
    if (this.eF) {
      title = this.eF.field.name;
    } else if (this.indexedPath) {
      const { id: objectId, index: objectIndex } = Field_default.getIdAndIndex(this.indexedPath.split("____").last());
      const upperObject = (_a = this.plugin.fieldIndex.filesFields.get(this.file.path)) == null ? void 0 : _a.find((_f) => _f.id === objectId);
      title = `${upperObject == null ? void 0 : upperObject.name}${objectIndex ? " [" + objectIndex + "]" : ""}` || "unknown field";
    }
    const titleContainer = container.createDiv({ cls: "suggester-title" });
    titleContainer.innerHTML = `<b>${title}</b> fields`;
  }
};

// src/modals/fields/ObjectModal.ts
var ObjectModal = class extends BaseSuggestModal {
  constructor(plugin, file, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    super(plugin, file, eF, indexedPath, previousModal);
    this.plugin = plugin;
    this.file = file;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.existingFields = [];
    this.missingFields = [];
  }
  async onOpen() {
    if (this.indexedPath) {
      const upperPath = Field_default.upperIndexedPathObjectPath(this.indexedPath);
      const { index: upperFieldIndex } = Field_default.getIdAndIndex(upperPath.split("____").last());
      const { existingFields, missingFields } = await ObjectField.getExistingAndMissingFields(
        this.plugin,
        this.file,
        upperFieldIndex !== void 0 ? upperPath : this.indexedPath
      );
      this.existingFields = existingFields;
      this.missingFields = missingFields;
    }
    super.onOpen();
  }
  getSuggestions(query = "") {
    return [...this.existingFields, ...this.missingFields].filter((f) => {
      if (f instanceof ExistingField) {
        return f.field.name.toLocaleLowerCase().includes(query.toLocaleLowerCase());
      } else {
        return f.name.toLocaleLowerCase().includes(query.toLocaleLowerCase());
      }
    });
  }
  renderSuggestion(item, el) {
    const container = el.createDiv({ cls: "value-container" });
    if (item instanceof ExistingField) {
      container.createDiv({ text: `${item.field.name} :`, cls: "label-container" });
      const fM = new FieldManager[item.field.type](this.plugin, item.field);
      const valueContainer = container.createDiv();
      fM.displayValue(valueContainer, this.file, item.value !== void 0 ? item.value : "<empty>");
    } else {
      container.createDiv({ text: `${item.name} :`, cls: "label-container" });
      container.createDiv({ text: "<missing>" });
    }
  }
  async onChooseSuggestion(item, evt) {
    const reOpen = async () => {
      const eF = await Note.getExistingFieldForIndexedPath(this.plugin, this.file, this.indexedPath);
      if (eF) {
        const thisFieldManager = new FieldManager[eF.field.type](this.plugin, eF.field);
        thisFieldManager.createAndOpenFieldModal(this.file, eF.field.name, eF, eF.indexedPath, void 0, void 0, void 0, this.previousModal);
        this.close();
      }
    };
    if (item instanceof ExistingField) {
      const field = item.field;
      const fieldManager = new FieldManager[field.type](this.plugin, field);
      switch (fieldManager.type) {
        case "Boolean" /* Boolean */:
          await fieldManager.toggle(this.file, item.indexedPath);
          await reOpen();
          break;
        case "Cycle" /* Cycle */:
          await fieldManager.next(field.name, this.file, item.indexedPath);
          await reOpen();
          break;
        default:
          fieldManager.createAndOpenFieldModal(this.file, field.name, item, item.indexedPath, void 0, void 0, void 0, this);
          break;
      }
    } else {
      if (item.type === "ObjectList" /* ObjectList */) {
        await postValues(this.plugin, [{ id: `${this.indexedPath}____${item.id}`, payload: { value: "" } }], this.file);
        this.open();
      } else if (item.type === "Object" /* Object */) {
        await postValues(this.plugin, [{ id: `${this.indexedPath}____${item.id}`, payload: { value: "" } }], this.file);
        await this.plugin.fieldIndex.indexFields();
        const fieldManager = new FieldManager[item.type](this.plugin, item);
        fieldManager.createAndOpenFieldModal(this.file, item.name, void 0, `${this.indexedPath}____${item.id}`, this.lineNumber, this.asList, this.asBlockquote, this);
      } else {
        const fieldManager = new FieldManager[item.type](this.plugin, item);
        fieldManager.createAndOpenFieldModal(this.file, item.name, void 0, `${this.indexedPath}____${item.id}`, this.lineNumber, this.asList, this.asBlockquote, this);
      }
    }
  }
};

// src/modals/BaseModal.ts
var BaseModal = class extends import_obsidian32.Modal {
  constructor(plugin, file, previousModal, indexedPath) {
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
    this.previousModal = previousModal;
    this.indexedPath = indexedPath;
    this.saved = false;
  }
  onOpen() {
    this.containerEl.onkeydown = async (e) => {
      if (e.key == "Enter" && e.altKey) {
        e.preventDefault();
        await this.save();
      }
      if (e.key === "Escape" && e.altKey) {
        this.close();
      }
    };
  }
  async save() {
    throw Error("Subclass should implement a save method");
  }
  buildSimpleSaveBtn(fieldContainer) {
    fieldContainer.createDiv({ cls: "spacer" });
    const infoContainer = fieldContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    const saveBtn = new import_obsidian32.ButtonComponent(fieldContainer);
    saveBtn.setIcon("checkmark");
    saveBtn.onClick(async () => {
      await this.save();
    });
  }
  buildFooterBtn() {
    const buttonContainer = this.containerEl.createDiv({ cls: "footer-actions" });
    buttonContainer.createDiv({ cls: "spacer" });
    const infoContainer = buttonContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    const confirmButton = new import_obsidian32.ButtonComponent(buttonContainer);
    confirmButton.setIcon("checkmark");
    confirmButton.onClick(async () => {
      await this.save();
      this.close();
    });
    const cancelButton = new import_obsidian32.ButtonComponent(buttonContainer);
    cancelButton.setIcon("cross");
    cancelButton.onClick(() => {
      this.close();
    });
    this.modalEl.appendChild(buttonContainer);
  }
  async goToPreviousModal() {
    var _a;
    const pM = this.previousModal;
    if (pM && this.indexedPath) {
      const upperPath = Field_default.upperIndexedPathObjectPath(this.indexedPath);
      const { index: upperFieldIndex } = Field_default.getIdAndIndex(upperPath.split("____").last());
      const eF = await Note.getExistingFieldForIndexedPath(this.plugin, pM.file, pM.indexedPath);
      const pField = (_a = pM.eF) == null ? void 0 : _a.field;
      const pFile = pM.file;
      const pIndexedPath = pM.indexedPath;
      if (upperFieldIndex) {
        pM.close();
        const objectModal = new ObjectModal(
          this.plugin,
          this.file,
          void 0,
          upperPath,
          void 0,
          void 0,
          void 0,
          pM.previousModal
        );
        objectModal.open();
      } else if (pField && pFile) {
        pM.close();
        const fM = new FieldManager[pField.type](this.plugin, pField);
        fM.createAndOpenFieldModal(
          pFile,
          pField.name,
          eF,
          pIndexedPath,
          pM.lineNumber,
          pM.asList,
          pM.asBlockquote,
          pM.previousModal
        );
      } else {
        pM.open();
      }
    }
  }
  async onClose() {
    var _a;
    if (!this.saved)
      (_a = this.previousModal) == null ? void 0 : _a.open();
    this.saved = false;
  }
};

// src/modals/fields/InputModal.ts
var InputModal = class extends BaseModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    var _a;
    super(plugin, file, previousModal, indexedPath);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.templateValues = {};
    this.value = ((_a = this.eF) == null ? void 0 : _a.value) || "";
    if (this.field.options.template) {
      const templateFieldRegex = new RegExp(`\\{\\{(?<field>[^\\}]+?)\\}\\}`, "gu");
      const tF = this.field.options.template.matchAll(templateFieldRegex);
      let next = tF.next();
      while (!next.done) {
        if (next.value.groups) {
          const value = next.value.groups.field;
          const [name, optionsString] = value.split(/:(.*)/s).map((v) => v.trim());
          this.templateValues[name] = "";
          if (optionsString) {
            try {
              const options2 = JSON.parse(optionsString);
              this.buildTemplateSelectItem(this.contentEl.createDiv({ cls: "field-container" }), name, options2);
            } catch ({ name: errorName, message }) {
              const notice = `{{${name}}} field definition is not a valid JSON 
in <${this.field.name}> ${this.field.fileClassName ? this.field.fileClassName : "Metadata Menu"} settings`;
              if (errorName === "SyntaxError")
                new import_obsidian33.Notice(notice, 5e3);
            }
          } else {
            this.buildTemplateInputItem(this.contentEl.createDiv({ cls: "field-container" }), name);
          }
        }
        next = tF.next();
      }
      this.contentEl.createDiv({ text: "Result preview" });
      this.buildResultPreview(this.contentEl.createDiv({ cls: "field-container" }));
    } else {
      this.buildInputEl(this.contentEl.createDiv({ cls: "field-container" }));
    }
    cleanActions(this.contentEl, ".footer-actions");
    this.buildFooterBtn();
    this.containerEl.addClass("metadata-menu");
  }
  onOpen() {
    super.onOpen();
  }
  renderValue() {
    let renderedString = this.field.options.template.slice();
    Object.keys(this.templateValues).forEach((k) => {
      const fieldRegex = new RegExp(`\\{\\{${k.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(:[^\\}]*)?\\}\\}`, "u");
      renderedString = renderedString.replace(fieldRegex, this.templateValues[k]);
    });
    this.renderedValue.setValue(renderedString.replaceAll("\n", ", "));
    this.newValue = renderedString.replaceAll("\n", ", ");
  }
  buildTemplateInputItem(fieldContainer, name) {
    fieldContainer.createDiv({ cls: "label", text: name });
    const input = new import_obsidian33.TextComponent(fieldContainer);
    input.inputEl.addClass("with-label");
    input.inputEl.addClass("full-width");
    input.setPlaceholder(`Enter a value for ${name}`);
    input.onChange((value) => {
      this.templateValues[name] = value;
      this.renderValue();
    });
  }
  buildTemplateSelectItem(fieldContainer, name, options2) {
    fieldContainer.createDiv({ text: name, cls: "label" });
    fieldContainer.createDiv({ cls: "spacer" });
    const selectEl = new import_obsidian33.DropdownComponent(fieldContainer);
    selectEl.addOption("", "--select--");
    options2.forEach((o) => selectEl.addOption(o, o));
    selectEl.onChange((value) => {
      this.templateValues[name] = value;
      this.renderValue();
    });
  }
  buildResultPreview(fieldContainer) {
    this.renderedValue = new import_obsidian33.TextAreaComponent(fieldContainer);
    this.renderedValue.inputEl.addClass("full-width");
    this.renderedValue.inputEl.rows = 3;
    this.renderedValue.setValue(this.value);
    this.renderedValue.onChange((value) => this.newValue = value);
  }
  buildInputEl(container) {
    const inputEl = new import_obsidian33.TextAreaComponent(container);
    inputEl.inputEl.rows = 3;
    inputEl.inputEl.focus();
    inputEl.inputEl.addClass("full-width");
    inputEl.setValue(`${this.value || ""}`);
    inputEl.onChange((value) => this.newValue = value);
  }
  async save() {
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: this.newValue } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
    this.saved = true;
    if (this.previousModal)
      await this.goToPreviousModal();
    this.close();
  }
};

// src/fields/fieldManagers/InputField.ts
var InputField = class extends FieldManager2 {
  constructor(plugin, field) {
    super(plugin, field, "Input" /* Input */);
  }
  getOptionsStr() {
    return this.field.options.template || "";
  }
  async buildAndOpenModal(file, indexedPath) {
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const modal = new InputModal(this.plugin, file, this.field, eF, indexedPath);
    modal.titleEl.setText(`Change Value for <${this.field.name}>`);
    modal.open();
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const iconName = FieldIcon["Input" /* Input */];
    const action = async () => await this.buildAndOpenModal(file, indexedPath);
    if (InputField.isSuggest(location)) {
      location.options.push({
        id: `update_${name}`,
        actionLabel: `<span>Update <b>${name}</b></span>`,
        action,
        icon: iconName
      });
    } else if (InputField.isFieldOptions(location)) {
      location.addOption(FieldIcon["Input" /* Input */], action, `Update ${name}'s value`);
    }
  }
  createSettingContainer(container, plugin) {
    container.createEl("span", { text: "Template", cls: "label" });
    const templateContainer = container.createDiv({ cls: "field-container" });
    const templateValue = new import_obsidian34.TextAreaComponent(templateContainer);
    templateValue.inputEl.cols = 50;
    templateValue.inputEl.rows = 4;
    templateValue.inputEl.addClass("full-width");
    templateValue.setValue(this.field.options.template || "");
    templateValue.onChange((value) => {
      this.field.options.template = value;
    });
  }
  validateOptions() {
    return true;
  }
  createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = new InputModal(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.titleEl.setText(`Enter value for ${selectedFieldName}`);
    fieldModal.open();
  }
  createDvField(dv, p, fieldContainer, attrs = {}) {
    var _a, _b;
    attrs.cls = "value-container";
    const editBtn = fieldContainer.createEl("button");
    const fieldValue = dv.el("span", p[this.field.name] || "", attrs);
    fieldContainer.appendChild(fieldValue);
    const inputContainer = fieldContainer.createDiv({});
    inputContainer.hide();
    const input = inputContainer.createEl("input");
    input.value = p[this.field.name];
    const spacer = fieldContainer.createDiv({ cls: "spacer-1" });
    if ((_a = attrs.options) == null ? void 0 : _a.alwaysOn)
      spacer.hide();
    (0, import_obsidian34.setIcon)(editBtn, FieldIcon["Input" /* Input */]);
    if (!((_b = attrs == null ? void 0 : attrs.options) == null ? void 0 : _b.alwaysOn)) {
      editBtn.hide();
      spacer.show();
      fieldContainer.onmouseover = () => {
        if (!inputContainer.isShown()) {
          editBtn.show();
          spacer.hide();
        }
      };
      fieldContainer.onmouseout = () => {
        var _a2;
        editBtn.hide();
        if (!((_a2 = attrs.options) == null ? void 0 : _a2.alwaysOn))
          spacer.show();
      };
    }
    const validateIcon = inputContainer.createEl("button");
    (0, import_obsidian34.setIcon)(validateIcon, "checkmark");
    validateIcon.onclick = (e) => {
      InputField.replaceValues(this.plugin, p.file.path, this.field.id, input.value);
      inputContainer.hide();
    };
    const cancelIcon = inputContainer.createEl("button");
    (0, import_obsidian34.setIcon)(cancelIcon, "cross");
    cancelIcon.onclick = (e) => {
      var _a2;
      inputContainer.hide();
      fieldValue.show();
      editBtn.show();
      if (!((_a2 = attrs.options) == null ? void 0 : _a2.alwaysOn))
        spacer.show();
    };
    input.focus();
    input.onkeydown = (e) => {
      var _a2;
      if (e.key === "Enter") {
        InputField.replaceValues(this.plugin, p.file.path, this.field.id, input.value);
        inputContainer.hide();
      }
      if (e.key === "Escape") {
        inputContainer.hide();
        fieldValue.show();
        editBtn.show();
        if (!((_a2 = attrs.options) == null ? void 0 : _a2.alwaysOn))
          spacer.show();
      }
    };
    editBtn.onclick = async () => {
      if (this.field.options.template) {
        const file = this.plugin.app.vault.getAbstractFileByPath(p.file.path);
        if (file instanceof import_obsidian34.TFile && file.extension === "md") {
          await this.buildAndOpenModal(file, this.field.id);
        }
      } else {
        inputContainer.show();
        input.focus();
      }
      fieldValue.hide();
      editBtn.hide();
      spacer.hide();
    };
  }
};

// src/modals/fields/BooleanModal.ts
var import_obsidian35 = require("obsidian");
var BooleanModal = class extends BaseModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    super(plugin, file, previousModal, indexedPath);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.value = this.eF ? BooleanField.stringToBoolean(this.eF.value || "") : false;
    this.containerEl.addClass("metadata-menu");
    this.containerEl.addClass("narrow");
    this.buildToggleEl();
  }
  buildToggleEl() {
    const choicesContainer = this.contentEl.createDiv({ cls: "value-container" });
    choicesContainer.createDiv({ cls: "spacer" });
    const trueButton = new import_obsidian35.ButtonComponent(choicesContainer);
    trueButton.setButtonText("True");
    trueButton.setClass("left");
    choicesContainer.createDiv({ cls: "spacer" });
    const falseButton = new import_obsidian35.ButtonComponent(choicesContainer);
    falseButton.setButtonText("False");
    choicesContainer.createDiv({ cls: "spacer" });
    if (this.value) {
      trueButton.setCta();
      falseButton.removeCta();
    } else {
      falseButton.setCta();
      trueButton.removeCta();
    }
    falseButton.onClick(() => {
      this.value = false;
      falseButton.setCta();
      trueButton.removeCta();
    });
    trueButton.onClick(() => {
      this.value = true;
      trueButton.setCta();
      falseButton.removeCta();
    });
    this.buildSimpleSaveBtn(choicesContainer);
  }
  async save() {
    const value = this.value.toString();
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
    this.saved = true;
    if (this.previousModal)
      await this.goToPreviousModal();
    this.close();
  }
};

// src/fields/fieldManagers/BooleanField.ts
var BooleanField = class extends FieldManager2 {
  constructor(plugin, field) {
    super(plugin, field, "Boolean" /* Boolean */);
    this.showModalOption = false;
  }
  async toggle(file, indexedPath) {
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const value = BooleanField.stringToBoolean(eF == null ? void 0 : eF.value);
    const postValue = !value ? "true" : "false";
    await postValues(this.plugin, [{ id: indexedPath || this.field.id, payload: { value: postValue } }], file);
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const iconName = FieldIcon["Boolean" /* Boolean */];
    const action = async () => await this.toggle(file, indexedPath);
    if (BooleanField.isSuggest(location)) {
      location.options.push({
        id: `update_${name}`,
        actionLabel: `Toggle <span><b>${name}</b></span>`,
        action,
        icon: iconName
      });
    } else if (BooleanField.isFieldOptions(location)) {
      location.addOption(
        iconName,
        action,
        `Toggle ${name}`,
        this.field.fileClassName,
        file,
        indexedPath,
        this.plugin
      );
    }
    ;
  }
  getOptionsStr() {
    return "";
  }
  createSettingContainer(parentContainer, plugin) {
  }
  validateValue(value) {
    try {
      const bValue = BooleanField.stringToBoolean(value);
      return isBoolean(bValue);
    } catch (error) {
      return false;
    }
  }
  validateOptions() {
    return true;
  }
  createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = new BooleanModal(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.titleEl.setText(`Set value for ${selectedFieldName}`);
    fieldModal.open();
  }
  createDvField(dv, p, fieldContainer, attrs) {
    const checkbox = dv.el("input", "", { ...attrs, "type": "checkbox" });
    checkbox.checked = p[this.field.name];
    fieldContainer.appendChild(checkbox);
    checkbox.onchange = (value) => {
      BooleanField.replaceValues(this.plugin, p.file.path, this.field.id, checkbox.checked.toString());
    };
  }
};

// src/fields/fieldManagers/NumberField.ts
var import_obsidian37 = require("obsidian");

// src/modals/fields/NumberModal.ts
var import_obsidian36 = require("obsidian");
var NumberModal = class extends BaseModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    var _a;
    super(plugin, file, previousModal, indexedPath);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.value = ((_a = this.eF) == null ? void 0 : _a.value) || "";
    this.fieldManager = new FieldManager[this.field.type](this.plugin, this.field);
    this.containerEl.addClass("metadata-menu");
    this.buildInputEl();
  }
  onOpen() {
    super.onOpen();
  }
  decrement(numberInput) {
    const { step } = this.field.options;
    const fStep = parseFloat(step);
    const fValue = parseFloat(numberInput.getValue()) || 0;
    if (!isNaN(fStep)) {
      numberInput.setValue((fValue - fStep).toString());
    } else {
      numberInput.setValue((fValue - 1).toString());
    }
  }
  increment(numberInput) {
    const { step } = this.field.options;
    const fStep = parseFloat(step);
    const fValue = parseFloat(numberInput.getValue()) || 0;
    if (!isNaN(fStep)) {
      numberInput.setValue((fValue + fStep).toString());
    } else {
      numberInput.setValue((fValue + 1).toString());
    }
  }
  toggleButtonsState(minusBtn, plusBtn, numberInput) {
    minusBtn.setDisabled(!this.fieldManager.canDecrement(numberInput.getValue()));
    plusBtn.setDisabled(!this.fieldManager.canIncrement(numberInput.getValue()));
    if (this.fieldManager.canDecrement(numberInput.getValue())) {
      minusBtn.setCta();
    } else {
      minusBtn.removeCta();
    }
    if (this.fieldManager.canIncrement(numberInput.getValue())) {
      plusBtn.setCta();
    } else {
      plusBtn.removeCta();
    }
  }
  buildInputEl() {
    const { step } = this.field.options;
    cleanActions(this.contentEl, ".field-container");
    const fieldContainer = this.contentEl.createEl("div", { cls: "field-container" });
    this.numberInput = new import_obsidian36.TextComponent(fieldContainer);
    const numberInput = this.numberInput;
    numberInput.inputEl.focus();
    numberInput.setValue(`${this.value || ""}`);
    const minusBtn = new import_obsidian36.ButtonComponent(fieldContainer);
    minusBtn.setButtonText(`- ${!!step ? step : 1}`);
    minusBtn.setDisabled(!this.fieldManager.canDecrement(numberInput.getValue()));
    const plusBtn = new import_obsidian36.ButtonComponent(fieldContainer);
    plusBtn.setButtonText(`+ ${!!step ? step : 1}`);
    plusBtn.setDisabled(!this.fieldManager.canIncrement(numberInput.getValue()));
    fieldContainer.createDiv({ cls: "spacer" });
    this.buildSimpleSaveBtn(fieldContainer);
    cleanActions(this.contentEl, ".field-error");
    this.errorField = this.contentEl.createEl("div", { cls: "field-error" });
    this.errorField.hide();
    this.toggleButtonsState(minusBtn, plusBtn, numberInput);
    numberInput.onChange(() => {
      numberInput.inputEl.removeClass("is-invalid");
      this.errorField.hide();
      this.errorField.setText("");
      this.toggleButtonsState(minusBtn, plusBtn, numberInput);
    });
    plusBtn.onClick((e) => {
      e.preventDefault();
      this.increment(numberInput);
      this.toggleButtonsState(minusBtn, plusBtn, numberInput);
    });
    minusBtn.onClick((e) => {
      e.preventDefault();
      this.decrement(numberInput);
      this.toggleButtonsState(minusBtn, plusBtn, numberInput);
    });
  }
  async save() {
    const inputValue = this.numberInput.getValue();
    if (!this.fieldManager.validateValue(inputValue)) {
      const { min: min2, max: max2 } = this.field.options;
      this.errorField.show();
      this.errorField.setText(`value must be numeric${min2 ? " and >= " + min2 : ""} ${max2 ? " and <= " + max2 : ""}`);
      this.numberInput.inputEl.setAttr("class", "is-invalid");
      return;
    }
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: inputValue } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
    this.saved = true;
    if (this.previousModal)
      await this.goToPreviousModal();
    this.close();
  }
};

// src/fields/fieldManagers/NumberField.ts
var NumberField = class extends FieldManager2 {
  constructor(plugin, field) {
    super(plugin, field, "Number" /* Number */);
  }
  getOptionsStr() {
    const options2 = [];
    Object.keys(this.field.options).forEach((k) => {
      if (this.field.options[k])
        options2.push(`${k}: ${this.field.options[k]}`);
    });
    return options2.join(" | ");
  }
  canDecrement(value) {
    const { step, min: min2 } = this.field.options;
    const fStep = parseFloat(step);
    const fMin = parseFloat(min2);
    return !//isNaN(parseFloat(value)) ||
    (!isNaN(fMin) && (!isNaN(fStep) && (parseFloat(value) - fStep < fMin || parseFloat(value) - 1 < fMin)));
  }
  canIncrement(value) {
    const { step, max: max2 } = this.field.options;
    const fStep = parseFloat(step);
    const fMax = parseFloat(max2);
    return !//isNaN(parseFloat(value)) ||
    (!isNaN(fMax) && (!isNaN(fStep) && (parseFloat(value) + fStep > fMax || parseFloat(value) + 1 > fMax)));
  }
  validateValue(value) {
    const { min: min2, max: max2 } = this.field.options;
    const fMin = parseFloat(min2);
    const fMax = parseFloat(max2);
    const fValue = parseFloat(value);
    return !isNaN(fValue) && (isNaN(fMin) || fValue >= fMin) && (isNaN(fMax) || fValue <= fMax);
  }
  async buildAndOpenModal(file, indexedPath) {
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const modal = new NumberModal(this.plugin, file, this.field, eF, indexedPath);
    modal.titleEl.setText(`Change Value for <${this.field.name}>`);
    modal.open();
  }
  async applyStep(file, direction, indexedPath) {
    const { min: min2, max: max2, step } = this.field.options;
    const fMin = parseFloat(min2);
    const fMax = parseFloat(max2);
    const fStep = parseFloat(step);
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const value = (eF == null ? void 0 : eF.value) || "";
    const fValue = parseFloat(value);
    if (!isNaN(fValue)) {
      switch (direction) {
        case "decrease":
          if (!isNaN(fMin) && fValue - fStep >= fMin) {
            await postValues(this.plugin, [{ id: indexedPath || this.field.id, payload: { value: (fValue - fStep).toString() } }], file);
          }
          break;
        case "increase":
          if (!isNaN(fMax) && fValue + fStep <= fMax) {
            await postValues(this.plugin, [{ id: indexedPath || this.field.id, payload: { value: (fValue + fStep).toString() } }], file);
          }
        default:
          break;
      }
    }
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const { step } = this.field.options;
    const fStep = parseFloat(step);
    const action = async () => await this.buildAndOpenModal(file, indexedPath);
    const increase = async () => await this.applyStep(file, "increase", indexedPath);
    const decrease = async () => await this.applyStep(file, "decrease", indexedPath);
    if (NumberField.isSuggest(location)) {
      location.options.push({
        id: `update_${name}`,
        actionLabel: `<span>Update <b>${name}</b></span>`,
        action,
        icon: FieldIcon["Number" /* Number */]
      });
    } else if (NumberField.isFieldOptions(location)) {
      if (step) {
        location.addOption("minus-square", decrease, `Decrease ${name} by ${step}`);
        location.addOption("plus-square", increase, `Increase ${name} by ${step}`);
      }
      location.addOption(FieldIcon["Number" /* Number */], action, `Update ${name}'s value`);
    }
    ;
  }
  createNumberContainer(container) {
    const numberStepValueContainer = container.createDiv({ cls: "field-container" });
    numberStepValueContainer.createEl("span", { text: "Step (optional)", cls: "label" });
    numberStepValueContainer.createDiv({ cls: "spacer" });
    this.numberStepValue = new import_obsidian37.TextComponent(numberStepValueContainer);
    this.numberStepValue.inputEl.addClass("with-label");
    this.numberStepValue.setValue(`${this.field.options.step}` || "");
    const numberMinValueContainer = container.createDiv({ cls: "field-container" });
    numberMinValueContainer.createEl("span", { text: "Min value (optional)", cls: "label" });
    this.numberMinValue = new import_obsidian37.TextComponent(numberMinValueContainer);
    this.numberMinValue.inputEl.addClass("full-width");
    this.numberMinValue.inputEl.addClass("with-label");
    this.numberMinValue.setValue(`${this.field.options.min}` || "");
    const numberMaxValueContainer = container.createDiv({ cls: "field-container" });
    numberMaxValueContainer.createEl("span", { text: "Max value (optional)", cls: "label" });
    this.numberMaxValue = new import_obsidian37.TextComponent(numberMaxValueContainer);
    this.numberMaxValue.inputEl.addClass("full-width");
    this.numberMaxValue.inputEl.addClass("with-label");
    this.numberMaxValue.setValue(`${this.field.options.max}` || "");
    this.numberStepValue.onChange((value) => {
      this.field.options.step = parseFloat(value);
      FieldSettingsModal.removeValidationError(this.numberStepValue);
    });
    this.numberMinValue.onChange((value) => {
      this.field.options.min = parseFloat(value);
      FieldSettingsModal.removeValidationError(this.numberMinValue);
    });
    this.numberMaxValue.onChange((value) => {
      this.field.options.max = parseFloat(value);
      FieldSettingsModal.removeValidationError(this.numberMaxValue);
    });
  }
  createSettingContainer(container, plugin) {
    this.createNumberContainer(container);
  }
  validateOptions() {
    let error = false;
    if (this.field.options.step && isNaN(parseFloat(this.field.options.step))) {
      FieldSettingsModal.setValidationError(
        this.numberStepValue,
        "Values must be numeric."
      );
      error = true;
    }
    if (this.field.options.min && isNaN(parseFloat(this.field.options.min))) {
      FieldSettingsModal.setValidationError(
        this.numberMinValue,
        "Values must be numeric."
      );
      error = true;
    }
    if (this.field.options.max && isNaN(parseFloat(this.field.options.max))) {
      FieldSettingsModal.setValidationError(
        this.numberMaxValue,
        "Values must be numeric."
      );
      error = true;
    }
    return !error;
  }
  createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = new NumberModal(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.titleEl.setText(`Enter value for ${selectedFieldName}`);
    fieldModal.open();
  }
  toggleDvButtons(decrementBtn, incrementBtn, value) {
    if (this.canDecrement(value)) {
      decrementBtn.removeClass("disabled");
    } else {
      decrementBtn.addClass("disabled");
    }
    if (this.canIncrement(value)) {
      incrementBtn.removeClass("disabled");
    } else {
      incrementBtn.addClass("disabled");
      ;
    }
  }
  createDvField(dv, p, fieldContainer, attrs = {}) {
    var _a;
    attrs.cls = "value-container";
    const fieldValue = dv.el("span", p[this.field.name], attrs);
    fieldContainer.appendChild(fieldValue);
    const inputContainer = fieldContainer.createDiv({});
    const input = inputContainer.createEl("input");
    input.value = p[this.field.name] || "";
    const tripleSpacer = fieldContainer.createDiv({ cls: "spacer-3" });
    const editButton = fieldContainer.createEl("button");
    (0, import_obsidian37.setIcon)(editButton, FieldIcon["Number" /* Number */]);
    const decrementButton = fieldContainer.createEl("button");
    (0, import_obsidian37.setIcon)(decrementButton, "left-arrow");
    const incrementButton = fieldContainer.createEl("button");
    (0, import_obsidian37.setIcon)(incrementButton, "right-arrow");
    if (!((_a = attrs == null ? void 0 : attrs.options) == null ? void 0 : _a.alwaysOn)) {
      editButton.hide();
      decrementButton.hide();
      incrementButton.hide();
      tripleSpacer.show();
      fieldContainer.onmouseover = () => {
        editButton.show();
        decrementButton.show();
        incrementButton.show();
        tripleSpacer.hide();
      };
      fieldContainer.onmouseout = () => {
        editButton.hide();
        decrementButton.hide();
        incrementButton.hide();
        tripleSpacer.show();
      };
    }
    const validateIcon = fieldContainer.createEl("button");
    (0, import_obsidian37.setIcon)(validateIcon, "checkmark");
    validateIcon.onclick = async () => {
      if (this.validateValue(input.value)) {
        const file = this.plugin.app.vault.getAbstractFileByPath(p.file.path);
        if (file instanceof import_obsidian37.TFile && file.extension == "md") {
          await postValues(this.plugin, [{ id: this.field.id, payload: { value: input.value } }], file);
          this.toggleDvButtons(decrementButton, incrementButton, input.value);
        }
        fieldContainer.removeChild(inputContainer);
      }
    };
    inputContainer == null ? void 0 : inputContainer.appendChild(validateIcon);
    const cancelIcon = fieldContainer.createEl("button");
    (0, import_obsidian37.setIcon)(cancelIcon, "cross");
    cancelIcon.onclick = (e) => {
      fieldContainer.removeChild(inputContainer);
      fieldContainer.appendChild(fieldValue);
      fieldContainer.appendChild(decrementButton);
      fieldContainer.appendChild(editButton);
      fieldContainer.appendChild(incrementButton);
      fieldContainer.appendChild(tripleSpacer);
    };
    inputContainer.appendChild(cancelIcon);
    input.focus();
    input.onkeyup = (e) => {
      if (!this.validateValue(input.value)) {
        input.addClass("is-invalid");
        validateIcon.addClass("disabled");
      } else {
        input.removeClass("is-invalid");
        validateIcon.removeClass("disabled");
      }
    };
    input.onkeydown = async (e) => {
      if (e.key === "Enter") {
        if (this.validateValue(input.value)) {
          const file = this.plugin.app.vault.getAbstractFileByPath(p.file.path);
          if (file instanceof import_obsidian37.TFile && file.extension == "md") {
            await postValues(this.plugin, [{ id: this.field.id, payload: { value: input.value } }], file);
            this.toggleDvButtons(decrementButton, incrementButton, input.value);
          }
          fieldContainer.removeChild(inputContainer);
        }
      }
      if (e.key === "Escape") {
        fieldContainer.removeChild(inputContainer);
        fieldContainer.appendChild(fieldValue);
        fieldContainer.appendChild(decrementButton);
        fieldContainer.appendChild(editButton);
        fieldContainer.appendChild(incrementButton);
        fieldContainer.appendChild(tripleSpacer);
      }
    };
    editButton.onclick = () => {
      fieldContainer.removeChild(fieldValue);
      fieldContainer.removeChild(editButton);
      fieldContainer.removeChild(decrementButton);
      fieldContainer.removeChild(incrementButton);
      fieldContainer.removeChild(tripleSpacer);
      fieldContainer.appendChild(inputContainer);
      input.focus();
    };
    decrementButton.onclick = async () => {
      if (this.canDecrement(p[this.field.name])) {
        const { step } = this.field.options;
        const fStep = parseFloat(step);
        const file = this.plugin.app.vault.getAbstractFileByPath(p["file"]["path"]);
        if (file instanceof import_obsidian37.TFile && file.extension == "md") {
          const newValue = (!!fStep ? p[this.field.name] - fStep : p[this.field.name] - 1).toString();
          await postValues(this.plugin, [{ id: this.field.id, payload: { value: newValue } }], file);
          this.toggleDvButtons(decrementButton, incrementButton, newValue);
        }
      }
    };
    incrementButton.onclick = async () => {
      if (this.canIncrement(p[this.field.name])) {
        const { step } = this.field.options;
        const fStep = parseFloat(step);
        const file = this.plugin.app.vault.getAbstractFileByPath(p["file"]["path"]);
        if (file instanceof import_obsidian37.TFile && file.extension == "md") {
          const newValue = (!!fStep ? p[this.field.name] + fStep : p[this.field.name] + 1).toString();
          await postValues(this.plugin, [{ id: this.field.id, payload: { value: newValue } }], file);
          this.toggleDvButtons(decrementButton, incrementButton, newValue);
        }
      }
    };
    fieldContainer.removeChild(inputContainer);
    fieldContainer.appendChild(fieldValue);
    fieldContainer.appendChild(decrementButton);
    fieldContainer.appendChild(editButton);
    fieldContainer.appendChild(incrementButton);
    fieldContainer.appendChild(tripleSpacer);
    this.toggleDvButtons(decrementButton, incrementButton, p[this.field.name]);
  }
};

// src/fields/fieldManagers/SelectField.ts
var import_obsidian42 = require("obsidian");

// src/modals/BaseSelectModal.ts
var import_obsidian38 = require("obsidian");

// src/types/selectValuesSourceTypes.ts
var Type2 = /* @__PURE__ */ ((Type3) => {
  Type3["ValuesList"] = "ValuesList";
  Type3["ValuesListNotePath"] = "ValuesListNotePath";
  Type3["ValuesFromDVQuery"] = "ValuesFromDVQuery";
  return Type3;
})(Type2 || {});
var Key = {
  "ValuesList": "valuesList",
  "ValuesListNotePath": "valuesListNotePath",
  "ValuesFromDVQuery": "valuesFromDVQuery"
};
var typeDisplay = {
  "ValuesList": "Values defined in these settings",
  "ValuesListNotePath": "Values from a note",
  "ValuesFromDVQuery": "Values returned from a dataview query"
};

// src/modals/BaseSelectModal.ts
var BaseSelecttModal = class extends import_obsidian38.SuggestModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.containerEl.addClass("metadata-menu");
    const inputContainer = this.containerEl.createDiv({ cls: "suggester-input" });
    inputContainer.appendChild(this.inputEl);
    this.containerEl.find(".prompt").prepend(inputContainer);
    cleanActions(this.containerEl, ".footer-actions");
    const footerActionsContainer = this.containerEl.createDiv({ cls: "footer-actions" });
    this.buildAddButton(inputContainer);
    this.buildFooterActions(footerActionsContainer);
  }
  buildAddButton(container) {
    this.addButton = new import_obsidian38.ButtonComponent(container);
    this.addButton.setIcon("plus");
    this.addButton.onClick(async () => await this.onAdd());
    this.addButton.setCta();
    this.addButton.setTooltip("Add this value to this field settings");
    this.addButton.buttonEl.hide();
  }
  buildFooterActions(footerActionsContainer) {
    footerActionsContainer.createDiv({ cls: "spacer" });
    this.buildConfirm(footerActionsContainer);
    const cancelButton = new import_obsidian38.ButtonComponent(footerActionsContainer);
    cancelButton.setIcon("cross");
    cancelButton.onClick(() => this.close());
    cancelButton.setTooltip("Cancel");
    const clearButton = new import_obsidian38.ButtonComponent(footerActionsContainer);
    clearButton.setIcon("eraser");
    clearButton.setTooltip("Clear field's value(s)");
    clearButton.onClick(async () => {
      await this.clearValues();
      this.close();
    });
    clearButton.buttonEl.addClass("danger");
    this.modalEl.appendChild(footerActionsContainer);
  }
  buildConfirm(footerActionsContainer) {
  }
  close(openPreviousModal = true) {
    var _a;
    if (openPreviousModal)
      (_a = this.previousModal) == null ? void 0 : _a.open();
    super.close();
  }
  async onAdd() {
    throw Error("This class has to implement an onAdd method");
  }
  async addNewValueToSettings() {
    var _a, _b;
    const newValue = this.inputEl.value;
    const fileClassName = (_b = (_a = this.plugin.fieldIndex.filesFields.get(this.file.path)) == null ? void 0 : _a.find((field) => field.id === this.field.id)) == null ? void 0 : _b.fileClassName;
    if (fileClassName) {
      const fileClass = this.plugin.fieldIndex.fileClassesName.get(fileClassName);
      const fileClassAttribute = fileClass == null ? void 0 : fileClass.attributes.find((attr) => attr.id === this.field.id);
      if (fileClass && fileClassAttribute) {
        let newOptions;
        if (Array.isArray(fileClassAttribute.options)) {
          newOptions = [...fileClassAttribute.options, newValue];
          await fileClass.updateAttribute(fileClassAttribute.type, fileClassAttribute.name, newOptions, fileClassAttribute);
        } else if (fileClassAttribute.options.sourceType === "ValuesList" /* ValuesList */) {
          newOptions = fileClassAttribute.options.valuesList;
          newOptions[`${Object.keys(fileClassAttribute.options.valuesList).length + 1}`] = newValue;
          await fileClass.updateAttribute(fileClassAttribute.type, fileClassAttribute.name, newOptions, fileClassAttribute);
        } else if (fileClassAttribute.options.sourceType === "ValuesListNotePath" /* ValuesListNotePath */) {
          const valuesFile = this.plugin.app.vault.getAbstractFileByPath(fileClassAttribute.options.valuesListNotePath);
          if (valuesFile instanceof import_obsidian38.TFile && valuesFile.extension == "md") {
            const result = await this.plugin.app.vault.read(valuesFile);
            this.plugin.app.vault.modify(valuesFile, `${result}
${newValue}`);
          }
        } else {
          newOptions = fileClassAttribute.options;
          newOptions[`${Object.keys(fileClassAttribute.options).length + 1}`] = newValue;
          await fileClass.updateAttribute(fileClassAttribute.type, fileClassAttribute.name, newOptions, fileClassAttribute);
        }
      }
    } else {
      const presetField = this.plugin.presetFields.find((field) => field.name === this.field.name);
      if ((presetField == null ? void 0 : presetField.options.sourceType) === "ValuesListNotePath" /* ValuesListNotePath */) {
        const valuesFile = this.plugin.app.vault.getAbstractFileByPath(presetField.options.valuesListNotePath);
        if (valuesFile instanceof import_obsidian38.TFile && valuesFile.extension == "md") {
          const result = await this.plugin.app.vault.read(valuesFile);
          this.plugin.app.vault.modify(valuesFile, `${result}
${newValue}`);
        }
      } else if ((presetField == null ? void 0 : presetField.options.sourceType) === "ValuesList" /* ValuesList */) {
        const currentExistingField = this.plugin.presetFields.find((p) => p.id == this.field.id);
        if (currentExistingField) {
          const valuesList = currentExistingField.options.valuesList;
          valuesList[`${Object.keys(valuesList).length + 1}`] = newValue;
        }
        this.plugin.saveSettings();
      }
    }
  }
  async clearValues() {
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: "" } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
  }
  getSuggestions(query) {
    var _a;
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    let dvFile;
    if (dvApi)
      dvFile = dvApi.page(this.file.path);
    const fieldManager = new FieldManager[this.field.type](this.plugin, this.field);
    const values = fieldManager.getOptionsList(dvFile).filter((o) => String(o).toLowerCase().includes(query.toLowerCase()));
    if (this.addButton) {
      values.some((p) => p === query) || this.field.options.sourceType == "ValuesFromDVQuery" /* ValuesFromDVQuery */ || !query ? this.addButton.buttonEl.hide() : this.addButton.buttonEl.show();
    }
    ;
    return values;
  }
  renderSuggestion(value, el) {
    el.setText(value);
    el.addClass("value-container");
  }
  async onChooseSuggestion(item, evt) {
  }
};

// src/modals/fields/SelectModal.ts
var ValueSuggestModal = class extends BaseSelecttModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    var _a;
    super(plugin, file, field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.value = ((_a = this.eF) == null ? void 0 : _a.value) || "";
  }
  async onAdd() {
    await this.addNewValueToSettings();
    await this.saveItem(this.inputEl.value);
    this.close();
  }
  renderSuggestion(value, el) {
    super.renderSuggestion(value, el);
    if (value === this.value)
      el.addClass("value-checked");
  }
  async saveItem(item) {
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: item.toString() } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
  }
  async onChooseSuggestion(item, evt) {
    await this.saveItem(item);
  }
};

// src/fields/fieldManagers/AbstractListBasedField.ts
var import_obsidian41 = require("obsidian");

// src/suggester/FileSuggester.ts
var import_obsidian40 = require("obsidian");

// src/suggester/suggest.ts
var import_obsidian39 = require("obsidian");

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options2 = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options2.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options2 = _ref2.options;
  var _options$element = options2.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options2 = _ref5.options;
  var _options$gpuAccelerat = options2.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options2.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options2.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance = _ref.instance, options2 = _ref.options;
  var _options$scroll = options2.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options2.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _options = options2, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options2 = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options2.fallbackPlacements, padding = options2.padding, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, _options$flipVariatio = options2.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options2.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options2 = _ref2.options, name = _ref2.name;
  var _options$offset = options2.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options2 = _ref.options, name = _ref.name;
  var _options$mainAxis = options2.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options2.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options2.boundary, rootBoundary = options2.rootBoundary, altBoundary = options2.altBoundary, padding = options2.padding, _options$tether = options2.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options2.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce3(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options2) {
    if (options2 === void 0) {
      options2 = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options3 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options3);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce3(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options2).then(function(state2) {
      if (!isDestroyed && options2.onFirstUpdate) {
        options2.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options3 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance,
            options: options3
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/suggester/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(inputEl) {
    this.inputEl = inputEl;
    this.scope = new import_obsidian39.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/suggester/FileSuggester.ts
var FileSuggest = class extends TextInputSuggest {
  constructor(inputEl, plugin, folder, extenstion = "md") {
    super(inputEl);
    this.inputEl = inputEl;
    this.plugin = plugin;
    this.folder = folder;
    this.extenstion = extenstion;
    this.plugin = plugin;
  }
  getSuggestions(input_str) {
    const all_files = [];
    try {
      all_files.push(...get_tfiles_from_folder(this.plugin, this.folder));
    } catch (error) {
    }
    const files = [];
    const lower_input_str = input_str.toLowerCase();
    all_files.forEach((file) => {
      if (file instanceof import_obsidian40.TFile && file.extension === this.extenstion && file.path.toLowerCase().contains(lower_input_str)) {
        files.push(file);
      }
    });
    return files;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/fields/fieldManagers/AbstractListBasedField.ts
var AbstractListBasedField = class extends FieldManager2 {
  constructor(plugin, field, type) {
    super(plugin, field, type);
  }
  createListNotePathContainer(container, plugin) {
    const valuesListNotePathContainer = container.createDiv({ cls: "field-container" });
    valuesListNotePathContainer.createDiv({ text: `Path of the note`, cls: "label" });
    const input = new import_obsidian41.TextComponent(valuesListNotePathContainer);
    input.inputEl.addClass("full-width");
    input.inputEl.addClass("with-label");
    new FileSuggest(
      input.inputEl,
      plugin,
      "/"
    );
    const listNotePath = this.field.options.valuesListNotePath;
    input.setValue(listNotePath || "");
    input.setPlaceholder("Path/of/the/note.md");
    input.onChange((value) => this.field.options.valuesListNotePath = value);
    return valuesListNotePathContainer;
  }
  removePresetValue(key) {
    let newValues = {};
    for (let _key in this.field.options.valuesList) {
      if (key !== _key) {
        newValues[_key] = this.field.options.valuesList[_key];
      }
      ;
    }
    ;
    this.field.options.valuesList = newValues;
  }
  createValuesListContainer(parentContainer) {
    const presetValuesFields = parentContainer.createDiv();
    const valuesList = presetValuesFields.createDiv();
    const valuesListBody = valuesList.createDiv();
    Object.keys(this.field.options.valuesList).forEach((key) => {
      this.valuesPromptComponents.push(this.createValueContainer(valuesListBody, key));
    });
    this.createAddButton(valuesList, valuesListBody);
    return presetValuesFields;
  }
  createValueContainer(parentNode, key) {
    const values = this.field.options.valuesList || {};
    const presetValue = values[key];
    const valueContainer = parentNode.createDiv({ cls: "field-container" });
    const input = new import_obsidian41.TextComponent(valueContainer);
    input.inputEl.addClass("full-width");
    input.setValue(presetValue);
    input.onChange((value) => {
      this.field.options.valuesList[key] = value;
      FieldSettingsModal.removeValidationError(input);
    });
    const valueRemoveButton = new import_obsidian41.ButtonComponent(valueContainer);
    valueRemoveButton.setIcon("trash").onClick((evt) => {
      evt.preventDefault();
      FieldSettingsModal.removeValidationError(input);
      this.removePresetValue(key);
      parentNode.removeChild(valueContainer);
      this.valuesPromptComponents.remove(input);
    });
    if (key != Object.keys(this.field.options)[0]) {
      const valueUpgradeButton = new import_obsidian41.ButtonComponent(valueContainer);
      (0, import_obsidian41.setIcon)(valueUpgradeButton.buttonEl, "up-chevron-glyph");
      valueUpgradeButton.onClick((evt) => {
        const thisValue = values[key];
        const inputIndex = this.valuesPromptComponents.indexOf(input);
        const upperComponent = inputIndex !== -1 ? this.valuesPromptComponents[inputIndex - 1] : this.valuesPromptComponents.last();
        if (upperComponent) {
          const upperValue = upperComponent.inputEl.value;
          const upperKey = Object.keys(values).filter((k) => values[k] == upperValue)[0];
          if (upperKey) {
            upperComponent.setValue(thisValue);
            values[upperKey] = thisValue;
            input.setValue(upperValue);
            values[key] = upperValue;
          }
          ;
        }
        ;
      });
    }
    ;
    return input;
  }
  validateValue(value) {
    return true;
  }
  getOptionsStr() {
    switch (this.field.options.sourceType) {
      case "ValuesList" /* ValuesList */:
        return Object.values(this.field.options.valuesList).join(", ");
      case "ValuesListNotePath" /* ValuesListNotePath */:
        return this.field.options.valuesListNotePath;
      case "ValuesFromDVQuery" /* ValuesFromDVQuery */:
        return this.field.options.valuesFromDVQuery;
      default:
        return "";
    }
  }
  getOptionsList(dvFile = void 0) {
    var _a;
    let values = [];
    if (Array.isArray(this.field.options)) {
      values = this.field.options;
    } else if (!this.field.options.sourceType) {
      values = Object.values(this.field.options);
    } else {
      switch (this.field.options.sourceType) {
        case "ValuesList" /* ValuesList */:
          values = Object.values(this.field.options.valuesList);
          break;
        case "ValuesListNotePath" /* ValuesListNotePath */:
          values = this.plugin.fieldIndex.valuesListNotePathValues.get(this.field.options.valuesListNotePath) || [];
          break;
        case "ValuesFromDVQuery" /* ValuesFromDVQuery */:
          {
            const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
            if (dvApi) {
              values = new Function("dv", "current", `return ${this.field.options.valuesFromDVQuery}`)(dvApi, dvFile || {});
            } else {
              values = [];
            }
          }
          break;
        default:
          values = [];
          break;
      }
    }
    return values;
  }
  validateOptions() {
    let error = false;
    let prevComponent;
    const vPC = this.valuesPromptComponents;
    vPC.forEach((input, i) => {
      var _a, _b;
      if (vPC.length > 1) {
        if (i === 0) {
          prevComponent = vPC[vPC.length - 1];
        }
        if (prevComponent.inputEl.value === input.inputEl.value) {
          FieldSettingsModal.setValidationError(
            input,
            "Two adjacent values can't be equal"
          );
          error = true;
        }
        prevComponent = input;
      }
      if (/[,]/gu.test(input.inputEl.value) && ((_a = input.inputEl.parentElement) == null ? void 0 : _a.lastElementChild)) {
        FieldSettingsModal.setValidationError(
          input,
          "Values cannot contain a comma"
        );
        error = true;
      }
      ;
      if (input.inputEl.value == "" && ((_b = input.inputEl.parentElement) == null ? void 0 : _b.lastElementChild)) {
        FieldSettingsModal.setValidationError(
          input,
          "Values can't be null."
        );
        error = true;
      }
      ;
    });
    return !error;
  }
  createAddButton(valuesList, valuesListBody) {
    const valuesListFooter = valuesList.createDiv();
    const addValue = valuesListFooter.createEl("button");
    addValue.type = "button";
    addValue.textContent = "Add a value";
    addValue.onClickEvent(async (evt) => {
      evt.preventDefault();
      let newKeyNumber = 1;
      Object.keys(this.field.options.valuesList).forEach((key) => {
        if (parseInt(key) && parseInt(key) >= newKeyNumber) {
          newKeyNumber = parseInt(key) + 1;
        }
        ;
      });
      const newKey = newKeyNumber.toString();
      this.field.options.valuesList[newKey] = "";
      this.valuesPromptComponents.push(this.createValueContainer(valuesListBody, newKey));
    });
    valuesList.createEl("hr");
  }
  createValuesFromDVQueryContainer(parentContainer) {
    const valuesFromDVQueryTopContainer = parentContainer.createDiv({ cls: "vstacked" });
    valuesFromDVQueryTopContainer.createEl("span", { text: "Dataview function" });
    valuesFromDVQueryTopContainer.createEl("span", { text: "Dataview query returning a list of string (<dv> object is available)", cls: "sub-text" });
    const valuesFromDVQueryContainer = valuesFromDVQueryTopContainer.createDiv({ cls: "field-container" });
    const valuesFromDVQuery = new import_obsidian41.TextAreaComponent(valuesFromDVQueryContainer);
    valuesFromDVQuery.inputEl.addClass("full-width");
    valuesFromDVQuery.inputEl.cols = 65;
    valuesFromDVQuery.inputEl.rows = 8;
    valuesFromDVQuery.setPlaceholder("ex: dv.pages('#student').map(p => p.name)");
    valuesFromDVQuery.setValue(this.field.options.valuesFromDVQuery || "");
    valuesFromDVQuery.onChange((value) => {
      this.field.options.valuesFromDVQuery = value;
    });
    return valuesFromDVQueryTopContainer;
  }
  displaySelectedTypeContainer(optionContainers, value) {
    Object.keys(optionContainers).forEach((key) => {
      if (key === value) {
        optionContainers[key].show();
      } else {
        optionContainers[key].hide();
      }
    });
  }
  createSettingContainer(container, plugin, location) {
    const sourceTypeContainer = container.createDiv({ cls: "field-container" });
    sourceTypeContainer.createDiv({ text: "Values source type", cls: "label" });
    sourceTypeContainer.createDiv({ cls: "spacer" });
    const sourceType = new import_obsidian41.DropdownComponent(sourceTypeContainer);
    if (!this.field.options.sourceType) {
      if (typeof this.field.options === "object" && Object.keys(this.field.options).every((key) => !isNaN(parseInt(key)))) {
        const valuesList = {};
        Object.keys(this.field.options).forEach((key) => valuesList[key] = this.field.options[key]);
        this.field.options = {};
        this.field.options.valuesList = valuesList;
      } else {
        this.field.options = {};
      }
      this.field.options.sourceType = "ValuesList" /* ValuesList */;
      this.field.options.valuesListNotePath = "";
      this.field.options.valuesFromDVQuery = "";
    }
    Object.keys(Type2).forEach((option) => sourceType.addOption(option, typeDisplay[option]));
    sourceType.setValue(this.field.options.sourceType || "ValuesList" /* ValuesList */);
    const valuesListNotePathContainer = this.createListNotePathContainer(container, plugin);
    const presetValuesFieldsContainer = this.createValuesListContainer(container);
    const valuesFromDVQueryContainer = this.createValuesFromDVQueryContainer(container);
    const valuesContainers = {
      "ValuesList": presetValuesFieldsContainer,
      "ValuesListNotePath": valuesListNotePathContainer,
      "ValuesFromDVQuery": valuesFromDVQueryContainer
    };
    sourceType.onChange((value) => {
      this.field.options.sourceType = value;
      this.displaySelectedTypeContainer(valuesContainers, value);
    });
    this.displaySelectedTypeContainer(valuesContainers, this.field.options.sourceType);
  }
  createDvField(dv, p, fieldContainer, attrs = {}) {
    attrs.cls = "value-container";
    fieldContainer.appendChild(dv.el("span", p[this.field.name] || "", attrs));
  }
};

// src/fields/fieldManagers/SelectField.ts
var SelectField = class extends AbstractListBasedField {
  constructor(plugin, field) {
    super(plugin, field, "Select" /* Select */);
    this.valuesPromptComponents = [];
  }
  async buildAndOpenModal(file, indexedPath) {
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const modal = new ValueSuggestModal(this.plugin, file, this.field, eF, indexedPath);
    modal.titleEl.setText("Select value");
    modal.open();
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const action = async () => await this.buildAndOpenModal(file, indexedPath);
    if (SelectField.isSuggest(location)) {
      location.options.push({
        id: `update_${name}`,
        actionLabel: `<span>Update <b>${name}</b></span>`,
        action,
        icon: FieldIcon["Select" /* Select */]
      });
    } else if (SelectField.isFieldOptions(location)) {
      location.addOption(FieldIcon["Select" /* Select */], action, `Update ${name}'s value`);
    }
    ;
  }
  createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = new ValueSuggestModal(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.titleEl.setText(`Select option for ${selectedFieldName}`);
    fieldModal.open();
  }
  createDvField(dv, p, fieldContainer, attrs = {}) {
    var _a;
    attrs.cls = "value-container";
    fieldContainer.appendChild(dv.el("span", p[this.field.name] || "", attrs));
    const spacer = fieldContainer.createEl("div", { cls: "spacer-1" });
    const dropDownButton = fieldContainer.createEl("button");
    (0, import_obsidian42.setIcon)(dropDownButton, "down-chevron-glyph");
    const file = this.plugin.app.vault.getAbstractFileByPath(p["file"]["path"]);
    if (file instanceof import_obsidian42.TFile && file.extension == "md") {
      dropDownButton.onclick = async () => await this.buildAndOpenModal(file);
    } else {
      dropDownButton.onclick = () => {
      };
    }
    if (!((_a = attrs == null ? void 0 : attrs.options) == null ? void 0 : _a.alwaysOn)) {
      dropDownButton.hide();
      spacer.show();
      fieldContainer.onmouseover = () => {
        dropDownButton.show();
        spacer.hide();
      };
      fieldContainer.onmouseout = () => {
        dropDownButton.hide();
        spacer.show();
      };
    }
  }
};

// src/fields/fieldManagers/CycleField.ts
var import_obsidian43 = require("obsidian");
var CycleField = class extends AbstractListBasedField {
  constructor(plugin, field) {
    super(plugin, field, "Cycle" /* Cycle */);
    this.valuesPromptComponents = [];
    this.showModalOption = false;
  }
  createSettingContainer(container, plugin, location) {
    const allowNullValueContainer = container.createDiv({ cls: "field-container" });
    allowNullValueContainer.createDiv({ cls: "label", text: "Cycle begins by a null value" });
    allowNullValueContainer.createDiv({ cls: "spacer" });
    const allowNullToggler = new import_obsidian43.ToggleComponent(allowNullValueContainer);
    allowNullToggler.setValue(this.field.options.allowNull || false);
    allowNullToggler.onChange((value) => this.field.options.allowNull = value);
    super.createSettingContainer(container, plugin, location);
  }
  nextOption(rawValue) {
    let nextOption;
    const values = this.getOptionsList();
    const value = !rawValue ? "" : rawValue.toString();
    if (values.indexOf(value) === -1) {
      nextOption = values[0] || "";
    } else {
      nextOption = values[(values.indexOf(value) + 1) % values.length];
    }
    return nextOption;
  }
  getOptionsList() {
    return this.field.options.allowNull ? ["", ...super.getOptionsList()] : super.getOptionsList();
  }
  displayValue(container, file, value, onClicked) {
    let valueText;
    switch (value) {
      case void 0:
        valueText = "";
        break;
      case null:
        valueText = "";
        break;
      case false:
        valueText = "false";
        break;
      case 0:
        valueText = "0";
        break;
      default:
        valueText = value.toString() || "";
    }
    container.createDiv({ text: valueText });
  }
  async next(name, file, indexedPath) {
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const value = (eF == null ? void 0 : eF.value) || "";
    await postValues(this.plugin, [{ id: indexedPath || this.field.id, payload: { value: this.nextOption(value).toString() } }], file);
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const iconName = FieldIcon["Cycle" /* Cycle */];
    const action = async () => this.next(name, file, indexedPath);
    if (CycleField.isSuggest(location)) {
      location.options.push({
        id: `cycle_${name}`,
        actionLabel: `<span>Cycle <b>${name}</b></span>`,
        action,
        icon: iconName
      });
    } else if (CycleField.isFieldOptions(location)) {
      location.addOption(iconName, action, `Cycle ${name}`);
    }
    ;
  }
  createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = new ValueSuggestModal(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.titleEl.setText(`Select option for ${selectedFieldName}`);
    fieldModal.open();
  }
  createDvField(dv, p, fieldContainer, attrs = {}) {
    var _a;
    attrs.cls = "value-container";
    fieldContainer.appendChild(dv.el("span", p[this.field.name] || "", attrs));
    const spacer = fieldContainer.createEl("div", { cls: "spacer-1" });
    const cycleBtn = fieldContainer.createEl("button");
    (0, import_obsidian43.setIcon)(cycleBtn, FieldIcon["Cycle" /* Cycle */]);
    if (!((_a = attrs == null ? void 0 : attrs.options) == null ? void 0 : _a.alwaysOn)) {
      cycleBtn.hide();
      spacer.show();
      fieldContainer.onmouseover = () => {
        cycleBtn.show();
        spacer.hide();
      };
      fieldContainer.onmouseout = () => {
        cycleBtn.hide();
        spacer.show();
      };
    }
    const file = this.plugin.app.vault.getAbstractFileByPath(p.file.path);
    cycleBtn.onclick = async (e) => {
      var _a2;
      if (!(file instanceof import_obsidian43.TFile))
        return;
      const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, this.field.id);
      const value = (eF == null ? void 0 : eF.value) || "";
      const nextOption = this.nextOption(value);
      CycleField.replaceValues(this.plugin, file.path, this.field.id, nextOption);
      if (!((_a2 = attrs == null ? void 0 : attrs.options) == null ? void 0 : _a2.alwaysOn)) {
        cycleBtn.hide();
        spacer.show();
      }
    };
  }
};

// src/fields/fieldManagers/MultiField.ts
var import_obsidian45 = require("obsidian");

// src/modals/fields/MultiSelectModal.ts
var import_obsidian44 = require("obsidian");
var MultiSuggestModal = class extends BaseSelecttModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal, preSelectedOptions) {
    var _a, _b;
    super(plugin, file, field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.preSelectedOptions = preSelectedOptions;
    const initialOptions = ((_a = this.eF) == null ? void 0 : _a.value) || [];
    if (initialOptions) {
      if (Array.isArray(initialOptions)) {
        this.selectedOptions = initialOptions.map((item) => {
          const link = getLink(item, this.file);
          if (link) {
            return FileField.buildMarkDownLink(this.plugin, this.file, link.path);
          } else {
            return item.toString();
          }
        });
        this.selectedOptions = initialOptions.map((item) => item.toString());
      } else if (typeof initialOptions === "string" && initialOptions.toString().startsWith("[[")) {
        this.selectedOptions = initialOptions.split(",").map((item) => item.trim());
      } else {
        const link = getLink(initialOptions, this.file);
        if (link) {
          this.selectedOptions = [`[[${link.path.replace(".md", "")}]]`];
        } else if (typeof initialOptions === "string") {
          this.selectedOptions = initialOptions.toString().replace(/^\[(.*)\]$/, "$1").split(",").map((item) => item.trim());
        }
      }
    } else {
      this.selectedOptions = [];
    }
    (_b = this.preSelectedOptions) == null ? void 0 : _b.forEach((item) => {
      if (!this.selectedOptions.includes(item)) {
        this.selectedOptions.push(item);
      }
    });
    this.containerEl.onkeydown = async (e) => {
      if (e.key == "Enter" && e.altKey) {
        await this.replaceValues();
        this.close();
      }
    };
  }
  buildConfirm(footerActionsContainer) {
    const infoContainer = footerActionsContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    const confirmButton = new import_obsidian44.ButtonComponent(footerActionsContainer);
    confirmButton.setIcon("checkmark");
    confirmButton.onClick(async () => {
      await this.replaceValues();
      this.close();
    });
  }
  async onAdd() {
    await this.addNewValueToSettings();
    await this.plugin.fieldIndex.indexFields();
    this.selectedOptions.push(this.inputEl.value);
    const fM = new FieldManager[this.field.type](this.plugin, this.field);
    fM.createAndOpenFieldModal(this.file, this.field.name, this.eF, this.indexedPath, this.lineNumber, this.asList, this.asBlockquote, this.previousModal, this.selectedOptions);
    this.close(false);
  }
  async replaceValues() {
    const options2 = this.selectedOptions;
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: options2.join(", ") } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
    this.close();
  }
  renderSelected() {
    const chooser = this.chooser;
    const suggestions = chooser.suggestions;
    const values = chooser.values;
    suggestions.forEach((s, i) => {
      if (this.selectedOptions.includes(values[i].toString())) {
        s.addClass("value-checked");
        if (s.querySelectorAll(".icon-container").length == 0) {
          const iconContainer = s.createDiv({ cls: "icon-container" });
          (0, import_obsidian44.setIcon)(iconContainer, "check-circle");
        }
      } else {
        s.removeClass("value-checked");
        s.querySelectorAll(".icon-container").forEach((icon) => icon.remove());
      }
    });
  }
  renderSuggestion(value, el) {
    super.renderSuggestion(value, el);
    const spacer = this.containerEl.createDiv({ cls: "spacer" });
    el.appendChild(spacer);
    if (this.selectedOptions.includes(value.toString())) {
      el.addClass("value-checked");
      const iconContainer = el.createDiv({ cls: "icon-container" });
      (0, import_obsidian44.setIcon)(iconContainer, "check-circle");
    }
    this.inputEl.focus();
  }
  selectSuggestion(value, evt) {
    if (this.selectedOptions.includes(value.toString())) {
      this.selectedOptions.remove(value.toString());
    } else {
      this.selectedOptions.push(value.toString());
    }
    this.renderSelected();
  }
};

// src/fields/fieldManagers/MultiField.ts
var MultiField = class extends AbstractListBasedField {
  constructor(plugin, field) {
    super(plugin, field, "Multi" /* Multi */);
    this.valuesPromptComponents = [];
  }
  async buildAndOpenModal(file, indexedPath) {
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const modal = new MultiSuggestModal(this.plugin, file, this.field, eF, indexedPath);
    modal.titleEl.setText("Select values");
    modal.open();
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const action = async () => await this.buildAndOpenModal(file, indexedPath);
    if (MultiField.isSuggest(location)) {
      location.options.push({
        id: `update_${name}`,
        actionLabel: `<span>Update <b>${name}</b></span>`,
        action,
        icon: FieldIcon["Multi" /* Multi */]
      });
    } else if (MultiField.isFieldOptions(location)) {
      location.addOption(FieldIcon["Multi" /* Multi */], action, `Update ${name}'s value`);
    }
    ;
  }
  createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal, preSelectedOptions) {
    const fieldModal = new MultiSuggestModal(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal, preSelectedOptions);
    fieldModal.titleEl.setText(`Select options for ${selectedFieldName}`);
    fieldModal.open();
  }
  createDvField(dv, p, fieldContainer, attrs = {}) {
    var _a, _b;
    let valueHovered = false;
    let currentValues = [];
    if (p[this.field.name]) {
      if (Object.keys(p[this.field.name]).includes("path")) {
        currentValues = [`[[${p[this.field.name].path.replace(".md", "")}]]`];
      } else if (Array.isArray(p[this.field.name])) {
        p[this.field.name].forEach((item) => {
          if (Object.keys(item).includes("path")) {
            currentValues.push(`[[${item.path.replace(".md", "")}]]`);
          } else {
            currentValues.push(item.trim());
          }
        });
      } else {
        const value = p[this.field.name];
        currentValues = value ? `${value}`.split(",").map((v) => v.trim()) : [];
      }
    }
    const file = this.plugin.app.vault.getAbstractFileByPath(p["file"]["path"]);
    const valuesContainer = fieldContainer.createDiv({ cls: "values-container" });
    currentValues.forEach((v) => {
      const valueContainer = valuesContainer.createDiv({ cls: "item-container" });
      const valueRemoveBtn = valueContainer.createEl("button");
      const valueLabel = valueContainer.createDiv({ cls: "label", text: v });
      (0, import_obsidian45.setIcon)(valueRemoveBtn, "cross");
      valueRemoveBtn.hide();
      valueRemoveBtn.onclick = async () => {
        const remainingValues = currentValues.filter((cV) => cV !== v).join(", ");
        MultiField.replaceValues(this.plugin, p.file.path, this.field.id, remainingValues);
      };
      valueContainer.onmouseover = () => {
        valueHovered = true;
        doubleSpacer.hide();
        singleSpacer.hide();
        valueRemoveBtn.show();
        valueLabel.addClass("hovered");
      };
      valueContainer.onmouseout = () => {
        valueHovered = false;
        valueRemoveBtn.hide();
        singleSpacer.show();
        doubleSpacer.hide();
        valueLabel.removeClass("hovered");
      };
    });
    const addBtn = valuesContainer.createEl("button");
    (0, import_obsidian45.setIcon)(addBtn, "list-plus");
    let fieldModal;
    if (file instanceof import_obsidian45.TFile && file.extension == "md") {
      addBtn.onclick = async () => await this.buildAndOpenModal(file);
    } else {
      addBtn.onclick = () => {
      };
    }
    const singleSpacer = valuesContainer.createDiv({ cls: "spacer-1" });
    const doubleSpacer = valuesContainer.createDiv({ cls: "spacer-2" });
    if (!((_a = attrs == null ? void 0 : attrs.options) == null ? void 0 : _a.alwaysOn)) {
      addBtn.hide();
      fieldContainer.onmouseover = () => {
        addBtn.show();
        doubleSpacer.hide();
        if (!valueHovered)
          singleSpacer.show();
      };
      fieldContainer.onmouseout = () => {
        addBtn.hide();
        singleSpacer.hide();
        doubleSpacer.show();
      };
    }
    if (!((_b = attrs == null ? void 0 : attrs.options) == null ? void 0 : _b.alwaysOn)) {
      singleSpacer.hide();
      doubleSpacer.show();
      addBtn.hide();
    } else {
      singleSpacer.show();
      doubleSpacer.hide();
      addBtn.show();
    }
  }
};

// src/fields/fieldManagers/DateField.ts
var import_obsidian48 = require("obsidian");

// src/modals/fields/DateModal.ts
var import_obsidian46 = require("obsidian");
var import_obsidian47 = require("obsidian");

// node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

// node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth) {
    var s = nth % 100;
    if (s > 3 && s < 21)
      return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var default_default = english;

// node_modules/flatpickr/dist/esm/utils/index.js
var pad = function(number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce4(fn2, wait) {
  var t;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t);
    t = setTimeout(function() {
      return fn2.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};

// node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e.className = className;
  if (content !== void 0)
    e.textContent = content;
  return e;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}

// node_modules/flatpickr/dist/esm/utils/formatting.js
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function(_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function(_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date) {
    return date.toISOString();
  },
  D: function(date, locale, options2) {
    return locale.weekdays.shorthand[formats.w(date, locale, options2)];
  },
  F: function(date, locale, options2) {
    return monthToStr(formats.n(date, locale, options2) - 1, false, locale);
  },
  G: function(date, locale, options2) {
    return pad(formats.h(date, locale, options2));
  },
  H: function(date) {
    return pad(date.getHours());
  },
  J: function(date, locale) {
    return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: function(date, locale) {
    return locale.amPM[int(date.getHours() > 11)];
  },
  M: function(date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: function(date) {
    return pad(date.getSeconds());
  },
  U: function(date) {
    return date.getTime() / 1e3;
  },
  W: function(date, _, options2) {
    return options2.getWeek(date);
  },
  Y: function(date) {
    return pad(date.getFullYear(), 4);
  },
  d: function(date) {
    return pad(date.getDate());
  },
  h: function(date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function(date) {
    return pad(date.getMinutes());
  },
  j: function(date) {
    return date.getDate();
  },
  l: function(date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: function(date) {
    return pad(date.getMonth() + 1);
  },
  n: function(date) {
    return date.getMonth() + 1;
  },
  s: function(date) {
    return date.getSeconds();
  },
  u: function(date) {
    return date.getTime();
  },
  w: function(date) {
    return date.getDay();
  },
  y: function(date) {
    return String(date.getFullYear()).substring(2);
  }
};

// node_modules/flatpickr/dist/esm/utils/dates.js
var createDateFormatter = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function(c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
  return function(date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date)
      return void 0;
    var locale = customLocale || l10n;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date)
      parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0)
      parsedDate = new Date(date);
    else if (typeof date === "string") {
      var format = givenFormat || (config || defaults).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0, ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
          var token = format[i];
          var isBackSlash = token === "\\";
          var escaped = format[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match = new RegExp(regexStr).exec(date);
            if (match && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
        ops.forEach(function(_a2) {
          var fn2 = _a2.fn, val = _a2.val;
          return parsedDate = fn2(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== void 0) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
      seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== void 0) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr)
      minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes)
      seconds = config.maxDate.getSeconds();
  }
  return { hours, minutes, seconds };
}

// node_modules/flatpickr/dist/esm/utils/polyfills.js
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}

// node_modules/flatpickr/dist/esm/index.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self = {
    config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
    l10n: default_default
  };
  self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
  self._handlers = [];
  self.pluginElements = [];
  self.loadedPlugins = [];
  self._bind = bind;
  self._setHoursFromDate = setHoursFromDate;
  self._positionCalendar = positionCalendar;
  self.changeMonth = changeMonth;
  self.changeYear = changeYear;
  self.clear = clear;
  self.close = close;
  self.onMouseOver = onMouseOver;
  self._createElement = createElement;
  self.createDay = createDay;
  self.destroy = destroy;
  self.isEnabled = isEnabled;
  self.jumpToDate = jumpToDate;
  self.updateValue = updateValue;
  self.open = open;
  self.redraw = redraw;
  self.set = set2;
  self.setDate = setDate;
  self.toggle = toggle;
  function setupHelperFunctions() {
    self.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self.currentMonth;
        }
        if (yr === void 0) {
          yr = self.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self.element = self.input = element;
    self.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self.isMobile)
      build();
    bindEvents();
    if (self.selectedDates.length || self.config.noCalendar) {
      if (self.config.enableTime) {
        setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn2) {
    return fn2.bind(self);
  }
  function setCalendarWidth() {
    var config = self.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self.calendarContainer !== void 0) {
          self.calendarContainer.style.visibility = "hidden";
          self.calendarContainer.style.display = "block";
        }
        if (self.daysContainer !== void 0) {
          var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
          self.daysContainer.style.width = daysWidth + "px";
          self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== void 0 ? self.weekWrapper.offsetWidth : 0) + "px";
          self.calendarContainer.style.removeProperty("visibility");
          self.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self.selectedDates.length === 0) {
      var defaultDate = self.config.minDate === void 0 || compareDates(new Date(), self.config.minDate) >= 0 ? new Date() : new Date(self.config.minDate.getTime());
      var defaults2 = getDefaultHours(self.config);
      defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
      self.selectedDates = [defaultDate];
      self.latestSelectedDateObj = defaultDate;
    }
    if (e !== void 0 && e.type !== "blur") {
      timeWrapper(e);
    }
    var prevValue = self._input.value;
    setHoursFromInputs();
    updateValue();
    if (self._input.value !== prevValue) {
      self._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self.hourElement === void 0 || self.minuteElement === void 0)
      return;
    var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== void 0 ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
    if (self.amPM !== void 0) {
      hours = ampm2military(hours, self.amPM.textContent);
    }
    var limitMinHours = self.config.minTime !== void 0 || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
    var limitMaxHours = self.config.maxTime !== void 0 || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;
    if (self.config.maxTime !== void 0 && self.config.minTime !== void 0 && self.config.minTime > self.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self.config.minTime.getHours(), self.config.minTime.getMinutes(), self.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self.config.maxTime.getHours(), self.config.maxTime.getMinutes(), self.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self.config.maxTime !== void 0 ? self.config.maxTime : self.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours())
          minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes())
          seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self.config.minTime !== void 0 ? self.config.minTime : self.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes())
          minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes())
          seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self.latestSelectedDateObj !== void 0) {
      self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self.hourElement || !self.minuteElement || self.isMobile)
      return;
    self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self.minuteElement.value = pad(minutes);
    if (self.amPM !== void 0)
      self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
    if (self.secondElement !== void 0)
      self.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element2, event, handler, options2) {
    if (event instanceof Array)
      return event.forEach(function(ev) {
        return bind(element2, ev, handler, options2);
      });
    if (element2 instanceof Array)
      return element2.forEach(function(el) {
        return bind(el, event, handler, options2);
      });
    element2.addEventListener(event, handler, options2);
    self._handlers.push({
      remove: function() {
        return element2.removeEventListener(event, handler, options2);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind(el, "click", self[evt]);
        });
      });
    }
    if (self.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce4(onResize, 50);
    self._debouncedChange = debounce4(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind(self.daysContainer, "mouseover", function(e) {
        if (self.config.mode === "range")
          onMouseOver(getEventTarget(e));
      });
    bind(self._input, "keydown", onKeyDown);
    if (self.calendarContainer !== void 0) {
      bind(self.calendarContainer, "keydown", onKeyDown);
    }
    if (!self.config.inline && !self.config.static)
      bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind(window.document, "touchstart", documentClick);
    else
      bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, { capture: true });
    if (self.config.clickOpens === true) {
      bind(self._input, "focus", self.open);
      bind(self._input, "click", self.open);
    }
    if (self.daysContainer !== void 0) {
      bind(self.monthNav, "click", onMonthNavClick);
      bind(self.monthNav, ["keyup", "increment"], onYearInput);
      bind(self.daysContainer, "click", selectDate);
    }
    if (self.timeContainer !== void 0 && self.minuteElement !== void 0 && self.hourElement !== void 0) {
      var selText = function(e) {
        return getEventTarget(e).select();
      };
      bind(self.timeContainer, ["increment"], updateTime);
      bind(self.timeContainer, "blur", updateTime, { capture: true });
      bind(self.timeContainer, "click", timeIncrement);
      bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
      if (self.secondElement !== void 0)
        bind(self.secondElement, "focus", function() {
          return self.secondElement && self.secondElement.select();
        });
      if (self.amPM !== void 0) {
        bind(self.amPM, "click", function(e) {
          updateTime(e);
        });
      }
    }
    if (self.config.allowInput) {
      bind(self._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
    var oldYear = self.currentYear;
    var oldMonth = self.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self.currentYear = jumpTo.getFullYear();
        self.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self.config.errorHandler(e);
    }
    if (triggerChange2 && self.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self.redraw();
  }
  function timeIncrement(e) {
    var eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    var target = e && getEventTarget(e);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self.calendarContainer = createElement("div", "flatpickr-calendar");
    self.calendarContainer.tabIndex = -1;
    if (!self.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self.config.weekNumbers) {
        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
        self.innerContainer.appendChild(weekWrapper);
        self.weekNumbers = weekNumbers;
        self.weekWrapper = weekWrapper;
      }
      self.rContainer = createElement("div", "flatpickr-rContainer");
      self.rContainer.appendChild(buildWeekdays());
      if (!self.daysContainer) {
        self.daysContainer = createElement("div", "flatpickr-days");
        self.daysContainer.tabIndex = -1;
      }
      buildDays();
      self.rContainer.appendChild(self.daysContainer);
      self.innerContainer.appendChild(self.rContainer);
      fragment.appendChild(self.innerContainer);
    }
    if (self.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
    toggleClass(self.calendarContainer, "animate", self.config.animate === true);
    toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
    self.calendarContainer.appendChild(fragment);
    var customAppend = self.config.appendTo !== void 0 && self.config.appendTo.nodeType !== void 0;
    if (self.config.inline || self.config.static) {
      self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
      if (self.config.inline) {
        if (!customAppend && self.element.parentNode)
          self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
        else if (self.config.appendTo !== void 0)
          self.config.appendTo.appendChild(self.calendarContainer);
      }
      if (self.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self.element.parentNode)
          self.element.parentNode.insertBefore(wrapper, self.element);
        wrapper.appendChild(self.element);
        if (self.altInput)
          wrapper.appendChild(self.altInput);
        wrapper.appendChild(self.calendarContainer);
      }
    }
    if (!self.config.static && !self.config.inline)
      (self.config.appendTo !== void 0 ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
      self.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self.selectedDateElem = dayElement;
        if (self.config.mode === "range") {
          toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date))
        dayElement.classList.add("inRange");
    }
    if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
      var month = self.daysContainer.children[m];
      var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset2) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement : self.selectedDateElem !== void 0 && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== void 0 && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset2);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self.daysContainer === void 0) {
      return;
    }
    clearNode(self.daysContainer);
    if (self.weekNumbers)
      clearNode(self.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self.config.showMonths; i++) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self.daysContainer.appendChild(frag);
    self.days = self.daysContainer.firstChild;
    if (self.config.mode === "range" && self.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self.config.minDate !== void 0 && self.currentYear === self.config.minDate.getFullYear() && month2 < self.config.minDate.getMonth()) {
        return false;
      }
      return !(self.config.maxDate !== void 0 && self.currentYear === self.config.maxDate.getFullYear() && month2 > self.config.maxDate.getMonth());
    };
    self.monthsDropdownContainer.tabIndex = -1;
    self.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i))
        continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
      month.tabIndex = -1;
      if (self.currentMonth === i) {
        month.selected = true;
      }
      self.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
      bind(self.monthsDropdownContainer, "change", function(e) {
        var target = getEventTarget(e);
        var selectedMonth = parseInt(target.value, 10);
        self.changeMonth(selectedMonth - self.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
    if (self.config.minDate) {
      yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
    }
    if (self.config.maxDate) {
      yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self.monthNav);
    self.monthNav.appendChild(self.prevMonthNav);
    if (self.config.showMonths) {
      self.yearElements = [];
      self.monthElements = [];
    }
    for (var m = self.config.showMonths; m--; ) {
      var month = buildMonth();
      self.yearElements.push(month.yearElement);
      self.monthElements.push(month.monthElement);
      self.monthNav.appendChild(month.container);
    }
    self.monthNav.appendChild(self.nextMonthNav);
  }
  function buildMonthNav() {
    self.monthNav = createElement("div", "flatpickr-months");
    self.yearElements = [];
    self.monthElements = [];
    self.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self.prevMonthNav.innerHTML = self.config.prevArrow;
    self.nextMonthNav = createElement("span", "flatpickr-next-month");
    self.nextMonthNav.innerHTML = self.config.nextArrow;
    buildMonths();
    Object.defineProperty(self, "_hidePrevMonthArrow", {
      get: function() {
        return self.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self.__hidePrevMonthArrow !== bool) {
          toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
          self.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self, "_hideNextMonthArrow", {
      get: function() {
        return self.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self.__hideNextMonthArrow !== bool) {
          toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
          self.__hideNextMonthArrow = bool;
        }
      }
    });
    self.currentYearElement = self.yearElements[0];
    updateNavigationCurrentMonth();
    return self.monthNav;
  }
  function buildTime() {
    self.calendarContainer.classList.add("hasTime");
    if (self.config.noCalendar)
      self.calendarContainer.classList.add("noCalendar");
    var defaults2 = getDefaultHours(self.config);
    self.timeContainer = createElement("div", "flatpickr-time");
    self.timeContainer.tabIndex = -1;
    var separator2 = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self.l10n.hourAriaLabel
    });
    self.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self.l10n.minuteAriaLabel
    });
    self.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
    self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
    self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : defaults2.minutes);
    self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
    self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
    self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
    self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
    self.hourElement.setAttribute("maxlength", "2");
    self.minuteElement.setAttribute("min", "0");
    self.minuteElement.setAttribute("max", "59");
    self.minuteElement.setAttribute("maxlength", "2");
    self.timeContainer.appendChild(hourInput);
    self.timeContainer.appendChild(separator2);
    self.timeContainer.appendChild(minuteInput);
    if (self.config.time_24hr)
      self.timeContainer.classList.add("time24hr");
    if (self.config.enableSeconds) {
      self.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self.secondElement = secondInput.getElementsByTagName("input")[0];
      self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : defaults2.seconds);
      self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
      self.secondElement.setAttribute("min", "0");
      self.secondElement.setAttribute("max", "59");
      self.secondElement.setAttribute("maxlength", "2");
      self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self.timeContainer.appendChild(secondInput);
    }
    if (!self.config.time_24hr) {
      self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
      self.amPM.title = self.l10n.toggleTitle;
      self.amPM.tabIndex = -1;
      self.timeContainer.appendChild(self.amPM);
    }
    return self.timeContainer;
  }
  function buildWeekdays() {
    if (!self.weekdayContainer)
      self.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self.weekdayContainer);
    for (var i = self.config.showMonths; i--; ) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i = self.config.showMonths; i--; ) {
      self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self.currentMonth;
    if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true)
      return;
    self.currentMonth += delta;
    if (self.currentMonth < 0 || self.currentMonth > 11) {
      self.currentYear += self.currentMonth > 11 ? 1 : -1;
      self.currentMonth = (self.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self.input.value = "";
    if (self.altInput !== void 0)
      self.altInput.value = "";
    if (self.mobileInput !== void 0)
      self.mobileInput.value = "";
    self.selectedDates = [];
    self.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self.currentYear = self._initialDate.getFullYear();
      self.currentMonth = self._initialDate.getMonth();
    }
    if (self.config.enableTime === true) {
      var _a = getDefaultHours(self.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
      setHours(hours, minutes, seconds);
    }
    self.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self.isOpen = false;
    if (!self.isMobile) {
      if (self.calendarContainer !== void 0) {
        self.calendarContainer.classList.remove("open");
      }
      if (self._input !== void 0) {
        self._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self.config !== void 0)
      triggerEvent("onDestroy");
    for (var i = self._handlers.length; i--; ) {
      self._handlers[i].remove();
    }
    self._handlers = [];
    if (self.mobileInput) {
      if (self.mobileInput.parentNode)
        self.mobileInput.parentNode.removeChild(self.mobileInput);
      self.mobileInput = void 0;
    } else if (self.calendarContainer && self.calendarContainer.parentNode) {
      if (self.config.static && self.calendarContainer.parentNode) {
        var wrapper = self.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self.calendarContainer.parentNode.removeChild(self.calendarContainer);
    }
    if (self.altInput) {
      self.input.type = "text";
      if (self.altInput.parentNode)
        self.altInput.parentNode.removeChild(self.altInput);
      delete self.altInput;
    }
    if (self.input) {
      self.input.type = self.input._type;
      self.input.classList.remove("flatpickr-input");
      self.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k) {
      try {
        delete self[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self.isOpen && !self.config.inline) {
      var eventTarget_1 = getEventTarget(e);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      var isIgnored = !self.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self.config.allowInput) {
          self.setDate(self._input.value, false, self.config.altInput ? self.config.altFormat : self.config.dateFormat);
        }
        if (self.timeContainer !== void 0 && self.minuteElement !== void 0 && self.hourElement !== void 0 && self.input.value !== "" && self.input.value !== void 0) {
          updateTime();
        }
        self.close();
        if (self.config && self.config.mode === "range" && self.selectedDates.length === 1)
          self.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
    self.currentYear = newYearNum || self.currentYear;
    if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
      self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
    } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
      self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
    }
    if (isNewYear) {
      self.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self.parseDate(date, void 0, timeless);
    if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== void 0 ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== void 0 ? timeless : !self.maxDateHasTime) > 0)
      return false;
    if (!self.config.enable && self.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self.config.enable, array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
    for (var i = 0, d = void 0; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        var parsed = self.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    var isInput = e.target === self._input;
    var valueChanged = self._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    var eventTarget = getEventTarget(e);
    var isInput = self.config.wrap ? element.contains(eventTarget) : eventTarget === self._input;
    var allowInput = self.config.allowInput;
    var allowKeydown = self.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
        self.close();
        return eventTarget.blur();
      } else {
        self.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self.config.allowInput) {
            e.preventDefault();
            self.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self.hourElement)
            self.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          var delta = e.keyCode === 40 ? 1 : -1;
          if (self.daysContainer && eventTarget.$i !== void 0 || eventTarget === self.input || eventTarget === self.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self.currentYearElement) {
            changeYear(self.currentYear - delta);
          } else if (self.config.enableTime) {
            if (!isTimeObj && self.hourElement)
              self.hourElement.focus();
            updateTime(e);
            self._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self.hourElement,
              self.minuteElement,
              self.secondElement,
              self.amPM
            ].concat(self.pluginElements).filter(function(x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self._input).focus();
            }
          } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self.amPM !== void 0 && eventTarget === self.amPM) {
      switch (e.key) {
        case self.l10n.amPM[0].charAt(0):
        case self.l10n.amPM[0].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self.l10n.amPM[1].charAt(0):
        case self.l10n.amPM[1].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
      if (!isEnabled(new Date(t), true)) {
        containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
        if (t < initialDate && (!minRange || t > minRange))
          minRange = t;
        else if (t > initialDate && (!maxRange || t < maxRange))
          maxRange = t;
      }
    }
    var hoverableCells = Array.from(self.rContainer.querySelectorAll("*:nth-child(-n+" + self.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date = dayElem.dateObj;
      var timestamp2 = date.getTime();
      var outOfRange = minRange > 0 && timestamp2 < minRange || maxRange > 0 && timestamp2 > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
        dayElem.classList.remove(c);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp2 === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp2 === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp2 >= minRange && (maxRange === 0 || timestamp2 <= maxRange) && isBetween(timestamp2, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self.isOpen && !self.config.static && !self.config.inline)
      positionCalendar();
  }
  function open(e, positionElement) {
    if (positionElement === void 0) {
      positionElement = self._positionElement;
    }
    if (self.isMobile === true) {
      if (e) {
        e.preventDefault();
        var eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self.mobileInput !== void 0) {
        self.mobileInput.focus();
        self.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self._input.disabled || self.config.inline) {
      return;
    }
    var wasOpen = self.isOpen;
    self.isOpen = true;
    if (!wasOpen) {
      self.calendarContainer.classList.add("open");
      self._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self.config.enableTime === true && self.config.noCalendar === true) {
      if (self.config.allowInput === false && (e === void 0 || !self.timeContainer.contains(e.relatedTarget))) {
        setTimeout(function() {
          return self.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date) {
      var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
      var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self.selectedDates) {
        self.selectedDates = self.selectedDates.filter(function(d) {
          return isEnabled(d);
        });
        if (!self.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self.currentYearElement.removeAttribute(type);
        self.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats2 = {};
    self.config.parseDate = userConfig.parseDate;
    self.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self.config, "enable", {
      get: function() {
        return self.config._enable;
      },
      set: function(dates) {
        self.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self.config, "disable", {
      get: function() {
        return self.config._disable;
      },
      set: function(dates) {
        self.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self.config, "minDate", {
      get: function() {
        return self.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self.config, "maxDate", {
      get: function() {
        return self.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self.config, "minTime", {
      get: function() {
        return self.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self.config, "maxTime", {
      get: function() {
        return self.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self.config.noCalendar = true;
      self.config.enableTime = true;
    }
    Object.assign(self.config, formats2, userConfig);
    for (var i = 0; i < boolOpts.length; i++)
      self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
    HOOKS.filter(function(hook) {
      return self.config[hook] !== void 0;
    }).forEach(function(hook) {
      self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
    });
    self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self.config.plugins.length; i++) {
      var pluginConf = self.config.plugins[i](self) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined")
      self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
    self.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : void 0);
    tokenRegex.D = "(" + self.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self.config.time_24hr = self.l10n.time_24hr;
    }
    self.formatDate = createDateFormatter(self);
    self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self.config.position === "function") {
      return void self.config.position(self, customPositionElement);
    }
    if (self.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top2 = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
    if (self.config.inline)
      return;
    var left2 = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left2 -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left2 -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self.calendarContainer, "arrowRight", isRight);
    var right2 = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left2 + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right2 + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self.calendarContainer, "rightMost", rightMost);
    if (self.config.static)
      return;
    self.calendarContainer.style.top = top2 + "px";
    if (!rightMost) {
      self.calendarContainer.style.left = left2 + "px";
      self.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self.calendarContainer.style.left = "auto";
      self.calendarContainer.style.right = right2 + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass(self.calendarContainer, "rightMost", false);
      toggleClass(self.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self.calendarContainer.style.left = centerLeft + "px";
      self.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self.config.noCalendar || self.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self.close, 0);
    } else {
      self.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t = findParent(getEventTarget(e), isSelectable);
    if (t === void 0)
      return;
    var target = t;
    var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
    self.selectedDateElem = target;
    if (self.config.mode === "single")
      self.selectedDates = [selectedDate];
    else if (self.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self.selectedDates.push(selectedDate);
    } else if (self.config.mode === "range") {
      if (self.selectedDates.length === 2) {
        self.clear(false, false);
      }
      self.latestSelectedDateObj = selectedDate;
      self.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
        self.selectedDates.sort(function(a, b) {
          return a.getTime() - b.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self.currentYear !== selectedDate.getFullYear();
      self.currentYear = selectedDate.getFullYear();
      self.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self.selectedDateElem !== void 0 && self.hourElement === void 0) {
      self.selectedDateElem && self.selectedDateElem.focus();
    }
    if (self.hourElement !== void 0)
      self.hourElement !== void 0 && self.hourElement.focus();
    if (self.config.closeOnSelect) {
      var single = self.config.mode === "single" && !self.config.enableTime;
      var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;
      if (single || range) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self.config.clickOpens === true) {
          bind(self._input, "focus", self.open);
          bind(self._input, "click", self.open);
        } else {
          self._input.removeEventListener("focus", self.open);
          self._input.removeEventListener("click", self.open);
        }
      }
    ]
  };
  function set2(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x) {
            return x();
          });
      }
    } else {
      self.config[option] = value;
      if (CALLBACKS[option] !== void 0)
        CALLBACKS[option].forEach(function(x) {
          return x();
        });
      else if (HOOKS.indexOf(option) > -1)
        self.config[option] = arrayify(value);
    }
    self.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map(function(d) {
        return self.parseDate(d, format);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self.parseDate(inputDate, format)];
    else if (typeof inputDate === "string") {
      switch (self.config.mode) {
        case "single":
        case "time":
          dates = [self.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self.config.conjunction).map(function(date) {
            return self.parseDate(date, format);
          });
          break;
        case "range":
          dates = inputDate.split(self.l10n.rangeSeparator).map(function(date) {
            return self.parseDate(date, format);
          });
          break;
        default:
          break;
      }
    } else
      self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter(function(d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self.config.mode === "range")
      self.selectedDates.sort(function(a, b) {
        return a.getTime() - b.getTime();
      });
  }
  function setDate(date, triggerChange2, format) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format === void 0) {
      format = self.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0)
      return self.clear(triggerChange2);
    setSelectedDate(date, format);
    self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
    self.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self.selectedDates.length === 0) {
      self.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self.parseDate(rule.from, void 0),
          to: self.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x) {
      return x;
    });
  }
  function setupDates() {
    self.selectedDates = [];
    self.now = self.parseDate(self.config.now) || new Date();
    var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self.config.dateFormat);
    self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
    self.currentYear = self._initialDate.getFullYear();
    self.currentMonth = self._initialDate.getMonth();
    if (self.selectedDates.length > 0)
      self.latestSelectedDateObj = self.selectedDates[0];
    if (self.config.minTime !== void 0)
      self.config.minTime = self.parseDate(self.config.minTime, "H:i");
    if (self.config.maxTime !== void 0)
      self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
    self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
    self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self.input = getInputElem();
    if (!self.input) {
      self.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self.input._type = self.input.type;
    self.input.type = "text";
    self.input.classList.add("flatpickr-input");
    self._input = self.input;
    if (self.config.altInput) {
      self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
      self._input = self.altInput;
      self.altInput.placeholder = self.input.placeholder;
      self.altInput.disabled = self.input.disabled;
      self.altInput.required = self.input.required;
      self.altInput.tabIndex = self.input.tabIndex;
      self.altInput.type = "text";
      self.input.setAttribute("type", "hidden");
      if (!self.config.static && self.input.parentNode)
        self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
    }
    if (!self.config.allowInput)
      self._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self._positionElement = self.config.positionElement || self._input;
  }
  function setupMobile() {
    var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
    self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
    self.mobileInput.tabIndex = 1;
    self.mobileInput.type = inputType;
    self.mobileInput.disabled = self.input.disabled;
    self.mobileInput.required = self.input.required;
    self.mobileInput.placeholder = self.input.placeholder;
    self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self.selectedDates.length > 0) {
      self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
    }
    if (self.config.minDate)
      self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
    if (self.config.maxDate)
      self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
    if (self.input.getAttribute("step"))
      self.mobileInput.step = String(self.input.getAttribute("step"));
    self.input.type = "hidden";
    if (self.altInput !== void 0)
      self.altInput.type = "hidden";
    try {
      if (self.input.parentNode)
        self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
    } catch (_a) {
    }
    bind(self.mobileInput, "change", function(e) {
      self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self.isOpen === true)
      return self.close();
    self.open(e);
  }
  function triggerEvent(event, data) {
    if (self.config === void 0)
      return;
    var hooks = self.config[event];
    if (hooks !== void 0 && hooks.length > 0) {
      for (var i = 0; hooks[i] && i < hooks.length; i++)
        hooks[i](self.selectedDates, self.input.value, self, data);
    }
    if (event === "onChange") {
      self.input.dispatchEvent(createEvent("change"));
      self.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date) {
    for (var i = 0; i < self.selectedDates.length; i++) {
      var selectedDate = self.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
        return "" + i;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self.config.mode !== "range" || self.selectedDates.length < 2)
      return false;
    return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self.config.noCalendar || self.isMobile || !self.monthNav)
      return;
    self.yearElements.forEach(function(yearElement, i) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
        self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
      } else {
        self.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self._hidePrevMonthArrow = self.config.minDate !== void 0 && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
    self._hideNextMonthArrow = self.config.maxDate !== void 0 && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self.config.altInput ? self.config.altFormat : self.config.dateFormat);
    return self.selectedDates.map(function(dObj) {
      return self.formatDate(dObj, format);
    }).filter(function(d, i, arr) {
      return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
    }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self.mobileInput !== void 0 && self.mobileFormatStr) {
      self.mobileInput.value = self.latestSelectedDateObj !== void 0 ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
    }
    self.input.value = getDateStr(self.config.dateFormat);
    if (self.altInput !== void 0) {
      self.altInput.value = getDateStr(self.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    var eventTarget = getEventTarget(e);
    var isPrevMonth = self.prevMonthNav.contains(eventTarget);
    var isNextMonth = self.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self.changeYear(self.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self.changeYear(self.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    var isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
    if (self.amPM !== void 0 && eventTarget === self.amPM) {
      self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
    }
    var min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
      if (newValue < min2) {
        newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self.hourElement);
      } else if (newValue > max2) {
        newValue = input === self.hourElement ? newValue - max2 - int(!self.amPM) : min2;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self.hourElement);
      }
      if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function(config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function(selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, default_default),
  default: __assign({}, default_default)
};
flatpickr.localize = function(l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var esm_default = flatpickr;

// src/modals/fields/DateModal.ts
var DateModal = class extends BaseModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    var _a, _b;
    super(plugin, file, previousModal);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.pathTemplateItems = {};
    this.pushNextInterval = false;
    const initialValue = ((_a = this.eF) == null ? void 0 : _a.value) || "";
    this.initialValue = initialValue ? ((_b = initialValue.toString().replace(/^\[\[/g, "").replace(/\]\]$/g, "").split("|").first()) == null ? void 0 : _b.split("/").last()) || "" : "";
    this.insertAsLink = FieldManager2.stringToBoolean(this.field.options.defaultInsertAsLink || "false") || false;
    this.format = this.field.options.dateFormat || this.field.options.defaultDateFormat;
    this.dateManager = new FieldManager[this.field.type](this.plugin, this.field);
    this.value = this.initialValue;
  }
  async onOpen() {
    super.onOpen();
    this.containerEl.addClass("metadata-menu");
    cleanActions(this.contentEl, ".field-container");
    cleanActions(this.contentEl, ".field-error");
    const fieldContainer = this.contentEl.createDiv({ cls: "field-container" });
    await this.buildFields(fieldContainer);
    this.errorField = this.contentEl.createEl("div", { cls: "field-error" });
    this.errorField.hide();
  }
  buildPath(value) {
    let renderedPath = this.field.options.linkPath || "";
    const templatePathRegex = new RegExp(`\\{\\{(?<pattern>[^\\}]+?)\\}\\}`, "gu");
    const tP = renderedPath.matchAll(templatePathRegex);
    let next = tP.next();
    while (!next.done) {
      if (next.value.groups) {
        const pattern = next.value.groups.pattern;
        this.pathTemplateItems[pattern] = (0, import_obsidian47.moment)(value).format(pattern);
      }
      next = tP.next();
    }
    Object.keys(this.pathTemplateItems).forEach((k) => {
      const fieldRegex = new RegExp(`\\{\\{${k}(:[^\\}]*)?\\}\\}`, "u");
      renderedPath = renderedPath.replace(fieldRegex, this.pathTemplateItems[k]);
    });
    return renderedPath;
  }
  async save() {
    let newValue;
    if (this.plugin.app.plugins.enabledPlugins.has("nldates-obsidian")) {
      try {
        const nldates = this.plugin.app.plugins.plugins["nldates-obsidian"];
        const parsedDate = nldates.parseDate(`${this.value}`);
        newValue = parsedDate.date ? parsedDate.moment : (0, import_obsidian47.moment)(`${this.value}`, this.format);
      } catch (error) {
        newValue = (0, import_obsidian47.moment)(`${this.value}`, this.format);
      }
    } else {
      newValue = (0, import_obsidian47.moment)(`${this.value}`, this.format);
    }
    if (newValue.isValid()) {
      const renderedPath = this.buildPath(newValue);
      const linkPath = this.plugin.app.metadataCache.getFirstLinkpathDest(renderedPath || "" + newValue.format(this.format), this.file.path);
      const formattedValue = this.insertAsLink ? `[[${renderedPath || ""}${newValue.format(this.format)}${linkPath ? "|" + linkPath.basename : ""}]]` : newValue.format(this.format);
      await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: formattedValue } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
      this.saved = true;
      if (this.previousModal)
        await this.goToPreviousModal();
      if (this.nextIntervalField && this.pushNextInterval && this.nextShift) {
        await postValues(this.plugin, [{ id: this.nextIntervalField.id, payload: { value: this.nextShift } }], this.file.path);
        this.close();
      }
      this.close();
    } else if (!this.value) {
      await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: "" } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
      this.saved = true;
      if (this.previousModal)
        await this.goToPreviousModal();
      this.close();
    } else {
      this.errorField.show();
      this.errorField.setText(`value must be a valid date`);
      this.inputEl.inputEl.addClass("is-invalid");
      return;
    }
  }
  async buildFields(dateFieldsContainer) {
    await this.buildInputEl(dateFieldsContainer);
    this.buildInsertAsLinkButton(dateFieldsContainer);
    this.buildClearBtn(dateFieldsContainer);
    this.buildSimpleSaveBtn(dateFieldsContainer);
  }
  buildInsertAsLinkButton(container) {
    const insertAsLinkBtn = new import_obsidian46.ButtonComponent(container);
    const setLinkBtnIcon = () => {
      insertAsLinkBtn.setIcon(this.insertAsLink ? "link" : "unlink");
      insertAsLinkBtn.setTooltip(
        this.insertAsLink ? "Click to insert date as text" : "Click to insert date as link"
      );
    };
    setLinkBtnIcon();
    insertAsLinkBtn.onClick(() => {
      this.insertAsLink = !this.insertAsLink;
      setLinkBtnIcon();
    });
  }
  buildClearBtn(container) {
    const clearBtn = new import_obsidian46.ButtonComponent(container);
    clearBtn.setIcon("eraser");
    clearBtn.setTooltip(`Clear ${this.field.name}'s date`);
    clearBtn.onClick(() => {
      this.value = "";
      this.inputEl.setPlaceholder("");
    });
  }
  toggleButton(button, value) {
    button.setDisabled(!!value);
    if (value) {
      button.buttonEl.addClass("disabled");
    } else {
      button.buttonEl.removeClass("disabled");
    }
  }
  async buildInputEl(container) {
    [this.currentShift, this.nextIntervalField, this.nextShift] = await this.dateManager.shiftDuration(this.file);
    this.inputEl = new import_obsidian46.TextComponent(container);
    this.inputEl.inputEl.focus();
    this.inputEl.setPlaceholder(
      this.initialValue ? (0, import_obsidian47.moment)(this.initialValue, this.field.options.dateFormat).format(this.field.options.dateFormat) : ""
    );
    this.inputEl.onChange((value) => {
      this.inputEl.inputEl.removeClass("is-invalid");
      this.errorField.hide();
      this.errorField.setText("");
      this.value = value;
      this.toggleButton(shiftFromTodayBtn, value);
    });
    const calendarDisplayBtn = new import_obsidian46.ButtonComponent(container);
    calendarDisplayBtn.setIcon(FieldIcon["Date" /* Date */]);
    calendarDisplayBtn.setTooltip("open date picker");
    const shiftFromTodayBtn = new import_obsidian46.ButtonComponent(container);
    shiftFromTodayBtn.setIcon("skip-forward");
    shiftFromTodayBtn.setTooltip(`Shift ${this.field.name} ${this.currentShift || "1 day"} ahead`);
    const datePickerContainer = container.createDiv();
    const datePicker = esm_default(datePickerContainer, {
      locale: {
        firstDayOfWeek: this.plugin.settings.firstDayOfWeek
      },
      defaultDate: (0, import_obsidian47.moment)(Date.now()).format("YYYY-MM-DD")
    });
    datePicker.config.onChange.push((value) => {
      const newDate = (0, import_obsidian47.moment)(value.toString()).format(this.format);
      this.inputEl.setValue(newDate);
      this.value = newDate;
      this.toggleButton(shiftFromTodayBtn, this.value);
    });
    calendarDisplayBtn.onClick((e) => {
      e.preventDefault();
      datePicker.setDate(datePicker.parseDate(this.inputEl.getValue()) || new Date());
      datePicker.open();
    });
    shiftFromTodayBtn.onClick(async (e) => {
      const newValue = await this.dateManager.getNewDateValue(this.currentShift, this.file, this.indexedPath);
      this.inputEl.setValue(newValue);
      this.value = newValue;
      this.pushNextInterval = true;
      this.toggleButton(shiftFromTodayBtn, this.inputEl.getValue());
    });
  }
};

// src/fields/fieldManagers/DateField.ts
var DateField = class extends FieldManager2 {
  constructor(plugin, field) {
    super(plugin, field, "Date" /* Date */);
    this.defaultDateFormat = "YYYY-MM-DD";
    this.showModalOption = false;
  }
  async buildAndOpenModal(file, indexedPath) {
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const modal = new DateModal(this.plugin, file, this.field, eF, indexedPath);
    modal.titleEl.setText(`Change date for <${this.field.name}>`);
    modal.open();
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const dateIconName = FieldIcon["Date" /* Date */];
    const dateModalAction = async () => await this.buildAndOpenModal(file, indexedPath);
    const shiftDateAction = async () => await this.shiftDate(file, indexedPath);
    const clearDateAction = async () => await this.clearDate(file, indexedPath);
    if (DateField.isSuggest(location)) {
      location.options.push({
        id: `update_${name}`,
        actionLabel: `<span>Update <b>${name}</b></span>`,
        action: dateModalAction,
        icon: dateIconName
      });
      if (this.field.options.dateShiftInterval || this.field.options.nextShiftIntervalField) {
        location.options.push({
          id: `update_${name}`,
          actionLabel: `<span>Shift <b>${name}</b> ahead</span>`,
          action: shiftDateAction,
          icon: "skip-forward"
        });
      }
      location.options.push({
        id: `clear_${name}`,
        actionLabel: `<span>Clear <b>${name}</b></span>`,
        action: clearDateAction,
        icon: "eraser"
      });
    } else if (DateField.isFieldOptions(location)) {
      location.addOption("skip-forward", shiftDateAction, `Shift ${name} ahead`);
      location.addOption(dateIconName, dateModalAction, `Set ${name}'s date`);
    }
    ;
  }
  createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = new DateModal(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.titleEl.setText(`Enter date for ${selectedFieldName}`);
    fieldModal.open();
  }
  createSettingContainer(container, plugin, location) {
    var _a, _b;
    if (!this.field.options.dateFormat)
      this.field.options.dateFormat = this.defaultDateFormat;
    if (!this.field.options.defaultInsertAsLink)
      this.field.options.defaultInsertAsLink = "false";
    const dateFormatContainer = container.createDiv({ cls: "field-container" });
    dateFormatContainer.createEl("span", { text: "Date format", cls: "label" });
    const dateExample = dateFormatContainer.createEl("span", { cls: "more-info" });
    const dateFormatInput = new import_obsidian48.TextComponent(dateFormatContainer);
    dateFormatInput.inputEl.addClass("with-label");
    dateFormatInput.inputEl.addClass("full-width");
    dateFormatInput.setValue(this.field.options.dateFormat);
    dateExample.setText(`${(0, import_obsidian48.moment)().format(dateFormatInput.getValue())}`);
    dateFormatInput.onChange((value) => {
      this.field.options.dateFormat = value;
      dateExample.setText(`${(0, import_obsidian48.moment)().format(value)}`);
    });
    const defaultInsertAsLinkContainer = container.createDiv({ cls: "field-container" });
    defaultInsertAsLinkContainer.createEl("span", { text: "Insert as link by default", cls: "label" });
    defaultInsertAsLinkContainer.createDiv({ cls: "spacer" });
    const defaultInsertAsLink = new import_obsidian48.ToggleComponent(defaultInsertAsLinkContainer);
    defaultInsertAsLink.setValue(DateField.stringToBoolean(this.field.options.defaultInsertAsLink));
    defaultInsertAsLink.onChange((value) => {
      this.field.options.defaultInsertAsLink = value;
    });
    const dateLinkPathContainer = container.createDiv({ cls: "field-container" });
    dateLinkPathContainer.createEl("span", { text: "Link path (optional)", cls: "label" });
    const dateLinkPathInput = new import_obsidian48.TextComponent(dateLinkPathContainer);
    dateLinkPathInput.inputEl.addClass("with-label");
    dateLinkPathInput.inputEl.addClass("full-width");
    dateLinkPathInput.setValue(this.field.options.linkPath);
    dateLinkPathInput.onChange((value) => {
      this.field.options.linkPath = value + (!value.endsWith("/") && !!value.length ? "/" : "");
    });
    const dateShiftIntervalContainer = container.createDiv({ cls: "field-container" });
    dateShiftIntervalContainer.createEl("span", { text: "Define a shift interval", cls: "label" });
    dateShiftIntervalContainer.createDiv({ cls: "spacer" });
    const dateShiftInterval = new import_obsidian48.TextComponent(dateShiftIntervalContainer);
    dateShiftInterval.setPlaceholder("ex: 1 month, 2 days");
    dateShiftInterval.setValue(this.field.options.dateShiftInterval);
    dateShiftInterval.onChange((value) => {
      if (!value) {
        delete this.field.options.dateShiftInterval;
      } else {
        this.field.options.dateShiftInterval = value.toString();
      }
    });
    const nextShiftIntervalFieldContainer = container.createDiv({ cls: "field-container" });
    nextShiftIntervalFieldContainer.createEl("span", {
      text: "Field containing shift intervals",
      cls: "label"
    });
    nextShiftIntervalFieldContainer.createDiv({ cls: "spacer" });
    const nextShiftIntervalField = new import_obsidian48.DropdownComponent(nextShiftIntervalFieldContainer);
    nextShiftIntervalField.addOption("none", "---None---");
    let rootFields = [];
    if (this.field.fileClassName) {
      rootFields = ((_a = this.plugin.fieldIndex.fileClassesFields.get(this.field.fileClassName || "")) == null ? void 0 : _a.filter((_f) => _f.isRoot() && _f.name !== this.field.name && _f.type === "Cycle" /* Cycle */)) || [];
    } else {
      rootFields = this.plugin.presetFields.filter((_f) => _f.name !== this.field.name && _f.type === "Cycle" /* Cycle */);
    }
    rootFields.forEach((_f) => nextShiftIntervalField.addOption(_f.id, _f.name));
    const currentField = ((_b = rootFields.find((_f) => _f.name === this.field.options.nextShiftIntervalField)) == null ? void 0 : _b.id) || "none";
    nextShiftIntervalField.setValue(currentField);
    nextShiftIntervalField.onChange((value) => {
      var _a2;
      if (value === "none") {
        delete this.field.options.nextShiftIntervalField;
      } else {
        this.field.options.nextShiftIntervalField = (_a2 = rootFields.find((_f) => _f.id === value)) == null ? void 0 : _a2.name.toString();
      }
    });
  }
  async getMomentDate(file, indexedPath) {
    var _a;
    const { dateFormat } = this.field.options;
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const _date = eF == null ? void 0 : eF.value;
    const _dateLink = getLink(_date, file);
    const _dateText = _dateLink ? (_a = _dateLink.path.split("/").last()) == null ? void 0 : _a.replace(/(.*).md/, "$1") : _date;
    return (0, import_obsidian48.moment)(_dateText, dateFormat);
  }
  async getNewDateValue(currentShift, file, indexedPath) {
    const { dateFormat } = this.field.options;
    const momentDate = await this.getMomentDate(file, indexedPath);
    const [_shiftNumber, shiftPeriod] = (currentShift == null ? void 0 : currentShift.split(" ")) || ["1", "days"];
    const shiftNumber = parseInt(_shiftNumber) || 1;
    const _newDate = momentDate.isValid() ? momentDate.add(shiftNumber, shiftPeriod).format(dateFormat) : void 0;
    return _newDate || (0, import_obsidian48.moment)().format(dateFormat);
  }
  async shiftDate(file, indexedPath) {
    if (!indexedPath)
      return;
    const { dateFormat, defaultInsertAsLink, linkPath } = this.field.options;
    const fieldManager = new FieldManager[this.field.type](this.plugin, this.field);
    const [currentShift, nextIntervalField, nextShift] = await fieldManager.shiftDuration(file);
    const newValue = await this.getNewDateValue(currentShift, file, indexedPath);
    if (nextIntervalField && nextShift) {
      await postValues(this.plugin, [{ id: nextIntervalField.id, payload: { value: nextShift } }], file.path);
    }
    const linkFile = this.plugin.app.metadataCache.getFirstLinkpathDest(linkPath || "" + newValue.format(dateFormat), file.path);
    const formattedValue = DateField.stringToBoolean(defaultInsertAsLink) ? `[[${linkPath || ""}${newValue}${linkFile ? "|" + linkFile.basename : ""}]]` : newValue;
    await postValues(this.plugin, [{ id: indexedPath, payload: { value: formattedValue } }], file);
  }
  async clearDate(file, indexedPath) {
    if (!indexedPath)
      return;
    await postValues(this.plugin, [{ id: indexedPath, payload: { value: "" } }], file);
  }
  createDvField(dv, p, fieldContainer, attrs = {}) {
    var _a;
    attrs.cls = "value-container";
    const fieldValue = dv.el("span", p[this.field.name] || "", attrs);
    const dateBtn = fieldContainer.createEl("button");
    (0, import_obsidian48.setIcon)(dateBtn, FieldIcon["Date" /* Date */]);
    const spacer = fieldContainer.createDiv({ cls: "spacer-1" });
    this.shiftBtn = fieldContainer.createEl("button");
    (0, import_obsidian48.setIcon)(this.shiftBtn, "skip-forward");
    spacer.setAttr("class", "spacer-2");
    const file = this.plugin.app.vault.getAbstractFileByPath(p.file.path);
    if (file instanceof import_obsidian48.TFile && file.extension == "md") {
      dateBtn.onclick = async () => await this.buildAndOpenModal(file, this.field.id);
      this.shiftBtn.onclick = () => {
        if (file)
          this.shiftDate(file, this.field.id);
      };
    }
    if (!((_a = attrs == null ? void 0 : attrs.options) == null ? void 0 : _a.alwaysOn)) {
      dateBtn.hide();
      if (this.shiftBtn)
        this.shiftBtn.hide();
      spacer.show();
      fieldContainer.onmouseover = () => {
        dateBtn.show();
        if (this.shiftBtn)
          this.shiftBtn.show();
        spacer.hide();
      };
      fieldContainer.onmouseout = () => {
        dateBtn.hide();
        if (this.shiftBtn)
          this.shiftBtn.hide();
        spacer.show();
      };
    }
    fieldContainer.appendChild(fieldValue);
    fieldContainer.appendChild(dateBtn);
    if (this.shiftBtn)
      fieldContainer.appendChild(this.shiftBtn);
    fieldContainer.appendChild(spacer);
  }
  getOptionsStr() {
    return this.field.options.dateFormat;
  }
  validateOptions() {
    return true;
  }
  displayValue(container, file, value, onClicked) {
    const dateFormat = this.field.options.dateFormat;
    const dateLink = getLink(value, file);
    if (dateLink == null ? void 0 : dateLink.path) {
      const linkText = dateLink.path.split("/").last() || "";
      const linkEl = container.createEl("a", { text: linkText.replace(/(.*).md/, "$1") });
      linkEl.onclick = () => {
        this.plugin.app.workspace.openLinkText(dateLink.path, file.path, true);
        onClicked();
      };
    } else {
      const date = (0, import_obsidian48.moment)(value, dateFormat);
      if (date.isValid()) {
        const dateText = date.format(this.field.options.dateFormat);
        if (this.field.options.defaultInsertAsLink) {
          const rootFolder = this.field.options.linkPath;
          const linkEl = container.createEl("a", { text: dateText });
          linkEl.onclick = () => {
            this.plugin.app.workspace.openLinkText(`${rootFolder ? rootFolder + "/" : ""}${dateText}.md`, file.path, true);
            onClicked();
          };
        } else {
          container.createDiv({ text: dateText });
        }
      } else {
        container.createDiv({ text: value });
      }
    }
    container.createDiv({});
  }
  validateValue(value) {
    var _a, _b;
    if (!value) {
      return true;
    } else {
      if (typeof value == "string") {
        return (0, import_obsidian48.moment)(
          (_a = value.replace(/^\[\[/g, "").replace(/\]\]$/g, "").split("|").first()) == null ? void 0 : _a.split("/").last(),
          this.field.options.dateFormat
        ).isValid();
      } else {
        return (0, import_obsidian48.moment)(
          (_b = value.path.replace(/^\[\[/g, "").replace(/\]\]$/g, "").split("|").first()) == null ? void 0 : _b.split("/").last(),
          this.field.options.dateFormat
        ).isValid();
      }
    }
  }
  async shiftDuration(file) {
    var _a, _b;
    const interval = this.field.options.dateShiftInterval;
    const cycleIntervalField = this.field.options.nextShiftIntervalField;
    const cycle = (_a = this.plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a.find((field) => field.name === cycleIntervalField);
    let currentValue;
    let nextValue;
    if (cycle) {
      const cycleManager = new FieldManager[cycle.type](this.plugin, cycle);
      const options2 = cycleManager.getOptionsList();
      currentValue = (_b = await Note.getExistingFieldForIndexedPath(this.plugin, file, cycle.id)) == null ? void 0 : _b.value;
      if (currentValue) {
        nextValue = cycleManager.nextOption(currentValue);
      } else {
        currentValue = options2[0];
        nextValue = options2[1];
      }
    } else if (interval) {
      currentValue = interval;
    }
    const [_nextShiftNumber, nextShiftPeriod] = (currentValue == null ? void 0 : currentValue.split(" ")) || ["1", "days"];
    const nextShiftNumber = parseInt(_nextShiftNumber) || 1;
    if (import_obsidian48.moment.isDuration(import_obsidian48.moment.duration(nextShiftNumber, nextShiftPeriod))) {
      return [currentValue, cycle, nextValue];
    } else {
      return [currentValue, cycle, interval];
    }
  }
};

// src/modals/fields/MultiFileModal.ts
var import_obsidian49 = require("obsidian");
var MultiFileModal = class extends import_obsidian49.FuzzySuggestModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    var _a;
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.selectedFiles = [];
    const initialOptions = ((_a = this.eF) == null ? void 0 : _a.value) || [];
    if (initialOptions) {
      if (Array.isArray(initialOptions)) {
        initialOptions.map((item) => {
          const link = getLink(item, this.file);
          if (link) {
            const file2 = this.plugin.app.vault.getAbstractFileByPath(link.path);
            if (file2 instanceof import_obsidian49.TFile && !this.selectedFiles.map((_f) => _f.path).includes(file2.path))
              this.selectedFiles.push(file2);
          }
        });
      } else {
        const links = extractLinks(initialOptions);
        links.forEach((_link) => {
          const link = getLink(_link, this.file);
          if (link) {
            const file2 = this.plugin.app.vault.getAbstractFileByPath(link.path);
            if (file2 instanceof import_obsidian49.TFile && !this.selectedFiles.map((_f) => _f.path).includes(link.path))
              this.selectedFiles.push(file2);
          }
        });
      }
    } else {
      this.selectedFiles = [];
    }
    this.containerEl.addClass("metadata-menu");
    this.containerEl.onkeydown = async (e) => {
      if (e.key == "Enter" && e.altKey) {
        e.preventDefault();
        await this.replaceValues();
        this.close();
      }
    };
    cleanActions(this.containerEl, ".footer-actions");
    const buttonContainer = this.containerEl.createDiv({ cls: "footer-actions" });
    buttonContainer.createDiv({ cls: "spacer" });
    const infoContainer = buttonContainer.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to save");
    const confirmButton = new import_obsidian49.ButtonComponent(buttonContainer);
    confirmButton.setIcon("checkmark");
    confirmButton.onClick(async () => {
      await this.replaceValues();
      this.close();
    });
    const cancelButton = new import_obsidian49.ButtonComponent(buttonContainer);
    cancelButton.setIcon("cross");
    cancelButton.onClick(() => {
      this.close();
    });
    const clearButton = new import_obsidian49.ButtonComponent(buttonContainer);
    clearButton.setIcon("trash");
    clearButton.onClick(async () => {
      await this.clearValues();
      this.close();
    });
    clearButton.buttonEl.addClass("danger");
    this.modalEl.appendChild(buttonContainer);
  }
  onOpen() {
    super.onOpen();
  }
  onClose() {
    var _a;
    (_a = this.previousModal) == null ? void 0 : _a.open();
  }
  getItems() {
    const sortingMethod = new Function("a", "b", `return ${this.field.options.customSorting}`) || function(a, b) {
      return a.basename < b.basename ? -1 : 1;
    };
    try {
      const fileManager = new FieldManager[this.field.type](this.plugin, this.field);
      return fileManager.getFiles(this.file).sort(sortingMethod);
    } catch (error) {
      this.close();
      throw error;
    }
  }
  getItemText(item) {
    return item.basename;
  }
  async replaceValues() {
    const result = this.selectedFiles.map((file) => {
      var _a;
      const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
      let alias = void 0;
      if (dvApi && this.field.options.customRendering) {
        alias = new Function("page", `return ${this.field.options.customRendering}`)(dvApi.page(file.path));
      }
      return FieldManager2.buildMarkDownLink(this.plugin, this.file, file.basename, void 0, alias);
    });
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: result.join(", ") } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
  }
  async clearValues() {
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: "" } }], this.file);
  }
  renderSuggestion(value, el) {
    var _a;
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    if (dvApi && this.field.options.customRendering) {
      const suggestionContainer = el.createDiv({ cls: "item-with-add-on" });
      suggestionContainer.createDiv({
        text: new Function("page", `return ${this.field.options.customRendering}`)(dvApi.page(value.item.path))
      });
      const filePath = suggestionContainer.createDiv({ cls: "add-on" });
      filePath.setText(value.item.path);
    } else {
      el.setText(value.item.basename);
    }
    el.addClass("value-container");
    const spacer = this.containerEl.createDiv({ cls: "spacer" });
    el.appendChild(spacer);
    if (this.selectedFiles.some((file) => file.path === value.item.path)) {
      el.addClass("value-checked");
      const iconContainer = el.createDiv({ cls: "icon-container" });
      (0, import_obsidian49.setIcon)(iconContainer, "check-circle");
    }
  }
  renderSelected() {
    const chooser = this.chooser;
    const suggestions = chooser.suggestions;
    const values = chooser.values;
    suggestions.forEach((s, i) => {
      if (this.selectedFiles.some((file) => file.path === values[i].item.path)) {
        s.addClass("value-checked");
        if (s.querySelectorAll(".icon-container").length == 0) {
          const iconContainer = s.createDiv({ cls: "icon-container" });
          (0, import_obsidian49.setIcon)(iconContainer, "check-circle");
        }
      } else {
        s.removeClass("value-checked");
        s.querySelectorAll(".icon-container").forEach((icon) => icon.remove());
      }
    });
  }
  selectSuggestion(value, evt) {
    if (this.selectedFiles.includes(value.item)) {
      this.selectedFiles.remove(value.item);
    } else {
      this.selectedFiles.push(value.item);
    }
    this.renderSelected();
  }
  async onChooseItem(item) {
  }
};

// src/utils/linksUtils.ts
var displayLinksOrText = (value, file, container, plugin, onClicked) => {
  const links = typeof value === "string" ? extractLinks(value) : void 0;
  if (links) {
    links.forEach((_link, i) => {
      const link = getLink(_link, file);
      if (link == null ? void 0 : link.path) {
        const linkText = link.path.split("/").last() || "";
        const linkEl = container.createEl("a", { text: linkText.replace(/(.*).md/, "$1") });
        linkEl.onclick = () => {
          plugin.app.workspace.openLinkText(link.path, file.path, true);
          onClicked();
        };
      }
      if (i < links.length - 1) {
        container.createEl("span", { text: " | " });
      }
    });
  } else {
    const values = Array.isArray(value) ? value : [value];
    values.forEach((value2, i) => {
      if (value2) {
        const link = getLink(value2, file);
        if (link == null ? void 0 : link.path) {
          const linkText = link.path.split("/").last() || "";
          const linkEl = container.createEl("a", { text: linkText.replace(/(.*).md/, "$1") });
          linkEl.onclick = () => {
            plugin.app.workspace.openLinkText(link.path, file.path, true);
            onClicked();
          };
        } else {
          container.createDiv({ text: value2 });
        }
        if (i < values.length - 1) {
          container.createEl("span", { text: " | " });
        }
      }
    });
  }
};

// src/fields/fieldManagers/MultiFileField.ts
var MultiFileField = class extends AbstractFileBasedField {
  constructor(plugin, field) {
    super(plugin, field, "MultiFile" /* MultiFile */);
  }
  modalFactory(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    return new MultiFileModal(plugin, file, field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
  }
  static buildMarkDownLink(plugin, file, path) {
    const destFile = plugin.app.metadataCache.getFirstLinkpathDest(path, file.path);
    if (destFile) {
      return plugin.app.fileManager.generateMarkdownLink(
        destFile,
        file.path,
        void 0,
        destFile.basename
      );
    }
    return "";
  }
  validateValue(value) {
    return true;
  }
  displayValue(container, file, value, onClick) {
    displayLinksOrText(value, file, container, this.plugin, () => onClick);
  }
};

// src/fields/fieldManagers/LookupField.ts
var import_obsidian51 = require("obsidian");

// src/commands/updateLookups.ts
var import_obsidian50 = require("obsidian");
function arraysAsStringAreEqual(a, b) {
  const aAsArray = typeof a === "string" ? a.split(",").map((v) => v.trim()) : Array.isArray(a) ? a : [];
  const bAsArray = typeof b === "string" ? b.split(",").map((v) => v.trim()) : Array.isArray(b) ? b : [];
  return aAsArray.every((item) => bAsArray.includes(item)) && bAsArray.every((item) => aAsArray.includes(item));
}
function renderValue(field, pages, plugin, tFile, renderingErrors) {
  let newValue = "";
  switch (field.options.outputType) {
    case "LinksList" /* LinksList */:
    case "LinksBulletList" /* LinksBulletList */:
      {
        const newValuesArray = pages == null ? void 0 : pages.map((dvFile) => {
          return FieldManager2.buildMarkDownLink(plugin, tFile, dvFile.file.path);
        });
        newValue = (newValuesArray || []).join(", ");
      }
      break;
    case "CustomList" /* CustomList */:
    case "CustomBulletList" /* CustomBulletList */:
      {
        const renderingFunction = new Function("page", `return ${field.options.customListFunction}`);
        const newValuesArray = pages == null ? void 0 : pages.map((dvFile) => {
          try {
            return renderingFunction(dvFile);
          } catch (e) {
            plugin.fieldIndex.fileLookupFieldsStatus.set(`${tFile.path}__related__${field.fileClassName}___${field.name}`, "error" /* error */);
            if (!renderingErrors.includes(field.name))
              renderingErrors.push(field.name);
            return "";
          }
        });
        newValue = (newValuesArray || []).join(", ");
      }
      break;
    case "CustomSummarizing" /* CustomSummarizing */:
      {
        const customSummarizingFunction = field.options.customSummarizingFunction;
        const summarizingFunction = new Function(
          "pages",
          customSummarizingFunction.replace(/\{\{summarizedFieldName\}\}/g, field.options.summarizedFieldName)
        );
        try {
          newValue = summarizingFunction(pages).toString();
        } catch (e) {
          plugin.fieldIndex.fileLookupFieldsStatus.set(`${tFile.path}__related__${field.fileClassName}___${field.name}`, "error" /* error */);
          if (!renderingErrors.includes(field.name))
            renderingErrors.push(field.name);
          newValue = "";
        }
      }
      break;
    case "BuiltinSummarizing" /* BuiltinSummarizing */:
      {
        const builtinFunction = field.options.builtinSummarizingFunction;
        const summarizingFunction = new Function(
          "pages",
          BuiltinSummarizingFunction[builtinFunction].replace(/\{\{summarizedFieldName\}\}/g, field.options.summarizedFieldName)
        );
        try {
          newValue = summarizingFunction(pages).toString();
        } catch (e) {
          if (!renderingErrors.includes(field.name))
            renderingErrors.push(field.name);
          newValue = "";
        }
      }
      break;
    default:
      break;
  }
  return newValue;
}
async function updateLookups(plugin, forceUpdateOne, forceUpdateAll = false) {
  const start2 = Date.now();
  const f = plugin.fieldIndex;
  const renderingErrors = [];
  const payloads = {};
  const updatedFields = [];
  await Promise.all([...f.fileLookupFiles.keys()].map(async (lookupFileId) => {
    var _a, _b;
    const matchRegex = /(?<filePath>.*)__related__(?<fileClassName>.*)___(?<fieldName>.*)/;
    const { filePath, fieldName } = ((_a = lookupFileId.match(matchRegex)) == null ? void 0 : _a.groups) || {};
    const file = plugin.app.vault.getAbstractFileByPath(filePath);
    if (!file || !(file instanceof import_obsidian50.TFile))
      return;
    payloads[filePath] = payloads[filePath] || [];
    let newValue = "";
    const pages = f.fileLookupFiles.get(lookupFileId);
    const field = (_b = f.filesFields.get(filePath)) == null ? void 0 : _b.find((field2) => field2.name == fieldName);
    if (field) {
      const outputType = field.options.outputType;
      if (!f.fileLookupFieldLastOutputType.get(lookupFileId))
        f.fileLookupFieldLastOutputType.set(lookupFileId, outputType);
      newValue = renderValue(field, pages, plugin, file, renderingErrors);
      const currentValue = f.fileLookupFieldLastValue.get(lookupFileId);
      const shouldCheckForUpdate = field.options.autoUpdate || field.options.autoUpdate === void 0 || forceUpdateAll || //field is autoUpdated OR
      //field is not autoupdated and we have to check for request to update this one
      (forceUpdateOne == null ? void 0 : forceUpdateOne.file.path) === file.path && (forceUpdateOne == null ? void 0 : forceUpdateOne.fieldName) === field.name;
      const valueHasChanged = !currentValue && newValue !== "" || !arraysAsStringAreEqual(currentValue || "", newValue);
      const formatHasChanged = outputType !== f.fileLookupFieldLastOutputType.get(lookupFileId);
      if (f.lastTimeBeforeResolving && file.stat.mtime < f.lastTimeBeforeResolving && file.stat.mtime > (f.lastDVUpdatingTime || 0)) {
        return;
      }
      if (valueHasChanged || formatHasChanged) {
        f.fileLookupFieldsStatus.set(`${filePath}__${fieldName}`, "changed" /* changed */);
      }
      if (shouldCheckForUpdate) {
        f.fileLookupFieldLastValue.set(lookupFileId, newValue);
        f.fileLookupFieldLastOutputType.set(lookupFileId, outputType);
      }
      if (shouldCheckForUpdate && (valueHasChanged || formatHasChanged)) {
        payloads[filePath].push({ id: field.id, payload: { value: newValue } });
        updatedFields.push(`${filePath}__${fieldName}`);
      }
      if (!valueHasChanged && !formatHasChanged) {
        f.fileLookupFieldsStatus.set(`${filePath}__${fieldName}`, "upToDate" /* upToDate */);
      }
    }
  }));
  Object.entries(payloads).forEach(async ([filePath, fieldsPayload]) => {
    f.pushPayloadToUpdate(filePath, fieldsPayload);
  });
}

// src/fields/fieldManagers/LookupField.ts
var LookupField = class extends FieldManager2 {
  constructor(plugin, field) {
    super(plugin, field, "Lookup" /* Lookup */);
    this.showModalOption = false;
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    if (!this.field.options.autoUpdate && this.field.options.autoUpdate !== void 0) {
      const f = this.plugin.fieldIndex;
      const id = `${file.path}__${this.field.name}`;
      let status;
      status = f.fileLookupFieldsStatus.get(id) || "changed" /* changed */;
      if (f.fileLookupFieldLastOutputType.get(`${file.path}__related__${this.field.fileClassName}___${this.field.name}`) !== this.field.options.outputType)
        status = "changed" /* changed */;
      const icon = statusIcon[status];
      const action = async () => {
        await updateLookups(this.plugin, { file, fieldName: this.field.name });
        f.applyUpdates();
      };
      if (LookupField.isSuggest(location) && ["changed" /* changed */, "mayHaveChanged" /* mayHaveChanged */].includes(status)) {
        location.options.push({
          id: `update_${name}`,
          actionLabel: `<span>Update <b>${name}</b></span>`,
          action,
          icon
        });
      } else if (LookupField.isFieldOptions(location) && ["changed" /* changed */, "mayHaveChanged" /* mayHaveChanged */].includes(status)) {
        location.addOption(icon, action, `Update ${name}'s value`);
      } else if (LookupField.isFieldOptions(location) && status === "upToDate" /* upToDate */) {
        location.addOption(icon, () => {
        }, `${name} is up to date`);
      }
    } else if (LookupField.isFieldOptions(location)) {
      location.addOption("server-cog", () => {
      }, `${name} is auto-updated`, "disabled");
    }
  }
  async createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote) {
    await this.plugin.fieldIndex.fullIndex();
  }
  createDvField(dv, p, fieldContainer, attrs) {
    var _a, _b;
    const file = p.file;
    const fieldName = this.field.name;
    const fileClassName = ((_b = (_a = this.plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a.find((f) => f.name === fieldName)) == null ? void 0 : _b.fileClassName) || "presetField";
    const fieldValue = dv.el("span", this.plugin.fieldIndex.fileLookupFieldLastValue.get(`${file.path}__related__${fileClassName}___${fieldName}`), attrs);
    fieldContainer.appendChild(fieldValue);
  }
  displaySelectedOutputOptionContainer(optionContainers, value) {
    optionContainers.forEach((options_set) => {
      var _a, _b;
      if (options_set[0].includes(value)) {
        (_a = options_set[1]) == null ? void 0 : _a.show();
      } else {
        (_b = options_set[1]) == null ? void 0 : _b.hide();
      }
    });
  }
  displayValue(container, file, value, onClicked = () => {
  }) {
    displayLinksOrText(value, file, container, this.plugin, () => onClicked);
  }
  displaySelectedOutputWarningContainer(optionWarningContainer, value) {
    ["LinksBulletList" /* LinksBulletList */.toString(), "CustomBulletList" /* CustomBulletList */.toString()].includes(value) ? optionWarningContainer.show() : optionWarningContainer.hide();
  }
  createLookupContainer(container) {
    const autoUpdateTopContainer = container.createDiv({ cls: "vstacked" });
    const autoUpdateContainer = autoUpdateTopContainer.createDiv({ cls: "field-container" });
    autoUpdateContainer.createEl("span", { text: "Auto update this field ", cls: "label" });
    autoUpdateContainer.createDiv({ cls: "spacer" });
    const autoUpdate = new import_obsidian51.ToggleComponent(autoUpdateContainer);
    autoUpdateTopContainer.createEl("span", { text: "This could lead to latencies depending on the queries", cls: "sub-text warning" });
    if (this.field.options.autoUpdate === void 0)
      this.field.options.autoUpdate = false;
    autoUpdate.setValue(this.field.options.autoUpdate);
    autoUpdate.onChange((value) => {
      this.field.options.autoUpdate = value;
    });
    const dvQueryStringTopContainer = container.createDiv({ cls: "vstacked" });
    dvQueryStringTopContainer.createEl("span", { text: "Pages to look for in your vault (DataviewJS Query)", cls: "label" });
    dvQueryStringTopContainer.createEl("span", { text: "DataviewJS query of the form `dv.pages(...)`", cls: "sub-text" });
    const dvQueryStringContainer = dvQueryStringTopContainer.createDiv({ cls: "field-container" });
    const dvQueryString = new import_obsidian51.TextAreaComponent(dvQueryStringContainer);
    dvQueryString.inputEl.addClass("full-width");
    dvQueryString.inputEl.cols = 50;
    dvQueryString.inputEl.rows = 4;
    dvQueryString.setValue(this.field.options.dvQueryString || "");
    dvQueryString.setPlaceholder("exampe: dv.pages('#student')");
    dvQueryString.onChange((value) => {
      this.field.options.dvQueryString = value;
      FieldSettingsModal.removeValidationError(dvQueryString);
    });
    const targetFieldTopContainer = container.createDiv({ cls: "vstacked" });
    const targetFieldContainer = targetFieldTopContainer.createDiv({ cls: "field-container" });
    targetFieldContainer.createEl("span", { text: "Name of the related field", cls: "label" });
    const targetFieldName = new import_obsidian51.TextComponent(targetFieldContainer);
    targetFieldName.inputEl.addClass("full-width");
    targetFieldName.inputEl.addClass("with-label");
    targetFieldTopContainer.createEl("span", { text: "field in the target pages that contains a link to the page where this lookup field is", cls: "sub-text" });
    targetFieldName.setValue(this.field.options.targetFieldName || "");
    targetFieldName.onChange((value) => {
      this.field.options.targetFieldName = value;
      FieldSettingsModal.removeValidationError(targetFieldName);
    });
    const outputTypeContainer = container.createDiv({ cls: "field-container" });
    this.field.options.outputType = this.field.options.outputType || "LinksList" /* LinksList */;
    outputTypeContainer.createEl("span", { text: "Type of output", cls: "label" });
    outputTypeContainer.createDiv({ cls: "spacer" });
    const outputTypeList = new import_obsidian51.DropdownComponent(outputTypeContainer);
    Object.keys(Type).forEach((outputType) => {
      outputTypeList.addOption(outputType, Description[outputType]);
    });
    outputTypeList.setValue(this.field.options.outputType);
    const outputWarningContainer = container.createDiv();
    outputWarningContainer.createEl("p", {
      text: "Warning: this may override some lines under your list. There shouldn't be an extra manual item in the list that is automatically rendered by this field: it would be overriden after each field indexing",
      cls: "field-warning"
    });
    const builtinOptionsContainer = container.createDiv();
    const builtinSummarizeFunctionTopContainer = builtinOptionsContainer.createDiv({ cls: "vstacked" });
    const builtinSummarizeFunctionContainer = builtinSummarizeFunctionTopContainer.createDiv({ cls: "field-container" });
    this.field.options.builtinSummarizingFunction = this.field.options.builtinSummarizingFunction || Default.BuiltinSummarizing;
    builtinSummarizeFunctionContainer.createEl("span", { text: OptionLabel.BuiltinSummarizing, cls: "label" });
    builtinSummarizeFunctionContainer.createDiv({ cls: "spacer" });
    const builtinSummarizeFunctionList = new import_obsidian51.DropdownComponent(builtinSummarizeFunctionContainer);
    Object.keys(BuiltinSummarizing).forEach((builtinFunction2) => {
      builtinSummarizeFunctionList.addOption(builtinFunction2, BuiltinSummarizing[builtinFunction2]);
    });
    const builtinOptionsDescriptionContainer = builtinSummarizeFunctionTopContainer.createDiv({ cls: "sub-text" });
    const builtinFunction = this.field.options.builtinSummarizingFunction;
    builtinOptionsDescriptionContainer.setText(BuiltinSummarizingFunctionDescription[builtinFunction].replace("{{summarizedFieldName}}", this.field.options.summarizedFieldName));
    builtinSummarizeFunctionList.setValue(this.field.options.builtinSummarizingFunction);
    builtinSummarizeFunctionList.onChange((value) => {
      this.field.options.builtinSummarizingFunction = value;
      builtinOptionsDescriptionContainer.setText(BuiltinSummarizingFunctionDescription[value].replace("{{summarizedFieldName}}", this.field.options.summarizedFieldName));
    });
    const summarizedFieldNameTopContainer = builtinOptionsContainer.createDiv({ cls: "vstacked" });
    this.field.options.summarizedFieldName = this.field.options.summarizedFieldName;
    const summarizedFieldNameContainer = summarizedFieldNameTopContainer.createDiv({ cls: "field-container" });
    summarizedFieldNameContainer.createEl("span", { text: "Summarized field name", cls: "label" });
    const summarizedFieldName = new import_obsidian51.TextComponent(summarizedFieldNameContainer);
    summarizedFieldName.inputEl.addClass("full-width");
    summarizedFieldName.inputEl.addClass("with-label");
    summarizedFieldNameTopContainer.createEl("span", { text: "Name of the field containing summarized value used for the summarizing function", cls: "sub-text" });
    summarizedFieldName.setValue(this.field.options.summarizedFieldName);
    summarizedFieldName.onChange((value) => {
      this.field.options.summarizedFieldName = value;
    });
    const outputRenderingFunctionTopContainer = container.createDiv({ cls: "vstacked" });
    this.field.options.customListFunction = this.field.options.customListFunction || Default.CustomList;
    outputRenderingFunctionTopContainer.createEl("span", { text: OptionLabel.CustomList, cls: "label" });
    outputRenderingFunctionTopContainer.createEl("code", { text: OptionSubLabel.CustomList });
    const outputRenderingFunctionContainer = outputRenderingFunctionTopContainer.createDiv({ cls: "field-container" });
    const outputRenderingFunction = new import_obsidian51.TextAreaComponent(outputRenderingFunctionContainer);
    outputRenderingFunction.inputEl.addClass("full-width");
    outputRenderingFunction.setPlaceholder(Helper.CustomList);
    outputRenderingFunction.setValue(this.field.options.customListFunction);
    outputRenderingFunction.inputEl.cols = 65;
    outputRenderingFunction.inputEl.rows = 4;
    outputRenderingFunction.onChange((value) => {
      this.field.options.customListFunction = value;
    });
    const outputSummarizingFunctionTopContainer = container.createDiv({ cls: "vstacked" });
    this.field.options.customSummarizingFunction = this.field.options.customSummarizingFunction || Default.CustomSummarizing;
    outputSummarizingFunctionTopContainer.createEl("span", { text: OptionLabel.CustomSummarizing, cls: "label" });
    outputSummarizingFunctionTopContainer.createEl("code", { text: OptionSubLabel.CustomSummarizing });
    const outputSummarizingFunctionContainer = outputSummarizingFunctionTopContainer.createDiv({ cls: "field-container" });
    const outputSummarizingFunction = new import_obsidian51.TextAreaComponent(outputSummarizingFunctionContainer);
    outputSummarizingFunction.inputEl.addClass("full-width");
    outputSummarizingFunction.setPlaceholder(Helper.CustomSummarizing);
    outputSummarizingFunction.setValue(this.field.options.customSummarizingFunction);
    outputSummarizingFunction.inputEl.cols = 65;
    outputSummarizingFunction.inputEl.rows = 8;
    outputSummarizingFunction.onChange((value) => {
      this.field.options.customSummarizingFunction = value;
    });
    const optionContainers = [
      [["LinksList", "LinksBulletList"], void 0],
      [["BuiltinSummarizing"], builtinOptionsContainer],
      [["CustomList", "CustomBulletList"], outputRenderingFunctionTopContainer],
      [["CustomSummarizing"], outputSummarizingFunctionTopContainer]
    ];
    this.displaySelectedOutputOptionContainer(optionContainers, outputTypeList.getValue());
    this.displaySelectedOutputWarningContainer(outputWarningContainer, outputTypeList.getValue());
    outputTypeList.onChange((value) => {
      this.field.options.outputType = value;
      this.displaySelectedOutputOptionContainer(optionContainers, value);
      this.displaySelectedOutputWarningContainer(outputWarningContainer, value);
    });
  }
  createSettingContainer(container, plugin, location) {
    this.createLookupContainer(container);
  }
  getOptionsStr() {
    const shortDescription = ShortDescription[this.field.options.outputType];
    let complement = "";
    if (this.field.options.outputType === "BuiltinSummarizing" /* BuiltinSummarizing */) {
      complement = ` ${this.field.options.builtinSummarizingFunction}${this.field.options.builtinSummarizingFunction !== "CountAll" /* CountAll */ ? " " + this.field.options.summarizedFieldName : ""}`;
    }
    return shortDescription + complement;
  }
  validateOptions() {
    return true;
  }
};

// src/fields/fieldManagers/FormulaField.ts
var import_obsidian53 = require("obsidian");

// src/commands/updateFormulas.ts
var import_obsidian52 = require("obsidian");
function cleanRemovedFormulasFromIndex(plugin) {
  var _a, _b;
  const f = plugin.fieldIndex;
  for (let id of f.fileFormulaFieldLastValue.keys()) {
    const matchRegex = /(?<filePath>.*)__calculated__(?<fileClassName>.*)___(?<fieldName>.*)/;
    const { filePath, fileClassName, fieldName } = ((_a = id.match(matchRegex)) == null ? void 0 : _a.groups) || {};
    const existingFormulaFieldWithNameAndFileClassName = (_b = f.filesFields.get(filePath)) == null ? void 0 : _b.find(
      (field) => field.name === fieldName && (field.fileClassName === void 0 && fileClassName === "presetField" || field.fileClassName === fileClassName)
    );
    const dvPage = f.dv.api.page(filePath);
    if (dvPage === void 0 || dvPage[fieldName] === void 0 || !existingFormulaFieldWithNameAndFileClassName) {
      f.fileFormulaFieldLastValue.delete(id);
    }
  }
}
async function updateFormulas(plugin, forceUpdateOne, forceUpdateAll = false) {
  var _a, _b;
  const start2 = Date.now();
  DEBUG && console.log("start update formulas", plugin.fieldIndex.lastRevision, "->", (_a = plugin.fieldIndex.dv) == null ? void 0 : _a.api.index.revision);
  const f = plugin.fieldIndex;
  const fileFormulasFields = /* @__PURE__ */ new Map();
  [...f.filesLookupAndFormulaFieldsExists].forEach(([filePath, fields]) => {
    fields.filter((field) => field.type === "Formula" /* Formula */).forEach((field) => {
      const fileFormulaField = `${filePath}__calculated__${field.fileClassName || "presetField"}___${field.name}`;
      fileFormulasFields.set(fileFormulaField, field);
    });
  });
  await Promise.all([...fileFormulasFields].map(async ([id, field]) => {
    var _a2;
    const matchRegex = /(?<filePath>.*)__calculated__(?<fileClassName>.*)___(?<fieldName>.*)/;
    const { filePath, fileClassName, fieldName } = ((_a2 = id.match(matchRegex)) == null ? void 0 : _a2.groups) || {};
    const shouldUpdate = forceUpdateAll || (forceUpdateOne == null ? void 0 : forceUpdateOne.file.path) === filePath && (forceUpdateOne == null ? void 0 : forceUpdateOne.fieldName) === fieldName || field.options.autoUpdate === true;
    const _file = plugin.app.vault.getAbstractFileByPath(filePath);
    if (!_file || !(_file instanceof import_obsidian52.TFile))
      return;
    const currentValue = `${f.fileFormulaFieldLastValue.get(id) || ""}`;
    try {
      const dvFile = f.dv.api.page(filePath);
      const newValue = new Function("current, dv", `return ${field.options.formula}`)(dvFile, f.dv.api).toString();
      const valueHasChanged = currentValue === void 0 && newValue !== "" || !arraysAsStringAreEqual(currentValue, newValue) || currentValue !== newValue;
      if (!valueHasChanged) {
        f.fileFormulaFieldsStatus.set(`${filePath}__${fieldName}`, "upToDate" /* upToDate */);
        return;
      } else {
        if (!shouldUpdate) {
          f.fileFormulaFieldsStatus.set(`${filePath}__${field.name}`, "changed" /* changed */);
        } else {
          f.pushPayloadToUpdate(filePath, [{ id: field.id, payload: { value: newValue } }]);
          f.fileFormulaFieldLastValue.set(id, newValue);
          f.fileFormulaFieldsStatus.set(`${filePath}__${field.name}`, "upToDate" /* upToDate */);
        }
      }
    } catch (e) {
      f.fileFormulaFieldsStatus.set(`${filePath}__${field.name}`, "error" /* error */);
    }
  }));
  DEBUG && console.log("finished update formulas", plugin.fieldIndex.lastRevision, "->", (_b = plugin.fieldIndex.dv) == null ? void 0 : _b.api.index.revision, `${Date.now() - start2}ms`);
  cleanRemovedFormulasFromIndex(plugin);
}

// src/fields/fieldManagers/FormulaField.ts
var FormulaField = class extends FieldManager2 {
  constructor(plugin, field) {
    super(plugin, field, "Formula" /* Formula */);
    this.showModalOption = false;
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const f = this.plugin.fieldIndex;
    const id = `${file.path}__${name}`;
    const status = f.fileFormulaFieldsStatus.get(id) || "changed" /* changed */;
    if (!this.field.options.autoUpdate && this.field.options.autoUpdate !== void 0) {
      const action = async () => {
        await updateFormulas(this.plugin, { file, fieldName: name });
        f.applyUpdates();
      };
      const icon = statusIcon[status];
      if (FormulaField.isSuggest(location) && ["changed" /* changed */, "mayHaveChanged" /* mayHaveChanged */].includes(status)) {
        location.options.push({
          id: `update_${name}`,
          actionLabel: `<span>Update <b>${name}</b></span>`,
          action,
          icon
        });
      } else if (FormulaField.isFieldOptions(location) && ["changed" /* changed */, "mayHaveChanged" /* mayHaveChanged */].includes(status)) {
        location.addOption(icon, action, `Update ${name}'s value`);
      } else if (FormulaField.isFieldOptions(location) && status === "upToDate" /* upToDate */) {
        location.addOption(icon, () => {
        }, `${name} is up to date`);
      } else if (FormulaField.isFieldOptions(location) && status === "error" /* error */) {
        location.addOption(icon, () => {
        }, `${name} has an error`);
      }
    } else if (FormulaField.isFieldOptions(location)) {
      const icon = status === "error" /* error */ ? statusIcon["error"] : "server-cog";
      location.addOption(icon, () => {
      }, `${name} is auto-updated`, "disabled");
    }
  }
  async createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote) {
    await this.plugin.fieldIndex.fullIndex();
  }
  createDvField(dv, p, fieldContainer, attrs) {
    const fieldValue = dv.el("span", p[this.field.name], attrs);
    fieldContainer.appendChild(fieldValue);
  }
  displayValue(container, file, value, onClicked = () => {
  }) {
    var _a, _b;
    const fileClassName = ((_b = (_a = this.plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a.find((f) => f.id === this.field.id)) == null ? void 0 : _b.fileClassName) || "presetField";
    container.createDiv({ text: this.plugin.fieldIndex.fileFormulaFieldLastValue.get(`${file.path}__calculated__${fileClassName}___${this.field.name}`) });
  }
  createFormulaContainer(container) {
    const autoUpdateTopContainer = container.createDiv({ cls: "vstacked" });
    const autoUpdateContainer = autoUpdateTopContainer.createDiv({ cls: "field-container" });
    autoUpdateContainer.createEl("span", { text: "Auto update this field ", cls: "label" });
    autoUpdateContainer.createDiv({ cls: "spacer" });
    const autoUpdate = new import_obsidian53.ToggleComponent(autoUpdateContainer);
    autoUpdateTopContainer.createEl("span", { text: "This could lead to latencies depending on the queries", cls: "sub-text warning" });
    if (this.field.options.autoUpdate === void 0)
      this.field.options.autoUpdate = false;
    autoUpdate.setValue(this.field.options.autoUpdate);
    autoUpdate.onChange((value) => {
      this.field.options.autoUpdate = value;
    });
    const formulaTopContainer = container.createDiv({ cls: "vstacked" });
    formulaTopContainer.createEl("span", { text: "javascript formula", cls: "label" });
    formulaTopContainer.createEl("span", { text: "current and dv variables are available`", cls: "sub-text" });
    const formulaContainer = formulaTopContainer.createDiv({ cls: "field-container" });
    const formula = new import_obsidian53.TextAreaComponent(formulaContainer);
    formula.inputEl.addClass("full-width");
    formula.inputEl.cols = 50;
    formula.inputEl.rows = 4;
    formula.setValue(this.field.options.formula || "");
    formula.setPlaceholder("exampe: current.apple + current.bananas - 3");
    formula.onChange((value) => {
      this.field.options.formula = value;
      FieldSettingsModal.removeValidationError(formula);
    });
  }
  createSettingContainer(parentContainer, plugin, location) {
    this.createFormulaContainer(parentContainer);
  }
  getOptionsStr() {
    return this.field.options.formula;
  }
  validateOptions() {
    return true;
  }
};

// src/fields/fieldManagers/AbstractCanvasBasedField.ts
var import_obsidian54 = require("obsidian");
var AbstractListBasedField2 = class extends FieldManager2 {
  constructor(plugin, field, type) {
    super(plugin, field, type);
    this.standardColors = ["1", "2", "3", "4", "5", "6"];
    this.sides = [
      ["top", "chevron-up"],
      ["right", "chevron-right"],
      ["bottom", "chevron-down"],
      ["left", "chevron-left"]
    ];
    this.buildColorsContainer = (container, colorList, label) => {
      container.replaceChildren(...[]);
      container.createEl("span", { text: label, cls: "label" });
      container.createDiv({ cls: "spacer" });
      const toggleStandardColorButton = (container2, color) => {
        if (colorList.includes(color)) {
          container2.addClass("active");
          (0, import_obsidian54.setIcon)(container2, "cross");
        } else {
          container2.removeClass("active");
          (0, import_obsidian54.setIcon)(container2, "plus");
        }
        ;
      };
      this.standardColors.forEach((color) => {
        const colorContainer = container.createDiv({ cls: `node-color color-${color}` });
        toggleStandardColorButton(colorContainer, color);
        colorContainer.onmouseover = () => {
          colorContainer.setAttr("style", `color: white`);
        };
        colorContainer.onmouseout = () => {
          colorContainer.removeAttribute("style");
        };
        colorContainer.onclick = () => {
          const colors = colorList;
          if (colors.includes(color)) {
            colors.remove(color);
          } else {
            colors.push(color);
          }
          ;
          toggleStandardColorButton(colorContainer, color);
        };
      });
      const toggleAltColors = () => {
        const altGroupColors = colorList && colorList.filter((color) => !this.standardColors.includes(color)) || [];
        altGroupColors.forEach((color) => {
          const colorContainer = container.createDiv({ cls: `node-color` });
          colorContainer.setAttr("style", `background-color: ${color}; color: ${color}`);
          colorContainer.onmouseover = () => {
            colorContainer.setAttr("style", `background-color: ${color}; color: white`);
          };
          colorContainer.onmouseout = () => {
            colorContainer.setAttr("style", `background-color: ${color}; color: ${color}`);
          };
          (0, import_obsidian54.setIcon)(colorContainer, "cross");
          colorContainer.onclick = () => {
            colorList.remove(color);
            container.removeChild(colorContainer);
          };
        });
      };
      toggleAltColors();
      const altColorPickerContainer = container.createDiv({ cls: `node-color picker` });
      const altColorPicker = new import_obsidian54.ColorComponent(altColorPickerContainer);
      altColorPicker.onChange((value) => {
        colorList.push(value);
        this.buildColorsContainer(container, colorList, label);
      });
    };
    this.buildEdgeSideContainer = (container, edgeList, label) => {
      container.createDiv({ cls: "label", text: label });
      container.createDiv({ cls: "spacer" });
      this.sides.forEach(([side, iconName]) => {
        edgeList = edgeList || this.sides.map((side2) => side2[0]);
        const edgeSideContainer = container.createDiv({ cls: "edge-side" });
        const sideIconContainer = edgeSideContainer.createDiv({ cls: "side-icon" });
        (0, import_obsidian54.setIcon)(sideIconContainer, iconName);
        const sideTogglerContainer = new import_obsidian54.ToggleComponent(edgeSideContainer);
        sideTogglerContainer.setValue(edgeList.includes(side));
        sideTogglerContainer.onChange((value) => value ? edgeList.push(side) : edgeList.remove(side));
      });
    };
    this.buildLabelsContainer = (container, labels, title) => {
      container.replaceChildren(...[]);
      container.createDiv({ cls: "label", text: title });
      labels.forEach((label) => {
        const labelContainer = container.createDiv({ cls: "item chip", text: label });
        new import_obsidian54.ButtonComponent(labelContainer).setIcon("x-circle").setClass("item-remove").onClick(() => {
          labels.remove(label);
          container.removeChild(labelContainer);
        });
      });
    };
    this.buildNewLabelContainer = (currentLabelsContainer, currentLabelsTitle, newLabelContainer, labels, title) => {
      newLabelContainer.createDiv({ cls: "label", text: title });
      newLabelContainer.createDiv({ cls: "spacer" });
      const labelInput = new import_obsidian54.TextComponent(newLabelContainer);
      const labelValidate = new import_obsidian54.ButtonComponent(newLabelContainer);
      labelInput.onChange((value) => value ? labelValidate.setCta() : labelValidate.removeCta());
      labelValidate.setIcon("plus-circle");
      labelValidate.onClick(() => {
        labels.push(labelInput.getValue());
        this.buildLabelsContainer(currentLabelsContainer, labels, currentLabelsTitle);
        labelInput.setValue("");
        labelValidate.removeCta();
      });
    };
    this.createCanvasPathContainer = (container) => {
      container.createDiv({ text: `Path of the canvas`, cls: "label" });
      const canvasPathInput = new import_obsidian54.TextComponent(container);
      canvasPathInput.inputEl.addClass("full-width");
      canvasPathInput.inputEl.addClass("with-label");
      new FileSuggest(
        canvasPathInput.inputEl,
        this.plugin,
        "/",
        "canvas"
      );
      const canvasPath = this.field.options.canvasPath;
      canvasPathInput.setValue(canvasPath || "");
      canvasPathInput.setPlaceholder("Path/of/the/file.canvas");
      canvasPathInput.onChange((value) => {
        FieldSettingsModal.removeValidationError(canvasPathInput);
        this.field.options.canvasPath = value;
      });
      this.canvasPathInput = canvasPathInput;
    };
    this.createDirectionContainer = (container, title) => {
      container.createDiv({ text: title, cls: "label" });
      container.createDiv({ cls: "spacer" });
      const directionSelection = new import_obsidian54.DropdownComponent(container);
      [
        ["incoming", "Incoming"],
        ["outgoing", "Outgoing"],
        ["bothsides", "Both sides"]
      ].forEach(([direction, label]) => directionSelection.addOption(direction, label));
      directionSelection.setValue(this.field.options.direction || "incoming");
      directionSelection.onChange((value) => this.field.options.direction = value);
    };
    this.createDvQueryContainer = (container, title) => {
      container.createEl("span", { text: title });
      container.createEl("span", { text: "Dataview query returning a list of files (<dv> object is available)", cls: "sub-text" });
      const filesFromDVQueryContainer = container.createDiv({ cls: "field-container" });
      const filesFromDVQuery = new import_obsidian54.TextAreaComponent(filesFromDVQueryContainer);
      filesFromDVQuery.inputEl.addClass("full-width");
      filesFromDVQuery.inputEl.cols = 65;
      filesFromDVQuery.inputEl.rows = 3;
      filesFromDVQuery.setPlaceholder("ex: dv.pages('#student')");
      filesFromDVQuery.setValue(this.field.options.filesFromDVQuery || "");
      filesFromDVQuery.onChange((value) => {
        this.field.options.filesFromDVQuery = value;
      });
    };
  }
};

// src/fields/fieldManagers/CanvasField.ts
var CanvasField = class extends AbstractListBasedField2 {
  constructor(plugin, field) {
    super(plugin, field, "Canvas" /* Canvas */);
  }
  displayValue(container, file, value, onClick) {
    const values = Array.isArray(value) ? value : [value];
    values.forEach((value2, i) => {
      const link = getLink(value2, file);
      if (link == null ? void 0 : link.path) {
        const linkText = link.path.split("/").last() || "";
        const linkEl = container.createEl("a", { text: linkText.replace(/(.*).md/, "$1") });
        linkEl.onclick = () => {
          this.plugin.app.workspace.openLinkText(value2.path, file.path, true);
          onClick();
        };
      } else {
        container.createDiv({ text: value2 });
      }
      if (i < values.length - 1) {
        container.createEl("span", { text: " | " });
      }
    });
    container.createDiv();
  }
  addFieldOption(file, location, indexedPath) {
  }
  async createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote) {
    await postValues(
      this.plugin,
      [{ id: indexedPath || this.field.id, payload: { value: "" } }],
      file,
      lineNumber,
      asList,
      asBlockquote
    );
  }
  createDvField(dv, p, fieldContainer, attrs) {
    const fieldValue = dv.el("span", p[this.field.name], attrs);
    fieldContainer.appendChild(fieldValue);
  }
  createSettingContainer(container, plugin, location) {
    const options2 = this.field.options;
    options2.direction = options2.direction || "bothsides";
    options2.nodeColors = options2.nodeColors || [];
    options2.edgeColors = options2.edgeColors || [];
    options2.edgeFromSides = options2.edgeFromSides || [];
    options2.edgeToSides = options2.edgeToSides || [];
    options2.edgeLabels = options2.edgeLabels || [];
    const canvasPathContainer = container.createDiv({ cls: "field-container" });
    container.createEl("hr");
    const directionContainer = container.createDiv({ cls: "field-container" });
    const edgeColorsContainer = container.createDiv({ cls: "field-container colors" });
    const edgeFromSidesContainer = container.createDiv({ cls: "field-container edges" });
    container.createDiv({ cls: "sub-text", text: "No edge selected is equivalent to all edges selected" });
    const edgeToSidesContainer = container.createDiv({ cls: "field-container egdes" });
    container.createDiv({ cls: "sub-text", text: "No edge selected is equivalent to all edges selected" });
    const edgeLabelsContainer = container.createDiv({ cls: "field-container labels" });
    const newEdgeLabelContainer = container.createDiv({ cls: "field-container" });
    container.createEl("hr");
    const nodeColorsContainer = container.createDiv({ cls: "field-container colors" });
    const filesFromDVQueryTopContainer = container.createDiv({ cls: "vstacked" });
    this.createCanvasPathContainer(canvasPathContainer);
    this.createDirectionContainer(directionContainer, `Direction of the edges pointing to those nodes`);
    this.createDvQueryContainer(filesFromDVQueryTopContainer, "Matching files");
    this.buildColorsContainer(nodeColorsContainer, options2.nodeColors, "Node matching colors:");
    this.buildColorsContainer(edgeColorsContainer, options2.edgeColors, "Edge matching colors:");
    this.buildEdgeSideContainer(edgeFromSidesContainer, options2.edgeFromSides, "Edges matchin From side:");
    this.buildEdgeSideContainer(edgeToSidesContainer, options2.edgeToSides, "Edges matchin To side:");
    this.buildLabelsContainer(edgeLabelsContainer, options2.edgeLabels, "Edges matching labels: ");
    this.buildNewLabelContainer(edgeLabelsContainer, "Edges matching labels: ", newEdgeLabelContainer, options2.edgeLabels, "Add a new matching edge label");
  }
  getOptionsStr() {
    return "";
  }
  validateOptions() {
    var _a;
    let error = false;
    if (!((_a = this.field.options.canvasPath) == null ? void 0 : _a.endsWith(".canvas"))) {
      error = true;
      FieldSettingsModal.setValidationError(
        this.canvasPathInput,
        "This is not a canvas file"
      );
    }
    return !error;
  }
};

// src/fields/fieldManagers/CanvasGroupField.ts
var CanvasGroupField = class extends AbstractListBasedField2 {
  constructor(plugin, field) {
    super(plugin, field, "CanvasGroup" /* CanvasGroup */);
  }
  addFieldOption(file, location, indexedPath) {
  }
  async createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote) {
    await postValues(this.plugin, [{ id: indexedPath || this.field.id, payload: { value: "" } }], file, lineNumber, asList, asBlockquote);
  }
  createDvField(dv, p, fieldContainer, attrs) {
    const fieldValue = dv.el("span", p[this.field.name], attrs);
    fieldContainer.appendChild(fieldValue);
  }
  createSettingContainer(container, plugin, location) {
    const options2 = this.field.options;
    options2.groupColors = options2.groupColors || [];
    options2.groupLabels = options2.groupLabels || [];
    const canvasPathContainer = container.createDiv({ cls: "field-container" });
    container.createEl("hr");
    const groupColorsContainer = container.createDiv({ cls: "field-container colors" });
    const groupLabelsContainer = container.createDiv({ cls: "field-container labels" });
    const newLabelContainer = container.createDiv({ cls: "field-container" });
    this.createCanvasPathContainer(canvasPathContainer);
    this.buildColorsContainer(groupColorsContainer, options2.groupColors, "Groups matching colors:");
    this.buildLabelsContainer(groupLabelsContainer, options2.groupLabels, "Groups matching labels: ");
    this.buildNewLabelContainer(groupLabelsContainer, "Groups matching labels: ", newLabelContainer, options2.groupLabels, "Add a new matching group name");
  }
  getOptionsStr() {
    return "";
  }
  validateOptions() {
    var _a;
    let error = false;
    if (!((_a = this.field.options.canvasPath) == null ? void 0 : _a.endsWith(".canvas"))) {
      error = true;
      FieldSettingsModal.setValidationError(
        this.canvasPathInput,
        "This is not a canvas file"
      );
    }
    return !error;
  }
};

// src/fields/fieldManagers/CanvasGroupLinkField.ts
var CanvasGroupLinkField = class extends AbstractListBasedField2 {
  constructor(plugin, field) {
    super(plugin, field, "CanvasGroupLink" /* CanvasGroupLink */);
  }
  addFieldOption(file, location, indexedPath) {
  }
  async createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote) {
    await postValues(this.plugin, [{ id: indexedPath || this.field.id, payload: { value: "" } }], file, lineNumber, asList, asBlockquote);
  }
  createDvField(dv, p, fieldContainer, attrs) {
    const fieldValue = dv.el("span", p[this.field.name], attrs);
    fieldContainer.appendChild(fieldValue);
  }
  createSettingContainer(container, plugin, location) {
    const options2 = this.field.options;
    options2.groupColors = options2.groupColors || [];
    options2.nodeColors = options2.nodeColors || [];
    options2.edgeColors = options2.edgeColors || [];
    options2.edgeFromSides = options2.edgeFromSides || [];
    options2.edgeToSides = options2.edgeToSides || [];
    options2.groupLabels = options2.groupLabels || [];
    options2.edgeLabels = options2.edgeLabels || [];
    options2.direction = options2.direction || "bothsides";
    const canvasPathContainer = container.createDiv({ cls: "field-container" });
    const groupColorsContainer = container.createDiv({ cls: "field-container colors" });
    const groupLabelsContainer = container.createDiv({ cls: "field-container labels" });
    const newGroupLabelContainer = container.createDiv({ cls: "field-container" });
    container.createEl("hr");
    const directionContainer = container.createDiv({ cls: "field-container" });
    const edgeColorsContainer = container.createDiv({ cls: "field-container colors" });
    const edgeFromSidesContainer = container.createDiv({ cls: "field-container edges" });
    container.createDiv({ cls: "sub-text", text: "No edge selected is equivalent to all edges selected" });
    const edgeToSidesContainer = container.createDiv({ cls: "field-container egdes" });
    container.createDiv({ cls: "sub-text", text: "No edge selected is equivalent to all edges selected" });
    const edgeLabelsContainer = container.createDiv({ cls: "field-container labels" });
    const newEdgeLabelContainer = container.createDiv({ cls: "field-container" });
    container.createEl("hr");
    const nodeColorsContainer = container.createDiv({ cls: "field-container colors" });
    const filesFromDVQueryTopContainer = container.createDiv({ cls: "vstacked" });
    const groupLabelsTitle = "Groups matching labels: ";
    const edgeLabelsTitle = "Edges matching labels: ";
    this.createCanvasPathContainer(canvasPathContainer);
    this.createDirectionContainer(directionContainer, `Direction of the edges pointing to those groups`);
    this.createDvQueryContainer(filesFromDVQueryTopContainer, "Matching files connected to those groups");
    this.buildColorsContainer(groupColorsContainer, options2.groupColors, "Groups matching colors:");
    this.buildColorsContainer(nodeColorsContainer, options2.nodeColors, "Groups' connected nodes matching colors:");
    this.buildColorsContainer(edgeColorsContainer, options2.edgeColors, "Groups' edges matching colors:");
    this.buildLabelsContainer(groupLabelsContainer, options2.groupLabels, groupLabelsTitle);
    this.buildLabelsContainer(edgeLabelsContainer, options2.edgeLabels, edgeLabelsTitle);
    this.buildEdgeSideContainer(edgeFromSidesContainer, options2.edgeFromSides, "Groups' edges matchin From side:");
    this.buildEdgeSideContainer(edgeToSidesContainer, options2.edgeToSides, "Groups' edges matchin To side:");
    this.buildNewLabelContainer(groupLabelsContainer, groupLabelsTitle, newGroupLabelContainer, options2.groupLabels, "Add a new matching group name");
    this.buildNewLabelContainer(edgeLabelsContainer, edgeLabelsTitle, newEdgeLabelContainer, options2.edgeLabels, "Add a new matching edge label");
  }
  getOptionsStr() {
    return "";
  }
  validateOptions() {
    var _a;
    let error = false;
    if (!((_a = this.field.options.canvasPath) == null ? void 0 : _a.endsWith(".canvas"))) {
      error = true;
      FieldSettingsModal.setValidationError(
        this.canvasPathInput,
        "This is not a canvas file"
      );
    }
    return !error;
  }
};

// src/fields/fieldManagers/YAMLField.ts
var import_language2 = require("@codemirror/language");

// src/fields/fieldManagers/AbstractRawObjectField.ts
var import_obsidian55 = require("obsidian");

// node_modules/codemirror/dist/index.js
var import_view = require("@codemirror/view");
var import_view2 = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_language = require("@codemirror/language");
var import_commands = require("@codemirror/commands");
var import_search = require("@codemirror/search");
var import_autocomplete = require("@codemirror/autocomplete");
var import_lint = require("@codemirror/lint");
var basicSetup = /* @__PURE__ */ (() => [
  (0, import_view.lineNumbers)(),
  (0, import_view.highlightActiveLineGutter)(),
  (0, import_view.highlightSpecialChars)(),
  (0, import_commands.history)(),
  (0, import_language.foldGutter)(),
  (0, import_view.drawSelection)(),
  (0, import_view.dropCursor)(),
  import_state.EditorState.allowMultipleSelections.of(true),
  (0, import_language.indentOnInput)(),
  (0, import_language.syntaxHighlighting)(import_language.defaultHighlightStyle, { fallback: true }),
  (0, import_language.bracketMatching)(),
  (0, import_autocomplete.closeBrackets)(),
  (0, import_autocomplete.autocompletion)(),
  (0, import_view.rectangularSelection)(),
  (0, import_view.crosshairCursor)(),
  (0, import_view.highlightActiveLine)(),
  (0, import_search.highlightSelectionMatches)(),
  import_view.keymap.of([
    ...import_autocomplete.closeBracketsKeymap,
    ...import_commands.defaultKeymap,
    ...import_search.searchKeymap,
    ...import_commands.historyKeymap,
    ...import_language.foldKeymap,
    ...import_autocomplete.completionKeymap,
    ...import_lint.lintKeymap
  ])
])();

// src/modals/fields/RawObjectModal.ts
var import_lint2 = require("@codemirror/lint");
var import_state2 = require("@codemirror/state");
var RawObjectModal = class extends BaseModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    var _a;
    super(plugin, file, previousModal, indexedPath);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.value = ((_a = this.eF) == null ? void 0 : _a.value) || "";
    this.buildPositionContainer();
    this.buildInputEl(this.contentEl.createDiv({ cls: "field-container" }));
    cleanActions(this.contentEl, ".footer-actions");
    this.buildFooterBtn();
    this.containerEl.addClass("metadata-menu");
  }
  onOpen() {
    super.onOpen();
  }
  buildPositionContainer() {
    this.positionContainer = this.contentEl.createDiv({ cls: "field-container" });
    this.positionContainer.textContent = "Position: ";
  }
  buildInputEl(container) {
    const manager = new FieldManager[this.field.type](this.plugin, this.field);
    const getPosition = (state) => {
      const range = state.selection.ranges.filter((range2) => range2.empty).first();
      const position = (range == null ? void 0 : range.from) || 0;
      const line = state.doc.lineAt((range == null ? void 0 : range.head) || 0);
      const col = ((range == null ? void 0 : range.head) || 0) - line.from;
      this.positionContainer.textContent = `Line: ${line.number} | Col: ${col} | Position: ${position}`;
    };
    const positionChange = import_state2.StateField.define({
      create: (state) => getPosition(state),
      update(value, tr) {
        getPosition(tr.state);
      }
    });
    const gutter = (0, import_lint2.lintGutter)();
    this.editor = new import_view2.EditorView({
      doc: manager.dumpValue(manager.loadValue(this.value)),
      extensions: [
        basicSetup,
        gutter,
        positionChange,
        manager.getExtraExtensions()
      ],
      parent: container
    });
  }
  async save() {
    const newContent = this.editor.state.doc.toString().trim();
    await postValues(this.plugin, [{ id: this.indexedPath || this.field.id, payload: { value: newContent } }], this.file, this.lineNumber, this.asList, this.asBlockquote);
    this.saved = true;
    if (this.previousModal)
      await this.goToPreviousModal();
    this.close();
  }
};

// src/fields/fieldManagers/AbstractRawObjectField.ts
var RawObjectField = class extends FieldManager2 {
  constructor(plugin, field, type) {
    super(plugin, field, type);
  }
  getOptionsStr() {
    return this.field.options.template || "";
  }
  async buildAndOpenModal(file, indexedPath) {
    const eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
    const modal = new RawObjectModal(this.plugin, file, this.field, eF, indexedPath);
    modal.open();
  }
  addFieldOption(file, location, indexedPath) {
    const name = this.field.name;
    const iconName = FieldIcon[this.type];
    const action = async () => this.buildAndOpenModal(file, indexedPath);
    if (RawObjectField.isSuggest(location)) {
      location.options.push({
        id: `update_${name}`,
        actionLabel: `<span>Update <b>${name}</b></span>`,
        action,
        icon: iconName
      });
    } else if (RawObjectField.isFieldOptions(location)) {
      location.addOption(FieldIcon[this.type], action, `Update ${name}'s value`);
    }
  }
  createSettingContainer(container, plugin) {
  }
  validateOptions() {
    return true;
  }
  createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = new RawObjectModal(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.titleEl.setText(`Enter value for ${selectedFieldName}`);
    fieldModal.open();
  }
  createDvField(dv, p, fieldContainer, attrs = {}) {
    var _a, _b;
    attrs.cls = "value-container";
    const fieldValue = dv.el("span", p[this.field.name] || "", attrs);
    fieldContainer.appendChild(fieldValue);
    const editBtn = fieldContainer.createEl("button");
    const spacer = fieldContainer.createDiv({ cls: "spacer-1" });
    if ((_a = attrs.options) == null ? void 0 : _a.alwaysOn)
      spacer.hide();
    (0, import_obsidian55.setIcon)(editBtn, FieldIcon["Input" /* Input */]);
    if (!((_b = attrs == null ? void 0 : attrs.options) == null ? void 0 : _b.alwaysOn)) {
      editBtn.hide();
      spacer.show();
      fieldContainer.onmouseover = () => {
        editBtn.show();
        spacer.hide();
      };
      fieldContainer.onmouseout = () => {
        var _a2;
        editBtn.hide();
        if (!((_a2 = attrs.options) == null ? void 0 : _a2.alwaysOn))
          spacer.show();
      };
    }
    editBtn.onclick = async () => {
      const file = this.plugin.app.vault.getAbstractFileByPath(p.file.path);
      if (file instanceof import_obsidian55.TFile && file.extension === "md") {
        await this.buildAndOpenModal(file);
      }
      fieldValue.hide();
      editBtn.hide();
      spacer.hide();
    };
  }
};

// node_modules/@codemirror/legacy-modes/mode/yaml.js
var cons = ["true", "false", "on", "off", "yes", "no"];
var keywordRegex = new RegExp("\\b((" + cons.join(")|(") + "))$", "i");
var yaml = {
  name: "yaml",
  token: function(stream, state) {
    var ch = stream.peek();
    var esc = state.escaped;
    state.escaped = false;
    if (ch == "#" && (stream.pos == 0 || /\s/.test(stream.string.charAt(stream.pos - 1)))) {
      stream.skipToEnd();
      return "comment";
    }
    if (stream.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
      return "string";
    if (state.literal && stream.indentation() > state.keyCol) {
      stream.skipToEnd();
      return "string";
    } else if (state.literal) {
      state.literal = false;
    }
    if (stream.sol()) {
      state.keyCol = 0;
      state.pair = false;
      state.pairStart = false;
      if (stream.match("---")) {
        return "def";
      }
      if (stream.match("...")) {
        return "def";
      }
      if (stream.match(/^\s*-\s+/)) {
        return "meta";
      }
    }
    if (stream.match(/^(\{|\}|\[|\])/)) {
      if (ch == "{")
        state.inlinePairs++;
      else if (ch == "}")
        state.inlinePairs--;
      else if (ch == "[")
        state.inlineList++;
      else
        state.inlineList--;
      return "meta";
    }
    if (state.inlineList > 0 && !esc && ch == ",") {
      stream.next();
      return "meta";
    }
    if (state.inlinePairs > 0 && !esc && ch == ",") {
      state.keyCol = 0;
      state.pair = false;
      state.pairStart = false;
      stream.next();
      return "meta";
    }
    if (state.pairStart) {
      if (stream.match(/^\s*(\||\>)\s*/)) {
        state.literal = true;
        return "meta";
      }
      ;
      if (stream.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i)) {
        return "variable";
      }
      if (state.inlinePairs == 0 && stream.match(/^\s*-?[0-9\.\,]+\s?$/)) {
        return "number";
      }
      if (state.inlinePairs > 0 && stream.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/)) {
        return "number";
      }
      if (stream.match(keywordRegex)) {
        return "keyword";
      }
    }
    if (!state.pair && stream.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/)) {
      state.pair = true;
      state.keyCol = stream.indentation();
      return "atom";
    }
    if (state.pair && stream.match(/^:\s*/)) {
      state.pairStart = true;
      return "meta";
    }
    state.pairStart = false;
    state.escaped = ch == "\\";
    stream.next();
    return null;
  },
  startState: function() {
    return {
      pair: false,
      pairStart: false,
      keyCol: 0,
      inlinePairs: 0,
      inlineList: 0,
      literal: false,
      escaped: false
    };
  },
  languageData: {
    commentTokens: { line: "#" }
  }
};

// src/fields/fieldManagers/YAMLField.ts
var import_lint3 = require("@codemirror/lint");

// node_modules/yaml/browser/dist/nodes/identity.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

// node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    await visitAsync_(null, node, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK;
visitAsync.SKIP = SKIP;
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
  const ctrl = await callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visitAsync_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = await visitAsync_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = await visitAsync_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = await visitAsync_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node, path);
  if (isSeq(node))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node, path);
  if (isPair(node))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node, path);
  if (isScalar(node))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node, path);
  if (isAlias(node))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml2, tags2) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml2);
    this.tags = Object.assign({}, Directives.defaultTags, tags2);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags2 = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags2[node.tag] = true;
      });
      tagNames = Object.keys(tags2);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx == null ? void 0 : ctx.keep))
    return Number(value);
  return value;
}

// node_modules/yaml/browser/dist/nodes/Node.js
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
};

// node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source);
    if (!data) {
      toJS(source, null, ctx);
      data = anchors.get(source);
    }
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return (ctx == null ? void 0 : ctx.keep) ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags2) {
  var _a;
  if (tagName) {
    const match = tags2.filter((t) => t.tag === tagName);
    const tagObj = (_a = match.find((t) => !t.format)) != null ? _a : match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags2.find((t) => {
    var _a2;
    return ((_a2 = t.identify) == null ? void 0 : _a2.call(t, value)) && !t.format;
  });
}
function createNode(value, tagName, ctx) {
  var _a, _b, _c;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : typeof ((_c = tagObj == null ? void 0 : tagObj.nodeClass) == null ? void 0 : _c.from) === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
Collection.maxFlowStringSingleLineLength = 60;

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end2 = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end2 = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end2 = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end2 = i + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end2) {
        if (split) {
          folds.push(split);
          end2 = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end2 = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end3 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end3)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end3)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i) {
  let ch = text[i + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i += 1];
    } while (ch && ch !== "\n");
    ch = text[i + 1];
  }
  return i;
}

// node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start2 = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start2 > limit)
        return true;
      start2 = i + 1;
      if (strLen - start2 <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json2 = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json2;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start2 = 0;
  for (let i = 0, ch = json2[i]; ch; ch = json2[++i]) {
    if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
      str += json2.slice(start2, i) + "\\ ";
      i += 1;
      start2 = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json2[i + 1]) {
        case "u":
          {
            str += json2.slice(start2, i);
            const code = json2.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json2.substr(i, 6);
            }
            i += 5;
            start2 = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json2.slice(start2, i) + "\n\n";
            while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json2[i + 2] === " ")
              str += "\\";
            i += 1;
            start2 = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start2 ? str + json2.slice(start2) : json2;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
var blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch (e) {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end2 = value.substring(endStart);
  const endNlPos = end2.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end2 || endNlPos !== end2.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end2) {
    value = value.slice(0, -end2.length);
    if (end2[end2.length - 1] === "\n")
      end2 = end2.slice(0, -1);
    end2 = end2.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start2 = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start2) {
    value = value.substring(start2.length);
    start2 = start2.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start2}${value}${end2}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start2}${value}${end2}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str));
    };
    const { compat, tags: tags2 } = ctx.doc.schema;
    if (tags2.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options2) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options2);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags2, item) {
  var _a, _b, _c, _d;
  if (item.tag) {
    const match = tags2.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return (_a = match.find((t) => t.format === item.format)) != null ? _a : match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags2.filter((t) => {
      var _a2;
      return (_a2 = t.identify) == null ? void 0 : _a2.call(t, obj);
    });
    tagObj = (_b = match.find((t) => t.format === item.format)) != null ? _b : match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags2.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = (_d = (_c = obj == null ? void 0 : obj.constructor) == null ? void 0 : _c.name) != null ? _d : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a, _b;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = ((_b = ctx.indentAtStart) != null ? _b : 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  var _a, _b;
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = (_b = (_a = ctx.inFlow) != null ? _a : value.flow) != null ? _b : value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
var MERGE_KEY = "<<";
function addPairToJSMap(ctx, map2, { key, value }) {
  if ((ctx == null ? void 0 : ctx.doc.schema.merge) && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
var isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && (ctx == null ? void 0 : ctx.doc)) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return (ctx == null ? void 0 : ctx.doc) ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options2) {
  var _a;
  const flow = (_a = ctx.inFlow) != null ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options2);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && (ik == null ? void 0 : ik.comment)) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start: start2, end: end2 } = flowChars;
  if (lines.length === 0) {
    str = start2 + end2;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start2;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end2}`;
    } else {
      str = `${start2}${fcPadding}${lines.join(" ")}${fcPadding}${end2}`;
    }
  }
  if (comment) {
    str += lineComment(str, indent, commentString(comment));
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema4, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema4);
    const add = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema4.sortMapEntries === "function") {
      map2.items.sort(schema4.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    var _a;
    const it = findPair(this.items, key);
    const node = it == null ? void 0 : it.value;
    return (_a = !keepScalar && isScalar(node) ? node.value : node) != null ? _a : void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type3) {
    const map2 = Type3 ? new Type3() : (ctx == null ? void 0 : ctx.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/yaml/browser/dist/schema/common/map.js
var map = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: (schema4, obj, ctx) => YAMLMap.from(schema4, obj, ctx)
};

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema4, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema4);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/yaml/browser/dist/schema/common/seq.js
var seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema4, obj, ctx) => YAMLSeq.from(schema4, obj, ctx)
};

// node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset2, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset2), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int2 = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int2,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  var _a;
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = (_a = pair.value) != null ? _a : pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx == null ? void 0 : ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema4, iterable, ctx) => YAMLOMap.from(schema4, iterable, ctx)
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset2, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset2 += 1;
  str = str.substring(offset2).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int3 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema4, iterable, ctx) => YAMLSet.from(schema4, iterable, ctx),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int3,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int: int2,
  intHex,
  intOct,
  intTime,
  map,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags2 = schemas.get(schemaName);
  if (!tags2) {
    if (Array.isArray(customTags))
      tags2 = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags2 = tags2.concat(tag);
  } else if (typeof customTags === "function") {
    tags2 = customTags(tags2.slice());
  }
  return tags2.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults != null ? toStringDefaults : null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options2) {
  var _a;
  const lines = [];
  let hasDirectives = options2.directives === true;
  if (options2.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options2);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}

// node_modules/yaml/browser/dist/doc/Document.js
var Document = class {
  constructor(value, replacer, options2) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options2 === void 0 && replacer) {
      options2 = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    }, options2);
    this.options = opt;
    let { version } = opt;
    if (options2 == null ? void 0 : options2._directives) {
      this.directives = options2._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options2);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options2);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options2) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options2 === void 0 && replacer) {
      options2 = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options2 != null ? options2 : {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects != null ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined != null ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options2 = {}) {
    const k = this.createNode(key, null, options2);
    const v = this.createNode(value, null, options2);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (isEmptyPath(path)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options2 = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options2.schema instanceof Object)
      this.schema = options2.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options2));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json2,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg != null ? jsonArg : "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options2 = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
      const s = JSON.stringify(options2.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options2);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end2 = error.linePos[1];
    if (end2 && end2.line === line && end2.col > col) {
      count = Math.max(1, Math.min(end2.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset: offset2, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start2 = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start2 === null)
          start2 = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start2 === null)
          start2 = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow != null ? flow : "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end2 = last ? last.offset + last.source.length : offset2;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end: end2,
    start: start2 != null ? start2 : end2
  };
}

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end2 = fc.end[0];
    if (end2.indent === indent && (end2.source === "]" || end2.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end2, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag) {
  var _a, _b;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset2 = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start: start2, key, sep, value } = collItem;
    const keyProps = resolveProps(start2, {
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset: offset2,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset2, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset2, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key != null ? key : start2[start2.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_b = keyProps.found) == null ? void 0 : _b.indent) !== bm.indent) {
      onError(offset2, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start2, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep != null ? sep : [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset2 = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value == null ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset2, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset2, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset2 = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset2)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset2, commentEnd != null ? commentEnd : offset2];
  return map2;
}

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag) {
  var _a;
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset2 = bs.offset;
  let commentEnd = null;
  for (const { start: start2, value } of bs.items) {
    const props = resolveProps(start2, {
      indicator: "seq-item-ind",
      next: value,
      offset: offset2,
      onError,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset2, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start2, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset2 = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset2, commentEnd != null ? commentEnd : offset2];
  return seq2;
}

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end2, offset2, reqSpace, onError) {
  let comment = "";
  if (end2) {
    let hasSpace = false;
    let sep = "";
    for (const token of end2) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset2 += source.length;
    }
  }
  return { comment, offset: offset2 };
}

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag) {
  var _a, _b;
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = (_a = tag == null ? void 0 : tag.nodeClass) != null ? _a : isMap2 ? YAMLMap : YAMLSeq;
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset2 = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start: start2, key, sep, value } = collItem;
    const props = resolveProps(start2, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key != null ? key : sep == null ? void 0 : sep[0],
      offset: offset2,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset2 = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start2) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = (_b = prev.value) != null ? _b : prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset2 = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start2, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep != null ? sep : [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset2 = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset2;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset2, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end2 = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end2.comment) {
      if (coll.comment)
        coll.comment += "\n" + end2.comment;
      else
        coll.comment = end2.comment;
    }
    coll.range = [fc.offset, cePos, end2.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/yaml/browser/dist/compose/compose-collection.js
function resolveCollection(CN2, ctx, token, onError, tagName, tag) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag) : resolveFlowCollection(CN2, ctx, token, onError, tag);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, tagToken, onError) {
  var _a, _b;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq" || !expType) {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      if (kt == null ? void 0 : kt.collection) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag);
  const res = (_b = (_a = tag.resolve) == null ? void 0 : _a.call(tag, coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options)) != null ? _b : coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start2 = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start2, start2, start2] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end3 = start2 + header.length;
    if (scalar.source)
      end3 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start2, end3, end3] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset2 = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset2 + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset2 += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset2 += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset2 - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end2 = start2 + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start2, end2, end2] };
}
function parseBlockScalarHeader({ offset: offset2, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset2 + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset: offset2, type, source, end: end2 } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset2 + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset2, offset2 + source.length, offset2 + source.length]
      };
  }
  const valueEnd = offset2 + source.length;
  const re = resolveEnd(end2, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset2, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  var _a;
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + ((_a = match == null ? void 0 : match[1]) != null ? _a : "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset: offset2 } = foldNewline(source, i);
      res += fold;
      i = offset2;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset2) {
  let fold = "";
  let ch = source[offset2 + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset2 + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset2 += 1;
    ch = source[offset2 + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset: offset2 };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset2, length, onError) {
  const cc = source.substr(offset2, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset2 - 2, length + 2);
    onError(offset2 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken != null ? tagToken : token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  var _a;
  const tag = schema4.tags.find((tag2) => {
    var _a2;
    return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = (_a = schema4.compat.find((tag2) => {
      var _a2;
      return tag2.default && ((_a2 = tag2.test) == null ? void 0 : _a2.test(value));
    })) != null ? _a : schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset2, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset2 -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st == null ? void 0 : st.type) === "space") {
        offset2 += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset2;
}

// node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset2, before, pos, { spaceBefore, comment, anchor, tag, end: end2 }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset2, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end2;
  }
  return node;
}
function composeAlias({ options: options2 }, { offset: offset2, source, end: end2 }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset2, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset2 + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset2 + source.length;
  const re = resolveEnd(end2, valueEnd, options2.strict, onError);
  alias.range = [offset2, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options2, directives, { offset: offset2, start: start2, value, end: end2 }, onError) {
  const opts = Object.assign({ _directives: directives }, options2);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start2, {
    indicator: "doc-start",
    next: value != null ? value : end2 == null ? void 0 : end2[0],
    offset: offset2,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start2, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end2, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset2, contentEnd, re.offset];
  return doc;
}

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset: offset2, source } = src;
  return [offset2, offset2 + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) == null ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options2 = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options2.version || "1.2" });
    this.options = options2;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset2, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset2;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end2 = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end2.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end2.comment}` : end2.comment;
        }
        this.doc.range[2] = end2.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index] of path) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = "0123456789ABCDEFabcdef".split("");
var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
var invalidFlowScalarChars = ",[]{}".split("");
var invalidAnchorChars = " ,[]{}\n\r	".split("");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    var _a;
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = (_a = this.next) != null ? _a : "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset2) {
    let ch = this.buffer[offset2];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset2];
      if (ch === "\r") {
        const next = this.buffer[indent + offset2 + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset2 + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset2 + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset2, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset2 + 3]))
        return -1;
    }
    return offset2;
  }
  getLine() {
    let end2 = this.lineEndPos;
    if (typeof end2 !== "number" || end2 !== -1 && end2 < this.pos) {
      end2 = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end2;
    }
    if (end2 === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end2 - 1] === "\r")
      end2 -= 1;
    return this.buffer.substring(this.pos, end2);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if (s === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end2 = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end2 !== -1 && this.buffer[end2 + 1] === "'")
        end2 = this.buffer.indexOf("'", end2 + 2);
    } else {
      while (end2 !== -1) {
        let n = 0;
        while (this.buffer[end2 - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end2 = this.buffer.indexOf('"', end2 + 1);
      }
    }
    const qb = this.buffer.substring(0, end2);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end2 = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end2 === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end2 = this.buffer.length;
    }
    yield* this.pushToIndex(end2 + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i = this.pos; ch = this.buffer[i]; ++i) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i = nl - 1;
        let ch2 = this.buffer[i];
        if (ch2 === "\r")
          ch2 = this.buffer[--i];
        const lastChar = i;
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i];
        if (ch2 === "\n" && i >= this.pos && i + 1 + indent > lastChar)
          nl = i;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end2 = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end2 = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end2 = i;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end2 = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end2 + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset2) => this.lineStarts.push(offset2);
    this.linePos = (offset2) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset2)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset2)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset2 };
      const start2 = this.lineStarts[low - 1];
      return { line: low, col: offset2 - start2 + 1 };
    };
  }
};

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  var _a;
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return (_a = it.sep) != null ? _a : it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top2 = this.peek(1);
    if (this.type === "doc-end" && (!top2 || top2.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top2)
      return yield* this.stream();
    switch (top2.type) {
      case "document":
        return yield* this.document(top2);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top2);
      case "block-scalar":
        return yield* this.blockScalar(top2);
      case "block-map":
        return yield* this.blockMap(top2);
      case "block-seq":
        return yield* this.blockSequence(top2);
      case "flow-collection":
        return yield* this.flowCollection(top2);
      case "doc-end":
        return yield* this.documentEnd(top2);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error != null ? error : this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top2 = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top2 ? top2.indent : 0;
      } else if (token.type === "flow-collection" && top2.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top2.type) {
        case "document":
          top2.value = token;
          break;
        case "block-scalar":
          top2.props.push(token);
          break;
        case "block-map": {
          const it = top2.items[top2.items.length - 1];
          if (it.value) {
            top2.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top2.items[top2.items.length - 1];
          if (it.value)
            top2.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top2.items[top2.items.length - 1];
          if (!it || it.value)
            top2.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top2.type === "document" || top2.type === "block-map" || top2.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top2.type === "document")
            top2.end = last.start;
          else
            top2.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start2 = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start: start2, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end2 = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end2 == null ? void 0 : end2.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end2 = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end2)) {
              Array.prototype.push.apply(end2, it.start);
              end2.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map2.indent && it.sep;
      let start2 = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start2 = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start2.push(this.sourceToken);
            map2.items.push({ start: start2 });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
            it.start.push(this.sourceToken);
          } else if (atNextItem || it.value) {
            start2.push(this.sourceToken);
            map2.items.push({ start: start2 });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (includesToken(it.start, "explicit-key-ind")) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start3 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start3, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start3 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep = it.sep;
              sep.push(this.sourceToken);
              delete it.key, delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start3, key, sep }]
              });
            } else if (start2.length > 0) {
              it.sep = it.sep.concat(start2, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start: start2, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start: start2, key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
              map2.items.push({ start: start2 });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end2 = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end2) ? end2[end2.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end2 == null ? void 0 : end2.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end2 = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end2)) {
              Array.prototype.push.apply(end2, it.start);
              end2.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top2;
      do {
        yield* this.pop();
        top2 = this.peek(1);
      } while (top2 && top2.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start2 = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start: start2, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start2 = getFirstKeyStartProps(prev);
        start2.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: start2 }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start2 = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: start2, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start2, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start2.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options2) {
  const prettyErrors = options2.prettyErrors !== false;
  const lineCounter = options2.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser2 = new Parser(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options2);
  let doc = null;
  for (const _doc of composer.compose(parser2.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options2) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options2 === void 0 && reviver && typeof reviver === "object") {
    options2 = reviver;
  }
  const doc = parseDocument(src, options2);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options2));
}
function stringify3(value, replacer, options2) {
  var _a;
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options2 === void 0 && replacer) {
    options2 = replacer;
  }
  if (typeof options2 === "string")
    options2 = options2.length;
  if (typeof options2 === "number") {
    const indent = Math.round(options2);
    options2 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value === void 0) {
    const { keepUndefined } = (_a = options2 != null ? options2 : replacer) != null ? _a : {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value, _replacer, options2).toString(options2);
}

// src/fields/fieldManagers/YAMLField.ts
var YAMLField = class extends RawObjectField {
  constructor(plugin, field) {
    super(plugin, field, "YAML" /* YAML */);
  }
  dumpValue(value) {
    return `${stringify3(value, { lineWidth: 50 }) || ""}`;
  }
  loadValue(value) {
    try {
      return parse(value.split("\\n").join("\n") || null);
    } catch (e) {
      return value;
    }
  }
  displayValue(container, file, value, onClicked) {
    const valueString = this.dumpValue(value);
    container.setText(`${valueString.slice(0, 50)}${valueString.length > 50 ? "..." : ""}`);
  }
  getExtraExtensions() {
    const yaml2 = new import_language2.LanguageSupport(import_language2.StreamLanguage.define(yaml));
    const yamlLinter = (0, import_lint3.linter)((view) => {
      let diagnostics = [];
      try {
        parse(view.state.doc.toString());
      } catch (e) {
        var loc = e.mark;
        var from = loc ? Math.min(loc.position, view.state.doc.length) : 0;
        var to = from;
        var severity = "error";
        diagnostics.push({ from, to, message: e.message, severity });
      }
      return diagnostics;
    });
    return [yaml2, yamlLinter];
  }
};

// node_modules/@lezer/json/dist/index.js
var import_lr = require("@lezer/lr");
var import_highlight = require("@lezer/highlight");
var jsonHighlighting = (0, import_highlight.styleTags)({
  String: import_highlight.tags.string,
  Number: import_highlight.tags.number,
  "True False": import_highlight.tags.bool,
  PropertyName: import_highlight.tags.propertyName,
  Null: import_highlight.tags.null,
  ",": import_highlight.tags.separator,
  "[ ]": import_highlight.tags.squareBracket,
  "{ }": import_highlight.tags.brace
});
var parser = import_lr.LRParser.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "\u26A0 JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [jsonHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { "JsonText": [0, 1] },
  tokenPrec: 0
});

// node_modules/@codemirror/lang-json/dist/index.js
var import_language3 = require("@codemirror/language");
var jsonLanguage = /* @__PURE__ */ import_language3.LRLanguage.define({
  name: "json",
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ import_language3.indentNodeProp.add({
        Object: /* @__PURE__ */ (0, import_language3.continuedIndent)({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ (0, import_language3.continuedIndent)({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ import_language3.foldNodeProp.add({
        "Object Array": import_language3.foldInside
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function json() {
  return new import_language3.LanguageSupport(jsonLanguage);
}

// src/fields/fieldManagers/JSONField.ts
var import_lint4 = require("@codemirror/lint");
var JSONField = class extends RawObjectField {
  constructor(plugin, field) {
    super(plugin, field, "JSON" /* JSON */);
  }
  dumpValue(value) {
    return `${JSON.stringify(value, null, "  ") || ""}`;
  }
  loadValue(value) {
    try {
      return JSON.parse(value || "{}");
    } catch (e) {
      return value;
    }
  }
  displayValue(container, file, value, onClicked) {
    const valueString = this.dumpValue(value);
    container.setText(`${valueString.slice(0, 50)}${valueString.length > 50 ? "..." : ""}`);
  }
  getExtraExtensions() {
    const jsonLinter = (0, import_lint4.linter)((view) => {
      let diagnostics = [];
      try {
        JSON.parse(view.state.doc.toString());
      } catch (e) {
        var loc = e.mark;
        var from = loc ? Math.min(loc.position, view.state.doc.length) : 0;
        var to = from;
        var severity = "error";
        diagnostics.push({ from, to, message: e.message, severity });
      }
      return diagnostics;
    });
    return [json(), jsonLinter];
  }
};

// src/fields/fieldManagers/ObjectListField.ts
var import_obsidian57 = require("obsidian");

// src/modals/fields/ObjectListModal.ts
var import_obsidian56 = require("obsidian");
var ObjectListModal = class extends BaseSuggestModal {
  constructor(plugin, file, field, eF, indexedPath, lineNumber = -1, asList = false, asBlockquote = false, previousModal) {
    super(plugin, file, eF, indexedPath, previousModal);
    this.plugin = plugin;
    this.file = file;
    this.field = field;
    this.eF = eF;
    this.indexedPath = indexedPath;
    this.lineNumber = lineNumber;
    this.asList = asList;
    this.asBlockquote = asBlockquote;
    this.previousModal = previousModal;
    this.objects = [];
  }
  buildAddButton(container) {
    const infoContainer = container.createDiv({ cls: "info" });
    infoContainer.setText("Alt+Enter to Add");
    const addButton = new import_obsidian56.ButtonComponent(container);
    addButton.setIcon("plus");
    addButton.onClick(async () => {
      this.onAdd();
    });
    addButton.setCta();
    addButton.setTooltip("Add a new item");
  }
  async onAdd() {
    const fieldManager = new FieldManager[this.field.type](this.plugin, this.field);
    if (this.eF) {
      await fieldManager.addObjectListItem(this.file, this.eF, this.indexedPath);
      this.close();
      this.open();
    } else if (this.indexedPath) {
      await postValues(this.plugin, [{ id: this.indexedPath, payload: { value: "" } }], this.file);
      this.close();
      this.open();
    }
  }
  async onOpen() {
    const _eF = await Note.getExistingFieldForIndexedPath(this.plugin, this.file, this.indexedPath);
    this.objects = await (_eF == null ? void 0 : _eF.getChildrenFields(this.plugin, this.file)) || [];
    super.onOpen();
  }
  getSuggestions(query = "") {
    return this.objects;
  }
  renderSuggestion(item, el) {
    const container = el.createDiv({ cls: "value-container" });
    const index = container.createDiv({ cls: "index-container" });
    index.setText(`${item.indexInList}`);
    const valueContainer = container.createDiv({});
    if (item.fields.length) {
      valueContainer.setText(item.fields.map((eF) => {
        if (Array.isArray(eF.value)) {
          return `${eF.value.length} ${eF.field.name}`;
        } else if (typeof eF.value === "object") {
          return `${eF.field.name}: {...}`;
        } else {
          return `${eF.field.name}: ${eF.value}`;
        }
      }).join(" | "));
    } else {
      valueContainer.setText("<--empty-->");
      valueContainer.addClass("empty");
    }
    container.createDiv({ cls: "spacer" });
    const removeContainer = container.createDiv({ cls: "icon-container" });
    (0, import_obsidian56.setIcon)(removeContainer, "trash");
    removeContainer.onclick = () => {
      this.toRemove = item;
    };
  }
  async onChooseSuggestion(item, evt) {
    const reOpen = async () => {
      const eF = await Note.getExistingFieldForIndexedPath(this.plugin, this.file, this.indexedPath);
      if (eF) {
        const thisFieldManager = new FieldManager[eF.field.type](this.plugin, eF.field);
        thisFieldManager.createAndOpenFieldModal(this.file, eF.field.name, eF, eF.indexedPath, void 0, void 0, void 0, this.previousModal);
      }
    };
    if (this.toRemove) {
      const note = await Note.buildNote(this.plugin, this.file);
      if (item.indexedPath) {
        await note.removeObject(item.indexedPath);
        await reOpen();
      }
    } else {
      const objectModal = new ObjectModal(
        this.plugin,
        this.file,
        void 0,
        item.indexedPath,
        void 0,
        void 0,
        void 0,
        this
      );
      objectModal.open();
    }
  }
};

// src/fields/fieldManagers/ObjectListField.ts
var ObjectListField = class extends FieldManager2 {
  /*
  this object contains a list of objects.
  //TODO insert listItem at position
  //TODO reorder listItems
  */
  constructor(plugin, field) {
    super(plugin, field, "ObjectList" /* ObjectList */);
  }
  addFieldOption(file, location, indexedPath, noteField) {
    const name = this.field.name;
    if (noteField) {
      const moveToObject = async () => await noteField.moveToObject(`${indexedPath}`);
      const removeObject = async () => {
        if (indexedPath) {
          const note = await Note.buildNote(this.plugin, file);
          await note.removeObject(indexedPath);
        }
      };
      if (ObjectListField.isFieldOptions(location)) {
        location.addOption(FieldIcon["ObjectList" /* ObjectList */], moveToObject, `Go to this ${name} item`);
        location.addOption("trash", removeObject, `Remove this ${name} item`);
      }
    } else {
      const moveToObject = async () => {
        const _eF = await Note.getExistingFieldForIndexedPath(this.plugin, file, indexedPath);
        if (_eF)
          this.createAndOpenFieldModal(file, _eF.field.name, _eF, _eF.indexedPath, void 0, void 0, void 0, void 0);
      };
      const removeObject = async () => {
        if (indexedPath) {
          const note = await Note.buildNote(this.plugin, file);
          await note.removeObject(indexedPath);
        }
      };
      if (ObjectListField.isSuggest(location)) {
        location.options.push({
          id: `update_${name}`,
          actionLabel: `<span>Update <b>${name}</b></span>`,
          action: moveToObject,
          icon: FieldIcon["ObjectList" /* ObjectList */]
        });
        location.options.push({
          id: `remove_${name}`,
          actionLabel: `<span>Remove this <b>${name}</b> item</span>`,
          action: removeObject,
          icon: "trash"
        });
      }
    }
  }
  validateOptions() {
    return true;
  }
  createSettingContainer(container, plugin, location) {
  }
  createDvField(dv, p, fieldContainer, attrs) {
    const fieldValue = dv.el("span", "{...}", { ...attrs, cls: "value-container" });
    fieldContainer.appendChild(fieldValue);
    const editBtn = fieldContainer.createEl("button");
    (0, import_obsidian57.setIcon)(editBtn, FieldIcon[this.field.type]);
    editBtn.onclick = async () => {
      const file = this.plugin.app.vault.getAbstractFileByPath(p["file"]["path"]);
      const _eF = file instanceof import_obsidian57.TFile && file.extension == "md" && await Note.getExistingFieldForIndexedPath(this.plugin, file, this.field.id);
      if (_eF)
        this.createAndOpenFieldModal(file, this.field.name, _eF, _eF.indexedPath);
    };
  }
  getOptionsStr() {
    return "";
  }
  async addObjectListItem(file, eF, indexedPath) {
    const value = eF == null ? void 0 : eF.value;
    const indexForNew = !value || value.length === 0 ? 0 : value.length;
    if (indexedPath)
      await postValues(this.plugin, [{ id: `${indexedPath}[${indexForNew}]`, payload: { value: "" } }], file, -1);
  }
  async createAndOpenFieldModal(file, selectedFieldName, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal) {
    const fieldModal = new ObjectListModal(this.plugin, file, this.field, eF, indexedPath, lineNumber, asList, asBlockquote, previousModal);
    fieldModal.open();
  }
  displayValue(container, file, value, onClicked) {
    const fields = this.plugin.fieldIndex.filesFields.get(file.path);
    if (Array.isArray(value)) {
      const items = (fields == null ? void 0 : fields.filter(
        (_f) => (this.field.isRoot() && _f.path === this.field.id || !this.field.isRoot() && Field_default.upperPath(_f.path) === this.field.path) && _f.path !== ""
      ).map((_f) => _f.name)) || [];
      container.setText(`${value.length} item${value.length !== 1 ? "(s)" : ""}: [${items.join(" | ")}]`);
    }
  }
};

// src/fields/fieldManagers/Managers.ts
var Managers = {
  Input: InputField,
  Boolean: BooleanField,
  Number: NumberField,
  Select: SelectField,
  Cycle: CycleField,
  Multi: MultiField,
  File: FileField,
  Date: DateField,
  MultiFile: MultiFileField,
  Lookup: LookupField,
  Formula: FormulaField,
  Canvas: CanvasField,
  CanvasGroup: CanvasGroupField,
  CanvasGroupLink: CanvasGroupLinkField,
  YAML: YAMLField,
  JSON: JSONField,
  Object: ObjectField,
  ObjectList: ObjectListField
};
var Managers_default = Managers;

// src/types/fieldTypes.ts
var FieldTypeLabelMapping = {
  "Input": "Input" /* Input */,
  "Select": "Select" /* Select */,
  "Multi": "Multi" /* Multi */,
  "Cycle": "Cycle" /* Cycle */,
  "Boolean": "Boolean" /* Boolean */,
  "Number": "Number" /* Number */,
  "File": "File" /* File */,
  "MultiFile": "MultiFile" /* MultiFile */,
  "Date": "Date" /* Date */,
  "Lookup": "Lookup" /* Lookup */,
  "Formula": "Formula" /* Formula */,
  "Canvas": "Canvas" /* Canvas */,
  "CanvasGroup": "CanvasGroup" /* CanvasGroup */,
  "CanvasGroupLink": "CanvasGroupLink" /* CanvasGroupLink */,
  "YAML": "YAML" /* YAML */,
  "JSON": "JSON" /* JSON */,
  "Object": "Object" /* Object */,
  "ObjectList": "ObjectList" /* ObjectList */
};
var FieldTypeTagClass = {
  "Input": "single",
  "Select": "select",
  "Multi": "multi",
  "Cycle": "cycle",
  "Boolean": "boolean",
  "Number": "number",
  "File": "file",
  "MultiFile": "file",
  "Date": "date",
  "Lookup": "lookup",
  "Formula": "formula",
  "Canvas": "canvas-links",
  "CanvasGroup": "canvas-links",
  "CanvasGroupLink": "canvas-links",
  "YAML": "yaml",
  "JSON": "json",
  "Object": "object",
  "ObjectList": "object-list"
};
var FieldTypeTooltip = {
  "Input": "Accept any value",
  "Select": "Accept a single value from a list",
  "Multi": "Accept multiple values from a list",
  "Cycle": "Cycle through values from a list",
  "Boolean": "Accept true or false",
  "Number": "Accept a number",
  "File": "Accept a link",
  "MultiFile": "Accept multiple links",
  "Date": "Accept a date",
  "Lookup": "Accept a lookup query",
  "Formula": "Accept a formula",
  "Canvas": "Updates with links in canvas",
  "CanvasGroup": "Updates with groups in canvas",
  "CanvasGroupLink": "Updates with links to groups in canvas",
  "YAML": "Accept a YAML object",
  "JSON": "Accept a JSON object",
  "Object": "Accept objects (values are fields)",
  "ObjectList": "Accept a list of object fields"
};
var FieldManager = {
  "Input": Managers_default.Input,
  "Select": Managers_default.Select,
  "Multi": Managers_default.Multi,
  "Cycle": Managers_default.Cycle,
  "Boolean": Managers_default.Boolean,
  "Number": Managers_default.Number,
  "File": Managers_default.File,
  "MultiFile": Managers_default.MultiFile,
  "Date": Managers_default.Date,
  "Lookup": Managers_default.Lookup,
  "Formula": Managers_default.Formula,
  "Canvas": Managers_default.Canvas,
  "CanvasGroup": Managers_default.CanvasGroup,
  "CanvasGroupLink": Managers_default.CanvasGroupLink,
  "YAML": Managers_default.YAML,
  "JSON": Managers_default.JSON,
  "Object": Managers_default.Object,
  "ObjectList": Managers_default.ObjectList
};
var FieldIcon = {
  "Input": "pencil",
  "Select": "right-triangle",
  "Multi": "bullet-list",
  "Cycle": "switch",
  "Boolean": "toggle-left",
  "Number": "plus-minus-glyph",
  "File": "link",
  "MultiFile": "link",
  "Date": "calendar-with-checkmark",
  "Lookup": "file-search",
  "Formula": "function-square",
  "Canvas": "layout-dashboard",
  "CanvasGroup": "box-select",
  "CanvasGroupLink": "box-select",
  "YAML": "file-json-2",
  "JSON": "file-json-2",
  "Object": "package",
  "ObjectList": "boxes"
};
var FieldBackgroundColorClass = {
  "Input": "single",
  "Select": "select",
  "Multi": "multi",
  "Cycle": "cycle",
  "Boolean": "boolean",
  "Number": "number",
  "File": "file",
  "MultiFile": "file",
  "Date": "date",
  "Lookup": "lookup",
  "Formula": "lookup",
  "Canvas": "file",
  "CanvasGroup": "file",
  "CanvasGroupLink": "file",
  "YAML": "file",
  "JSON": "file",
  "Object": "lookup",
  "ObjectList": "lookup"
};
var multiTypes = [
  "Multi" /* Multi */,
  "MultiFile" /* MultiFile */,
  "Canvas" /* Canvas */,
  "CanvasGroup" /* CanvasGroup */,
  "CanvasGroupLink" /* CanvasGroupLink */,
  "ObjectList" /* ObjectList */
];
var ReservedMultiAttributes = ["tags", "tagNames", "excludes", "aliases"];
var rawObjectTypes = [
  "YAML" /* YAML */,
  "JSON" /* JSON */
];
var objectTypes2 = [
  "Object" /* Object */,
  "ObjectList" /* ObjectList */
];
var rootOnlyTypes = [
  "Canvas" /* Canvas */,
  "CanvasGroup" /* CanvasGroup */,
  "CanvasGroupLink" /* CanvasGroupLink */,
  "Lookup" /* Lookup */,
  "Formula" /* Formula */
];
var frontmatterOnlyTypes = [
  "YAML" /* YAML */,
  "Object" /* Object */,
  "ObjectList" /* ObjectList */
];

// src/fields/Field.ts
var Field = class {
  constructor(plugin, name = "", options2 = {}, id = "", type = "Input" /* Input */, fileClassName, command, display, style, path = "") {
    this.plugin = plugin;
    this.name = name;
    this.options = options2;
    this.id = id;
    this.type = type;
    this.fileClassName = fileClassName;
    this.command = command;
    this.display = display;
    this.style = style;
    this.path = path;
  }
  isRoot() {
    return this.path === "";
  }
  getDisplay() {
    if (multiTypes.includes(this.type)) {
      return this.display || this.plugin.settings.frontmatterListDisplay;
    } else {
      return "asArray" /* asArray */;
    }
  }
  getIndexedPath(node) {
    var _a;
    if (this.path === "")
      return node.indexedId;
    const parentNode = (_a = node.line.parentLine) == null ? void 0 : _a.nodes[0];
    const parentField = parentNode == null ? void 0 : parentNode.field;
    if (parentField) {
      const parentIndexedPath = parentField.getIndexedPath(parentNode);
      return `${parentIndexedPath}${parentIndexedPath ? "____" : ""}${node.indexedId}`;
    } else {
      return "";
    }
  }
  getFirstAncestor() {
    const ancestors = this.getAncestors();
    return ancestors.last();
  }
  getDottedPath() {
    if (!this.path)
      return this.name;
    const upperDottedPath = this.path.split("____").map((id) => {
      var _a;
      return (_a = Field.getFieldFromId(this.plugin, id, this.fileClassName)) == null ? void 0 : _a.name;
    }).join(".");
    return `${upperDottedPath}.${this.name}`;
  }
  hasIdAsAncestor(childId) {
    if (!this.path) {
      return false;
    } else {
      const parentId = this.path.split("____").last();
      if (parentId === childId) {
        return true;
      } else {
        const field = Field.getFieldFromId(this.plugin, parentId, this.fileClassName);
        return (field == null ? void 0 : field.hasIdAsAncestor(childId)) || false;
      }
    }
  }
  getCompatibleParents() {
    const otherObjectFields = this.getOtherObjectTypeFields();
    if (objectTypes2.includes(this.type)) {
      return otherObjectFields;
    } else {
      const compatibleParents = otherObjectFields.filter((_field) => {
        const field = Field.getFieldFromId(this.plugin, _field.id, this.fileClassName);
        return !(field == null ? void 0 : field.hasIdAsAncestor(this.id));
      }).filter(
        (_f) => !rootOnlyTypes.includes(this.type)
      );
      return compatibleParents;
    }
  }
  getAncestors(fieldId = this.id) {
    const field = Field.getFieldFromId(this.plugin, fieldId, this.fileClassName);
    const ancestors = [];
    if (!field || !field.path)
      return ancestors;
    const ancestorsIds = field.path.split("____");
    for (const id of ancestorsIds) {
      const ancestor = Field.getFieldFromId(this.plugin, id, this.fileClassName);
      if (ancestor)
        ancestors.push(ancestor);
    }
    return ancestors;
  }
  getIndentationLevel(node) {
    const ancestors = this.getAncestors();
    let level = 0;
    ancestors.forEach((ancestor) => {
      level = ancestor.type === "ObjectList" /* ObjectList */ ? level + 2 : level + 1;
    });
    if (this.isFirstItemOfObjectList(node))
      level = level - 1;
    return level;
  }
  isFirstItemOfObjectList(node) {
    var _a, _b;
    const ancestors = this.getAncestors(this.id);
    if (((_a = ancestors.last()) == null ? void 0 : _a.type) === "ObjectList" /* ObjectList */) {
      const indentRegex = new RegExp(/(?<indentation>\s*)(?<list>-\s)?.*/);
      const fR = node.rawContent.match(indentRegex);
      if ((_b = fR == null ? void 0 : fR.groups) == null ? void 0 : _b.list) {
        return true;
      }
    }
    return false;
  }
  getOtherObjectTypeFields() {
    var _a;
    let objectFields;
    if (this.fileClassName) {
      const index = this.plugin.fieldIndex;
      objectFields = ((_a = index.fileClassesFields.get(this.fileClassName)) == null ? void 0 : _a.filter((field) => objectTypes2.includes(field.type) && field.id !== this.id)) || [];
    } else {
      objectFields = this.plugin.presetFields.filter((field) => objectTypes2.includes(field.type) && field.id !== this.id);
    }
    return objectFields.map((_field) => {
      return Field.getFieldFromId(this.plugin, _field.id, this.fileClassName);
    });
  }
  static copyProperty(target, source) {
    target.id = source.id;
    target.name = source.name;
    target.type = source.type;
    Object.keys(source.options).forEach((k) => {
      target.options[k] = source.options[k];
    });
    Object.keys(target.options).forEach((k) => {
      if (!Object.keys(source.options).includes(k)) {
        delete target.options[k];
      }
      ;
    });
    target.command = source.command;
    target.display = source.display;
    target.style = source.style;
    target.path = source.path;
  }
  static createDefault(plugin, name) {
    const field = new Field(plugin);
    field.type = "Input" /* Input */;
    field.name = name;
    return field;
  }
  static existingFields(plugin, filePath, obj, depth = 0, path = "") {
    var _a;
    const reservedKeys = ["file", "aliases", "tags"];
    let _obj;
    if (depth === 0) {
      const dvApi = (_a = plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
      if (dvApi) {
        _obj = dvApi.page(filePath);
      } else {
        return [];
      }
    } else {
      _obj = obj;
    }
    const _existingFields = [];
    if (typeof obj === "object") {
      for (const key of obj) {
        if (depth === 0 && reservedKeys.includes(key))
          continue;
        if (typeof obj[key] === "object" && obj[key] !== null) {
          _existingFields.push(...Field.existingFields(plugin, filePath, obj[key], depth + 1, `${path ? path + "." : ""}${key}`).filter((k) => !_existingFields.includes(k)));
        } else if (!_existingFields.map((k) => k.name.toLowerCase().replace(/\s/g, "-")).includes(key.toLowerCase().replace(/\s/g, "-"))) {
          _existingFields.push(key);
        } else {
          if (key !== key.toLowerCase().replace(/\s/g, "-")) {
            _existingFields[_existingFields.indexOf(key.toLowerCase().replace(/\s/g, "-"))] = key;
          }
        }
      }
    }
    return _existingFields;
  }
  static getFieldFromId(plugin, id, fileClassName) {
    var _a;
    let field = void 0;
    if (fileClassName) {
      const index = plugin.fieldIndex;
      field = (_a = index.fileClassesFields.get(fileClassName)) == null ? void 0 : _a.find((field2) => field2.id === id);
    } else {
      const _field = plugin.presetFields.find((field2) => field2.id === id);
      if (_field) {
        field = new Field(plugin);
        Object.assign(field, _field);
      }
    }
    return field;
  }
  static getIdAndIndex(indexedId) {
    var _a;
    const { id, index } = ((_a = indexedId == null ? void 0 : indexedId.match(/(?<id>[^\[]*)(?:\[(?<index>.*)\])?/)) == null ? void 0 : _a.groups) || { id: "", index: void 0 };
    return { id, index };
  }
  static upperPath(indexedPath) {
    const upperIndexedIds = indexedPath == null ? void 0 : indexedPath.split("____");
    upperIndexedIds == null ? void 0 : upperIndexedIds.pop();
    return (upperIndexedIds == null ? void 0 : upperIndexedIds.join("____")) || "";
  }
  static upperIndexedPathObjectPath(indexedPath) {
    const endingIndex = indexedPath.match(/\[\w+\]$/);
    if (endingIndex) {
      return indexedPath.replace(/\[\w+\]$/, "");
    } else {
      return Field.upperPath(indexedPath);
    }
  }
  static getValueFromIndexedPath(carriageField, obj, indexedPath) {
    if (!indexedPath)
      return obj;
    const plugin = carriageField.plugin;
    const fileClassName = carriageField.fileClassName;
    const indexedProps = indexedPath.split("____");
    try {
      const indexedProp = indexedProps.shift();
      const { id, index } = Field.getIdAndIndex(indexedProp);
      const field = Field.getFieldFromId(plugin, id, fileClassName);
      if (!field)
        return "";
      let value;
      if (index !== void 0) {
        value = obj[field.name][index];
      } else {
        value = obj[field.name];
      }
      if (typeof value === "object") {
        const subValue = Field.getValueFromIndexedPath(field, value, indexedProps.join("____"));
        return subValue;
      } else if (Array.isArray(value)) {
        if (index && !isNaN(parseInt(index))) {
          const subObject = value[parseInt(index)];
          const subValue = Field.getValueFromIndexedPath(field, subObject, indexedProps.join("____"));
          return subValue;
        } else {
          return value;
        }
      } else {
        return value;
      }
    } catch (e) {
      return "";
    }
  }
  static getValueFromPath(obj, path) {
    if (!path)
      return obj;
    const properties = path.split(".");
    try {
      const subValue = Field.getValueFromPath(obj[properties.shift()], properties.join("."));
      return subValue;
    } catch (e) {
      return "";
    }
  }
  static getNewFieldId(plugin) {
    const index = plugin.fieldIndex;
    const ids = [];
    for (const fileClassFields of index.fileClassesFields.values()) {
      for (const field of fileClassFields) {
        ids.push(field.id);
      }
    }
    for (const field of plugin.presetFields) {
      ids.push(field.id);
    }
    let id = browser_default({ length: 6, type: "alphanumeric" });
    while (ids.includes(id)) {
      id = browser_default({ length: 6, type: "alphanumeric" });
    }
    return id;
  }
};
var Field_default = Field;

// src/components/NoteFields.ts
var FieldOptions = class {
  constructor(container) {
    this.container = container;
  }
  async setIconAndTooltipAsync(fieldOption, file, indexedPath, plugin) {
    const eF = await Note.getExistingFieldForIndexedPath(plugin, file, indexedPath);
    switch (eF == null ? void 0 : eF.field.type) {
      case "Boolean" /* Boolean */:
        {
          const value = BooleanField.stringToBoolean(eF == null ? void 0 : eF.value);
          fieldOption.setIcon(!value ? "toggle-left" : "toggle-right");
          fieldOption.setTooltip(!value ? `Set ${eF.name} as true` : `Set ${eF.name} as false`);
        }
        break;
      default: {
        fieldOption.setIcon("pencil");
        fieldOption.setTooltip(`Update ${(eF == null ? void 0 : eF.name) || ""}`);
      }
    }
  }
  addOption(icon, onclick, tooltip, className, file, indexedPath, plugin) {
    const fieldOptionContainer = this.container.createDiv({ cls: "field-item field-option" });
    const fieldOption = new import_obsidian58.ButtonComponent(fieldOptionContainer);
    if (indexedPath && file && plugin) {
      this.setIconAndTooltipAsync(fieldOption, file, indexedPath, plugin);
    } else {
      fieldOption.setIcon(icon);
      if (tooltip)
        fieldOption.setTooltip(tooltip);
    }
    if (className)
      fieldOption.buttonEl.addClass(className);
    fieldOption.onClick(() => onclick());
  }
};
var FieldsModal = class extends import_obsidian58.Modal {
  constructor(plugin, file, noteFields, indexedPath) {
    super(plugin.app);
    this.plugin = plugin;
    this.file = file;
    this.noteFields = noteFields;
    this.indexedPath = indexedPath;
    this.existingFields = [];
    this.missingFields = [];
    this.containerEl.addClass("metadata-menu");
    this.containerEl.addClass("note-fields-modal");
  }
  async onOpen() {
    await this.buildNote();
    this.build();
  }
  async buildNote() {
    this.note = await Note.buildNote(this.plugin, this.file);
  }
  build() {
    var _a;
    this.contentEl.replaceChildren();
    const indexedPath = this.indexedPath || "";
    const { id, index } = Field_default.getIdAndIndex(indexedPath == null ? void 0 : indexedPath.split("____").last());
    if (!id) {
      this.titleEl.setText(`Fields of ${this.file.basename}`);
    } else {
      const baseTitle = `Fields of ${this.file.basename} ${(indexedPath == null ? void 0 : indexedPath.split("____").length) > 1 ? " > ... > " : " > "}`;
      if (index) {
        const field = this.note.getExistingFieldForIndexedPath(indexedPath.replace(/\[\w+\]$/, ""));
        this.titleEl.setText(`${baseTitle} ${field == null ? void 0 : field.name} [${index}]`);
      } else {
        const field = this.note.getExistingFieldForIndexedPath(indexedPath);
        this.titleEl.setText(`${baseTitle} ${field == null ? void 0 : field.name}`);
      }
    }
    this.existingFields = this.note.existingFields.filter((_f) => {
      var _a2;
      if (!this.indexedPath) {
        return _f.isRoot();
      } else {
        const upperIndexedIdsInPath = (_a2 = _f.indexedPath) == null ? void 0 : _a2.split("____");
        upperIndexedIdsInPath == null ? void 0 : upperIndexedIdsInPath.pop();
        return (upperIndexedIdsInPath == null ? void 0 : upperIndexedIdsInPath.join("____")) === this.indexedPath;
      }
    });
    this.missingFields = ((_a = this.note) == null ? void 0 : _a.fields.filter((_f) => {
      var _a2;
      if (this.indexedPath)
        return ((_a2 = _f.getFirstAncestor()) == null ? void 0 : _a2.id) === id;
      else
        return _f.isRoot();
    }).filter((_f) => !this.existingFields.map((eF) => eF.field.id).includes(_f.id))) || [];
    if (this.indexedPath) {
      this.buildNavigation();
      this.contentEl.createEl("hr", { cls: "navigation-separator" });
    } else {
      this.contentEl.createEl("hr");
    }
    this.buildFieldsContainer();
    this.contentEl.createEl("hr");
    const fileClassManagersContainer = this.contentEl.createDiv({ cls: "fields-container" });
    this.buildFileClassManager(fileClassManagersContainer);
  }
  buildNavigation() {
    var _a;
    const fileName = this.file.name.replace(/(.*).md$/, "$1");
    const upperPath = Field_default.upperIndexedPathObjectPath(this.indexedPath || "");
    const { id: upperId, index: upperIndex } = Field_default.getIdAndIndex(upperPath.split("____").last());
    const upperObject = (_a = this.note.existingFields.find((eF) => eF.field.id === upperId)) == null ? void 0 : _a.field;
    const upperObjectName = upperObject ? upperObject.name : fileName;
    const backBtnWrapper = this.contentEl.createDiv({ cls: "back-button-wrapper" });
    const backBtn = new import_obsidian58.ButtonComponent(backBtnWrapper);
    backBtn.setIcon("chevron-left");
    backBtn.setTooltip(`Go to ${upperObjectName} fields`);
    backBtnWrapper.createSpan({ text: `${upperObjectName}${upperIndex ? " [" + upperIndex + "]" : ""}` });
    backBtnWrapper.onclick = async () => {
      await this.noteFields.moveToObject(upperPath);
    };
  }
  //
  buildFieldContainer(container, field, value, indexedPath) {
    const fieldManager = new FieldManager[field.type](this.plugin, field);
    const fieldNameWrapper = container.createDiv({ cls: "field-name-wrapper" });
    const fieldNameContainer = fieldNameWrapper.createDiv({ text: `${field.name}`, cls: "field-item field-name" });
    const fieldSettingsWrapper = container.createDiv({ cls: "field-settings-wrapper" });
    fieldSettingsWrapper.createDiv({ cls: "field-settings-spacer" });
    const fileClass = field.fileClassName ? this.plugin.fieldIndex.fileClassesName.get(field.fileClassName) : void 0;
    if (fileClass) {
      fieldNameContainer.addClass(`fileClassField__${fileClass.name.replace("/", "___").replaceAll(" ", "_")}`);
    }
    const fieldSettingContainer = fieldSettingsWrapper.createDiv({ cls: "field-item field-setting" });
    const fieldSettingBtn = new import_obsidian58.ButtonComponent(fieldSettingContainer);
    fieldSettingBtn.setIcon("gear");
    fieldSettingBtn.setTooltip(`${field.fileClassName ? field.fileClassName + " > " : "Preset Field > "} ${field.name} settings`);
    fieldSettingBtn.onClick(() => {
      const _fileClass = field.fileClassName ? this.plugin.fieldIndex.fileClassesName.get(field.fileClassName) : void 0;
      const fileClassAttribute = _fileClass == null ? void 0 : _fileClass.attributes.find((attr) => attr.id === field.id);
      if (fileClassAttribute && _fileClass) {
        const fileClassAttributeModal = new FileClassAttributeModal(this.plugin, _fileClass, fileClassAttribute);
        fileClassAttributeModal.open();
      }
    });
    const fieldTypeContainer = fieldSettingsWrapper.createDiv({ cls: `field-item` });
    fieldTypeContainer.createDiv({ text: field.type, cls: `chip field-type ${FieldBackgroundColorClass[field.type]}` });
    const fieldValueWrapper = container.createDiv({ cls: "field-value-wrapper" });
    const fieldValueContainer = fieldValueWrapper.createDiv({
      cls: ![void 0, null, ""].includes(value) ? "field-item field-value" : "field-item field-value emptyfield"
    });
    if (value === null || value === "") {
      fieldValueContainer.setText(field.type === "Lookup" /* Lookup */ ? "---auto---" : "<empty>");
    } else if (value === void 0) {
      fieldValueContainer.setText("<missing>");
    } else {
      fieldManager.displayValue(fieldValueContainer, this.file, value, () => {
        this.close();
      });
    }
    const fieldOptionsWrapper = container.createDiv({ cls: "field-options-wrapper" });
    fieldOptionsWrapper.createDiv({ cls: "field-options-spacer" });
    const fieldOptions = new FieldOptions(fieldOptionsWrapper);
    if (this.existingFields.map((_f) => _f.field.id).includes(field.id)) {
      if (objectTypes2.includes(field.type)) {
        fieldManager.addFieldOption(this.file, fieldOptions, indexedPath, this.noteFields);
      } else {
        fieldManager.addFieldOption(this.file, fieldOptions, indexedPath);
      }
    } else {
      const newIndexedPath = `${this.indexedPath ? this.indexedPath + "____" : ""}${field.id}`;
      const fieldBtnContainer = fieldOptionsWrapper.createDiv({ cls: "field-item field-option" });
      const fieldBtn = new import_obsidian58.ButtonComponent(fieldBtnContainer);
      fieldBtn.setIcon("list-plus");
      fieldBtn.setTooltip("Add field at section");
      fieldBtn.onClick(async () => {
        if (objectTypes2.includes(field.type) && this.note) {
          await postValues(this.plugin, [{ id: `${newIndexedPath}`, payload: { value: "" } }], this.file);
          this.indexedPath = `${newIndexedPath}`;
        } else {
          if (field.path === "") {
            new chooseSectionModal(
              this.plugin,
              this.file,
              (lineNumber, asList, asBlockquote) => FieldManager2.createAndOpenModal(
                this.plugin,
                this.file,
                field.name,
                field,
                void 0,
                newIndexedPath,
                lineNumber,
                asList,
                asBlockquote
              )
            ).open();
          } else {
            FieldManager2.createAndOpenModal(this.plugin, this.file, field.name, field, void 0, newIndexedPath, -1, false, false);
          }
        }
      });
    }
    ;
  }
  buildObjectListItemContainer(container, field, item, itemIndexedPath) {
    const fieldManager = new FieldManager[field.type](this.plugin, field);
    const { id, index } = Field_default.getIdAndIndex(itemIndexedPath.split("____").last());
    const value = Object.keys(item || {}).map((key) => {
      if (Array.isArray(item[key])) {
        return `${item[key].length} ${key}`;
      } else if (typeof item[key] === "object") {
        return `${key}: {...}`;
      } else {
        return `${key}: ${item[key]}`;
      }
    }).join(" | ");
    const fieldNameWrapper = container.createDiv({ cls: "field-name-wrapper" });
    const fieldNameContainer = fieldNameWrapper.createDiv({ text: `${field.name} [${index}]`, cls: "field-item field-name" });
    const fieldSettingsWrapper = container.createDiv({ cls: "field-settings-wrapper" });
    fieldSettingsWrapper.createDiv({ cls: "field-settings-spacer" });
    const fileClass = field.fileClassName ? this.plugin.fieldIndex.fileClassesName.get(field.fileClassName) : void 0;
    if (fileClass) {
      fieldNameContainer.addClass(`fileClassField__${fileClass.name.replace("/", "___").replaceAll(" ", "_")}`);
    }
    const fieldSettingContainer = fieldSettingsWrapper.createDiv({ cls: "field-item field-setting" });
    const fieldSettingBtn = new import_obsidian58.ButtonComponent(fieldSettingContainer);
    fieldSettingBtn.setIcon("gear");
    fieldSettingBtn.setTooltip(`${field.fileClassName ? field.fileClassName + " > " : "Preset Field > "} ${field.name} settings`);
    fieldSettingBtn.onClick(() => {
      const _fileClass = field.fileClassName ? this.plugin.fieldIndex.fileClassesName.get(field.fileClassName) : void 0;
      const fileClassAttribute = _fileClass == null ? void 0 : _fileClass.attributes.find((attr) => attr.id === field.id);
      if (fileClassAttribute && _fileClass) {
        const fileClassAttributeModal = new FileClassAttributeModal(this.plugin, _fileClass, fileClassAttribute);
        fileClassAttributeModal.open();
      }
    });
    const fieldTypeContainer = fieldSettingsWrapper.createDiv({ cls: `field-item` });
    fieldTypeContainer.createDiv({ text: `${field.type} item`, cls: `chip field-type ${FieldBackgroundColorClass[field.type]}` });
    const fieldValueWrapper = container.createDiv({ cls: "field-value-wrapper" });
    const fieldValueContainer = fieldValueWrapper.createDiv({
      cls: value !== void 0 && value !== null ? "field-item field-value" : "field-item field-value emptyfield"
    });
    fieldValueContainer.setText(value);
    const fieldOptionsWrapper = container.createDiv({ cls: "field-options-wrapper" });
    fieldOptionsWrapper.createDiv({ cls: "field-options-spacer" });
    const fieldOptions = new FieldOptions(fieldOptionsWrapper);
    fieldManager.addFieldOption(this.file, fieldOptions, itemIndexedPath, this.noteFields);
  }
  buildFileClassManager(container) {
    const fileClasses = this.plugin.fieldIndex.filesFileClasses.get(this.file.path) || [];
    fileClasses.forEach((fileClass) => {
      const fileClassManagerContainer = container.createDiv({ cls: "fields-inheritance-manager-container" });
      const _ancestors = this.plugin.fieldIndex.fileClassesAncestors.get(fileClass.name) || [];
      const ancestors = [..._ancestors].reverse();
      ancestors.push(fileClass.name);
      ancestors.forEach(async (fileClassName, i) => {
        const _fileClass = this.plugin.fieldIndex.fileClassesName.get(fileClassName);
        if (_fileClass) {
          const fileClassOptionsContainer = fileClassManagerContainer.createDiv({ cls: "fileclass-manager-container" });
          const fileClassNameContainer = fileClassOptionsContainer.createDiv({ cls: "name", text: _fileClass.name });
          fileClassNameContainer.setAttr("id", `fileClass__${_fileClass.name.replace("/", "___").replace(" ", "_")}`);
          if (await _fileClass.missingFieldsForFileClass(this.file)) {
            const fileClassInsertMissingFieldsInFrontmatterBtn = new import_obsidian58.ButtonComponent(fileClassOptionsContainer);
            fileClassInsertMissingFieldsInFrontmatterBtn.setIcon("align-vertical-space-around");
            fileClassInsertMissingFieldsInFrontmatterBtn.setTooltip(`Insert missing fields for ${_fileClass.name}`);
            fileClassInsertMissingFieldsInFrontmatterBtn.onClick(() => {
              insertMissingFields(this.plugin, this.file.path, -1, false, false, _fileClass.name);
            });
            const fileClassInsertMissingFieldsBtn = new import_obsidian58.ButtonComponent(fileClassOptionsContainer);
            fileClassInsertMissingFieldsBtn.setIcon("log-in");
            fileClassInsertMissingFieldsBtn.setTooltip(`Insert missing fields for ${_fileClass.name}`);
            fileClassInsertMissingFieldsBtn.onClick(() => {
              new chooseSectionModal(
                this.plugin,
                this.file,
                (lineNumber, asList, asBlockquote) => insertMissingFields(
                  this.plugin,
                  this.file.path,
                  lineNumber,
                  asList,
                  asBlockquote,
                  _fileClass.name
                )
              ).open();
            });
          }
          const fileClassAddAttributeBtn = new import_obsidian58.ButtonComponent(fileClassOptionsContainer);
          fileClassAddAttributeBtn.setIcon("plus-circle");
          fileClassAddAttributeBtn.setTooltip(`Add field definition in ${_fileClass.name}`);
          fileClassAddAttributeBtn.onClick(() => {
            const fileClassAttributeModal = new FileClassAttributeModal(this.plugin, _fileClass);
            fileClassAttributeModal.open();
          });
          if (i < ancestors.length - 1) {
            fileClassOptionsContainer.createDiv({ text: ">", cls: "separator" });
          }
          const fileClassFieldsContainers = this.containerEl.querySelectorAll(`[class*="fileClassField__${fileClassName.replace("/", "___").replace(" ", "_")}"]`);
          fileClassFieldsContainers.forEach((fieldNameContainer) => {
            fieldNameContainer.onmouseover = () => {
              fileClassNameContainer == null ? void 0 : fileClassNameContainer.addClass("active");
            };
            fieldNameContainer.onmouseout = () => {
              fileClassNameContainer == null ? void 0 : fileClassNameContainer.removeClass("active");
            };
          });
          fileClassNameContainer.onmouseover = () => {
            this.containerEl.querySelectorAll(`.field-item.field-name.fileClassField__${fileClassName.replace("/", "___").replace(" ", "_")}`).forEach((cont) => {
              cont.addClass("active");
            });
          };
          fileClassNameContainer.onmouseout = () => {
            this.containerEl.querySelectorAll(`.field-item.field-name.fileClassField__${fileClassName.replace("/", "___").replace(" ", "_")}`).forEach((cont) => {
              cont.removeClass("active");
            });
          };
          fileClassNameContainer.onclick = () => {
            const fileClassComponent = new FileClassViewManager(this.plugin, _fileClass);
            this.plugin.addChild(fileClassComponent);
            fileClassComponent.build();
            this.close();
          };
        }
      });
    });
  }
  buildInsertMissingFieldsBtn() {
    const insertMissingFieldsContainer = this.contentEl.createDiv({ cls: "insert-all-fields" });
    insertMissingFieldsContainer.createDiv({ text: "Insert missing fields" });
    const insertMissingFieldsInFrontmatterBtn = new import_obsidian58.ButtonComponent(insertMissingFieldsContainer);
    insertMissingFieldsInFrontmatterBtn.setIcon("align-vertical-space-around");
    insertMissingFieldsInFrontmatterBtn.setTooltip("In Frontmatter");
    insertMissingFieldsInFrontmatterBtn.onClick(() => {
      var _a;
      if (!this.indexedPath) {
        insertMissingFields(this.plugin, this.file.path, -1);
      } else {
        const field = (_a = this.note.getExistingFieldForIndexedPath(this.indexedPath)) == null ? void 0 : _a.field;
        const fileClass = (field == null ? void 0 : field.fileClassName) ? this.plugin.fieldIndex.fileClassesName.get(field.fileClassName) : void 0;
        insertMissingFields(this.plugin, this.file.path, -1, false, false, fileClass == null ? void 0 : fileClass.name, this.indexedPath);
      }
    });
    const insertMissingFieldsBtn = new import_obsidian58.ButtonComponent(insertMissingFieldsContainer);
    insertMissingFieldsBtn.setIcon("log-in");
    insertMissingFieldsBtn.setTooltip("At line...");
    insertMissingFieldsBtn.onClick(() => {
      var _a;
      if (!this.indexedPath) {
        new chooseSectionModal(
          this.plugin,
          this.file,
          (lineNumber, asList, asBlockquote) => insertMissingFields(
            this.plugin,
            this.file.path,
            lineNumber,
            asList,
            asBlockquote
          )
        ).open();
      } else {
        const field = (_a = this.note.getExistingFieldForIndexedPath(this.indexedPath)) == null ? void 0 : _a.field;
        const fileClass = (field == null ? void 0 : field.fileClassName) ? this.plugin.fieldIndex.fileClassesName.get(field.fileClassName) : void 0;
        insertMissingFields(
          this.plugin,
          this.file.path,
          -1,
          false,
          false,
          fileClass == null ? void 0 : fileClass.name,
          this.indexedPath
        );
      }
    });
  }
  buildInsertNewItem(field, indexedPath) {
    const insertNewItemContainer = this.contentEl.createDiv({ cls: "insert-all-fields" });
    insertNewItemContainer.createDiv({ text: "Add a new item" });
    const insertNewItemBtn = new import_obsidian58.ButtonComponent(insertNewItemContainer);
    insertNewItemBtn.setIcon("list-plus");
    insertNewItemBtn.onClick(async () => {
      const fieldManager = new FieldManager[field.type](this.plugin, field);
      if (this.note)
        fieldManager.addObjectListItem(this.file, void 0, this.indexedPath);
      this.indexedPath = indexedPath;
    });
  }
  buildFieldsContainer() {
    var _a, _b, _c;
    const fieldsContainer = this.contentEl.createDiv({ cls: "note-fields-container" });
    const { id, index } = Field_default.getIdAndIndex((_a = this.indexedPath) == null ? void 0 : _a.split("____").last());
    if (this.indexedPath && ((_b = this.note.fields.find((_f) => _f.id === id)) == null ? void 0 : _b.type) === "ObjectList" /* ObjectList */ && index === void 0) {
      const field = this.note.fields.find((_f) => _f.id === id);
      const items = ((_c = this.note.existingFields.find((eF) => eF.indexedPath === this.indexedPath)) == null ? void 0 : _c.value) || [];
      items.forEach((item, index2) => this.buildObjectListItemContainer(fieldsContainer, field, item, `${this.indexedPath}[${index2}]`));
      this.buildInsertNewItem(field, this.indexedPath);
    } else {
      this.existingFields.filter((f) => {
        if (f.name === this.plugin.settings.fileClassAlias)
          return this.plugin.settings.showFileClassSelectInModal;
        else
          return true;
      }).forEach((eF) => {
        this.buildFieldContainer(fieldsContainer, eF.field, eF.value, eF.indexedPath);
      });
      this.missingFields.forEach((_f) => this.buildFieldContainer(fieldsContainer, _f, void 0));
      if (this.missingFields.length)
        this.buildInsertMissingFieldsBtn();
    }
  }
};
var NoteFieldsComponent = class extends import_obsidian58.Component {
  constructor(plugin, cacheVersion, onChange, file, indexedPath) {
    super();
    this.plugin = plugin;
    this.cacheVersion = cacheVersion;
    this.onChange = onChange;
    this.file = file;
    this.indexedPath = indexedPath;
    this.fieldsModal = new FieldsModal(this.plugin, this.file, this, this.indexedPath);
    this.fieldsModal.onClose = () => {
      this.plugin.removeChild(this);
      this.unload();
    };
  }
  async moveToObject(indexedPath) {
    await this.fieldsModal.buildNote();
    this.fieldsModal.indexedPath = indexedPath;
    this.fieldsModal.build();
  }
  onload() {
    this.registerEvent(
      this.plugin.app.workspace.on("metadata-menu:indexed", async () => {
        await this.fieldsModal.buildNote();
        this.fieldsModal.build();
      })
    );
    this.fieldsModal.open();
  }
};

// src/commands/paletteCommands.ts
function addFileClassAttributeOptions(plugin) {
  const classFilesPath = plugin.settings.classFilesPath;
  plugin.addCommand({
    id: "fileClassAttr_options",
    name: "All fileClass attributes options",
    icon: "gear",
    checkCallback: (checking) => {
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const inFileClass = !!(classFilesPath && !!(view == null ? void 0 : view.file) && view.file.path.startsWith(classFilesPath));
      if (checking) {
        return inFileClass;
      }
      if (inFileClass) {
        const fieldCommandSuggestModal = new FieldCommandSuggestModal(plugin.app);
        const fileClassOptionsList = new FileClassOptionsList(plugin, view.file, fieldCommandSuggestModal);
        fileClassOptionsList.createExtraOptionList();
      }
    }
  });
}
function addInsertFileClassAttribute(plugin) {
  const classFilesPath = plugin.settings.classFilesPath;
  plugin.addCommand({
    id: "insert_fileClassAttr",
    name: "Insert a new fileClass attribute",
    icon: "list-plus",
    checkCallback: (checking) => {
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const inFileClass = !!(classFilesPath && !!(view == null ? void 0 : view.file) && view.file.path.startsWith(classFilesPath));
      if (checking) {
        return inFileClass;
      }
      if (inFileClass) {
        try {
          const fileClassName = FileClass.getFileClassNameFromPath(plugin.settings, view.file.path);
          if (fileClassName) {
            const fileClassAttributeModal = new FileClassAttributeModal(plugin, FileClass.createFileClass(plugin, fileClassName));
            fileClassAttributeModal.open();
          }
        } catch (error) {
          new import_obsidian59.Notice("plugin is not a valid fileClass");
        }
      }
    }
  });
}
function addInsertFieldAtPositionCommand(plugin) {
  const classFilesPath = plugin.settings.classFilesPath;
  plugin.addCommand({
    id: "insert_field_at_cursor",
    name: "Choose a field to insert at cursor",
    icon: "list-plus",
    checkCallback: (checking) => {
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const inFile = !!((view == null ? void 0 : view.file) && (!classFilesPath || !view.file.path.startsWith(classFilesPath)));
      if (checking) {
        return inFile;
      }
      if (inFile) {
        const optionsList = new OptionsList(plugin, view.file, "InsertFieldCommand");
        (async () => await optionsList.createExtraOptionList())();
      }
    }
  });
}
function addFieldOptionsCommand(plugin) {
  const classFilesPath = plugin.settings.classFilesPath;
  plugin.addCommand({
    id: "field_options",
    name: "Fields options",
    icon: "gear",
    checkCallback: (checking) => {
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const inFile = !!((view == null ? void 0 : view.file) && (!classFilesPath || !view.file.path.startsWith(classFilesPath)));
      if (checking) {
        return inFile;
      }
      if (inFile) {
        const fieldCommandSuggestModal = new FieldCommandSuggestModal(plugin.app);
        const optionsList = new OptionsList(plugin, view.file, fieldCommandSuggestModal);
        (async () => await optionsList.createExtraOptionList())();
      }
    }
  });
}
function addManageFieldAtCursorCommand(plugin) {
  const classFilesPath = plugin.settings.classFilesPath;
  plugin.addCommand({
    id: "field_at_cursor_options",
    name: "Manage field at cursor",
    icon: "text-cursor-input",
    checkCallback: (checking) => {
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const editor = view == null ? void 0 : view.editor;
      const inFile = !!((view == null ? void 0 : view.file) && (!classFilesPath || !view.file.path.startsWith(classFilesPath)));
      if (checking) {
        return inFile && editor !== void 0;
      }
      if (inFile && editor !== void 0) {
        const optionsList = new OptionsList(plugin, view.file, "ManageAtCursorCommand");
        (async function() {
          var _a;
          const note = await Note.buildNote(plugin, view.file);
          switch (view.getMode()) {
            case "source":
              {
                const node = note.getNodeAtPosition(editor.getCursor());
                if (node)
                  optionsList.createAndOpenFieldModal(node);
                else
                  new import_obsidian59.Notice("No field with definition at this position", 2e3);
              }
              break;
            case "preview": {
              const focusedElement = document.querySelector(".metadata-property:focus-within");
              if (focusedElement instanceof HTMLElement) {
                const key = focusedElement.dataset.propertyKey;
                const field = key && ((_a = plugin.fieldIndex.filesFields.get(view.file.path)) == null ? void 0 : _a.find((_f) => _f.isRoot() && _f.name === key));
                if (field) {
                  const node = note.getNodeForIndexedPath(field.id);
                  if (node)
                    optionsList.createAndOpenFieldModal(node);
                  else
                    new import_obsidian59.Notice("No field with definition at this position", 2e3);
                } else if (key === plugin.settings.fileClassAlias) {
                  const node = note.getNodeForIndexedPath(`fileclass-field-${plugin.settings.fileClassAlias}`);
                  if (node)
                    optionsList.createAndOpenFieldModal(node);
                  else
                    new import_obsidian59.Notice("No field with definition at this position", 2e3);
                }
              }
              break;
            }
          }
        })();
      }
    }
  });
}
function insertMissingFieldsCommand(plugin) {
  const classFilesPath = plugin.settings.classFilesPath;
  plugin.addCommand({
    id: "insert_missing_fields",
    name: "Bulk insert missing fields",
    icon: "battery-full",
    checkCallback: (checking) => {
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const inFile = !!((view == null ? void 0 : view.file) && (!classFilesPath || !view.file.path.startsWith(classFilesPath)));
      if (checking) {
        return inFile;
      }
      if (inFile) {
        (async function() {
          const file = view.file;
          const existingFields = await Note.getExistingFields(plugin, file);
          const existingFieldsNames = existingFields.map((eF) => eF.field.name);
          if (![...plugin.fieldIndex.filesFields.get(file.path) || []].map((field) => field.name).every((fieldName) => existingFieldsNames.includes(fieldName))) {
            new chooseSectionModal(
              plugin,
              file,
              (lineNumber, asList, asBlockquote) => insertMissingFields(
                plugin,
                file.path,
                lineNumber,
                asList,
                asBlockquote
              )
            ).open();
          }
        })();
      }
    }
  });
}
function addOpenFieldsModalCommand(plugin) {
  const classFilesPath = plugin.settings.classFilesPath;
  plugin.addCommand({
    id: "open_fields_modal",
    name: "Open this note's fields modal",
    icon: "clipboard-list",
    checkCallback: (checking) => {
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const inFile = !!((view == null ? void 0 : view.file) && (!classFilesPath || !view.file.path.startsWith(classFilesPath)));
      if (checking) {
        return inFile;
      }
      if (inFile) {
        const file = view.file;
        if (inFile && file instanceof import_obsidian59.TFile && file.extension === "md") {
          const noteFieldsComponent = new NoteFieldsComponent(plugin, "1", () => {
          }, file);
          plugin.addChild(noteFieldsComponent);
        }
      }
    }
  });
}
function addInsertFieldCommand(plugin, command, field, fileClassName) {
  plugin.addCommand({
    id: command.id,
    name: command.label,
    icon: command.icon,
    checkCallback: (checking) => {
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const fR = command.id.match(/insert__(?<fieldId>.*)/);
      const fileClasses = (view == null ? void 0 : view.file) ? plugin.fieldIndex.filesFileClasses.get(view == null ? void 0 : view.file.path) : void 0;
      const belongsToView = field !== void 0 && !!(view == null ? void 0 : view.file) && (!!fileClasses && fileClasses.some((fileClass) => fileClass.name === fileClassName) || !fileClasses && !fileClassName);
      if (checking)
        return belongsToView;
      if ((view == null ? void 0 : view.file) && field) {
        new chooseSectionModal(
          plugin,
          view.file,
          (lineNumber, asList, asBlockquote) => FieldManager2.openFieldModal(
            plugin,
            view.file,
            field.name,
            lineNumber,
            asList,
            asBlockquote
          )
        ).open();
      }
    }
  });
}
function addInsertFieldsCommand(plugin) {
  const fields = [];
  plugin.presetFields.forEach((f) => {
    if (f.command && f.isRoot())
      fields.push({ field: f, fileClassName: void 0 });
  });
  [...plugin.fieldIndex.fileClassesFields].forEach(([fileClassName, _fields]) => {
    _fields.forEach((field) => {
      if (field.command && field.isRoot()) {
        fields.push({ field, fileClassName });
      }
    });
  });
  fields.forEach((_field) => {
    if (_field.field.command) {
      const { field, fileClassName } = _field;
      const command = field.command;
      addInsertFieldCommand(plugin, command, field, fileClassName);
    }
  });
}
function addOpenFileclassViewCommand(plugin) {
  plugin.addCommand({
    id: "open_fileclass_view",
    name: "Open fileClass view",
    icon: "package",
    checkCallback: (checking) => {
      var _a;
      if (checking) {
        return true;
      }
      const activeFilePath = (_a = plugin.app.workspace.getActiveFile()) == null ? void 0 : _a.path;
      const fileClass = activeFilePath ? plugin.fieldIndex.fileClassesPath.get(activeFilePath) : void 0;
      const fileClassComponent = new FileClassViewManager(plugin, fileClass);
      plugin.addChild(fileClassComponent);
      fileClassComponent.build();
    }
  });
}
function addFileclassToFileCommand(plugin) {
  plugin.addCommand({
    id: "add_fileclass_to_file",
    name: "Add fileClass to file",
    icon: "package-plus",
    checkCallback: (checking) => {
      const activeFile = plugin.app.workspace.getActiveFile();
      if (checking) {
        return !!activeFile;
      }
      if (activeFile) {
        const modal = new AddFileClassToFileModal(plugin, activeFile);
        modal.open();
      }
    }
  });
}
function addUpdateLookupsAndFormulas(plugin) {
  plugin.addCommand({
    id: "update_all_lookups",
    name: "Update all lookups and formulas",
    icon: "file-search",
    checkCallback: (checking) => {
      if (checking)
        return true;
      plugin.fieldIndex.fullIndex(true);
    }
  });
}
function addUpdateFileLookupsCommand(plugin) {
  const classFilesPath = plugin.settings.classFilesPath;
  plugin.addCommand({
    id: "update_file_lookups",
    name: "Update active file lookups fields",
    icon: "file-search",
    checkCallback: (checking) => {
      var _a;
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const inFile = !!((view == null ? void 0 : view.file) && (!classFilesPath || !view.file.path.startsWith(classFilesPath)));
      if (checking) {
        return inFile;
      }
      if (inFile) {
        const file = view.file;
        if (inFile && file instanceof import_obsidian59.TFile && file.extension === "md") {
          const lookupFields = (_a = plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a.filter((field) => field.type === "Lookup" /* Lookup */);
          lookupFields == null ? void 0 : lookupFields.forEach(async (field) => {
            await updateLookups(plugin, { file, fieldName: field.name });
            await plugin.fieldIndex.applyUpdates();
          });
        }
      }
    }
  });
}
function addUpdateFileFormulasCommand(plugin) {
  const classFilesPath = plugin.settings.classFilesPath;
  plugin.addCommand({
    id: "update_file_formulas",
    name: "Update active file formulas fields",
    icon: "function-square",
    checkCallback: (checking) => {
      var _a;
      const view = plugin.app.workspace.getActiveViewOfType(import_obsidian59.MarkdownView);
      const inFile = !!((view == null ? void 0 : view.file) && (!classFilesPath || !view.file.path.startsWith(classFilesPath)));
      if (checking) {
        return inFile;
      }
      if (inFile) {
        const file = view.file;
        if (inFile && file instanceof import_obsidian59.TFile && file.extension === "md") {
          const formulaFields = (_a = plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a.filter((field) => field.type === "Formula" /* Formula */);
          formulaFields == null ? void 0 : formulaFields.forEach(async (field) => {
            await updateFormulas(plugin, { file, fieldName: field.name });
            await plugin.fieldIndex.applyUpdates();
          });
        }
      }
    }
  });
}
function addCommands(plugin) {
  addFileClassAttributeOptions(plugin);
  addInsertFileClassAttribute(plugin);
  addFieldOptionsCommand(plugin);
  addInsertFieldAtPositionCommand(plugin);
  addManageFieldAtCursorCommand(plugin);
  insertMissingFieldsCommand(plugin);
  addOpenFieldsModalCommand(plugin);
  addInsertFieldsCommand(plugin);
  addUpdateFileLookupsCommand(plugin);
  addUpdateFileFormulasCommand(plugin);
  addOpenFileclassViewCommand(plugin);
  addFileclassToFileCommand(plugin);
  addUpdateLookupsAndFormulas(plugin);
}

// src/components/ContextMenu.ts
var import_obsidian60 = require("obsidian");
var ContextMenu = class extends import_obsidian60.Component {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.fileContextMenuOpened = false;
  }
  onload() {
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("file-menu", async (menu, abstractFile, source) => {
        this.fileContextMenuOpened = true;
        const file = this.plugin.app.vault.getAbstractFileByPath(abstractFile.path);
        this.buildOptions(file, menu);
        menu.onHide = () => {
          this.fileContextMenuOpened = false;
        };
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.workspace.on("editor-menu", (menu, editor, view) => {
        if (!this.fileContextMenuOpened) {
          const file = this.plugin.app.workspace.getActiveFile();
          this.buildOptions(file, menu);
        }
      })
    );
  }
  buildOptions(file, menu) {
    const classFilesPath = this.plugin.settings.classFilesPath;
    if (file instanceof import_obsidian60.TFile && file.extension === "md") {
      if (!import_obsidian60.Platform.isMobile && (0, import_obsidian60.requireApiVersion)("0.16.0")) {
        if (classFilesPath && file.path.startsWith(classFilesPath)) {
          const fileClassName = FileClass.getFileClassNameFromPath(this.plugin.settings, file.path);
          menu.setSectionSubmenu(
            `metadata-menu-fileclass.${fileClassName}.fileclass-fields`,
            { title: "Manage fields", icon: "wrench" }
          );
        } else {
          const fileClasses = this.plugin.fieldIndex.filesFileClasses.get(file.path) || [];
          fileClasses.forEach((fileClass) => {
            menu.setSectionSubmenu(
              `metadata-menu-fileclass.${fileClass.name}.fileclass-fields`,
              { title: `Manage ${fileClass.name} fields`, icon: "wrench" }
            );
          });
        }
      }
      if (this.plugin.settings.displayFieldsInContextMenu) {
        if (classFilesPath && file.path.startsWith(classFilesPath)) {
          const fileClassOptionsList = new FileClassOptionsList(this.plugin, file, menu);
          fileClassOptionsList.createExtraOptionList();
        } else {
          const optionsList = new OptionsList(this.plugin, file, menu);
          optionsList.createContextMenuOptionsList();
        }
        ;
      } else {
        menu.addItem((item) => {
          item.setIcon("list");
          item.setTitle("Field Options");
          item.onClick(async () => {
            const fieldCommandSuggestModal = new FieldCommandSuggestModal(this.plugin.app);
            const optionsList = new OptionsList(this.plugin, file, fieldCommandSuggestModal);
            await optionsList.createExtraOptionList();
          });
        });
      }
    }
    ;
  }
};

// src/components/ExtraButton.ts
var import_obsidian63 = require("obsidian");

// src/options/linkAttributes.ts
var import_obsidian61 = require("obsidian");
function clearExtraAttributes(link) {
  Object.values(link.attributes).forEach((attr) => {
    if (attr.name.includes("fileclass-name")) {
      link.removeAttribute(attr.name);
      const el = link.nextElementSibling;
      if (el == null ? void 0 : el.hasClass("fileclass-icon")) {
        el.remove();
      }
    }
  });
}
function setLinkMetadataFormButton(plugin, link, destPath, viewTypeName, fileClassName) {
  var _a, _b;
  const setStatus = (el) => {
    const path = destPath + ".md";
    el.removeClass("field-status-changed");
    el.removeClass("field-status-error");
    el.removeClass("field-status-may-have-changed");
    const changed = plugin.fieldIndex.dvQFieldChanged(path);
    const error = plugin.fieldIndex.dvQFieldHasAnError(path);
    const mayHaveChanged = plugin.fieldIndex.dvQFieldMayHaveChanged(path);
    if (error)
      el.addClass("field-status-error");
    else if (changed)
      el.addClass("field-status-changed");
    else if (mayHaveChanged)
      el.addClass("field-status-may-have-changed");
  };
  if (link.classList.contains("metadata-menu-button-hidden"))
    return;
  switch (viewTypeName) {
    case "a.internal-link":
      if (!plugin.settings.enableLinks)
        return;
      break;
    case "properties":
      if (!plugin.settings.enableLinks)
        return;
      break;
    case "tabHeader":
      if (!plugin.settings.enableTabHeader)
        return;
      break;
    case "starred":
      if (!plugin.settings.enableStarred)
        return;
      break;
    case "bookmarks":
      if (!plugin.settings.enableStarred)
        return;
      break;
    case "file-explorer":
      if (!plugin.settings.enableFileExplorer)
        return;
      break;
    case "backlink":
      if (!plugin.settings.enableBacklinks)
        return;
      break;
    case "search":
      if (!plugin.settings.enableSearch)
        return;
      break;
    case "outgoing-link":
      if (!plugin.settings.enableBacklinks)
        return;
      break;
    default:
      return;
  }
  for (const a of link.attributes) {
    if (a.name.includes("fileclass-name") && a.name !== fileClassName) {
      link.removeAttribute(a.name);
      const el = link.nextElementSibling;
      if (el == null ? void 0 : el.hasClass("fileclass-icon")) {
        el.remove();
      }
    }
  }
  if (!plugin.fieldIndex.indexableFiles().map((f) => f.path).includes(`${destPath}.md`) && !plugin.fieldIndex.indexableFileClasses().map((f) => f.path).includes(`${destPath}.md`))
    return;
  const classFilessPath = plugin.settings.classFilesPath;
  const fileClass = plugin.fieldIndex.fileClassesPath.get(destPath + ".md");
  if (classFilessPath && fileClass) {
    const icon = fileClass.getIcon();
    link.setAttribute("fileclass-name", fileClass.name);
    const el = link.nextElementSibling;
    if (!(el == null ? void 0 : el.hasClass("fileclass-icon"))) {
      const metadataMenuBtn = plugin.app.workspace.containerEl.createEl("a", { cls: "metadata-menu fileclass-icon" });
      setStatus(metadataMenuBtn);
      if (metadataMenuBtn) {
        (0, import_obsidian61.setIcon)(metadataMenuBtn, icon);
        (_a = link.parentElement) == null ? void 0 : _a.insertBefore(metadataMenuBtn, link.nextSibling);
        metadataMenuBtn.onclick = (event) => {
          const fileClassViewManager = new FileClassViewManager(plugin, fileClass);
          plugin.addChild(fileClassViewManager);
          fileClassViewManager.build();
          event.stopPropagation();
        };
      }
    } else {
      setStatus(el);
    }
  } else if (fileClassName) {
    const fileClass2 = plugin.fieldIndex.fileClassesName.get(fileClassName);
    if (fileClass2) {
      const icon = fileClass2.getIcon();
      link.setAttribute("fileclass-name", fileClassName);
      const el = link.nextElementSibling;
      if (!(el == null ? void 0 : el.hasClass("fileclass-icon"))) {
        const metadataMenuBtn = plugin.app.workspace.containerEl.createEl("a", { cls: "metadata-menu fileclass-icon" });
        setStatus(metadataMenuBtn);
        if (metadataMenuBtn) {
          (0, import_obsidian61.setIcon)(metadataMenuBtn, icon || plugin.settings.fileClassIcon);
          (_b = link.parentElement) == null ? void 0 : _b.insertBefore(metadataMenuBtn, link.nextSibling);
          if (viewTypeName === "a.internal-link" && metadataMenuBtn.closest(".fv-table"))
            metadataMenuBtn.addClass("dataview-fileclass-icon");
          metadataMenuBtn.onclick = (event) => {
            const file = plugin.app.vault.getAbstractFileByPath(`${destPath}.md`);
            if (file instanceof import_obsidian61.TFile && file.extension === "md") {
              const noteFieldsComponent = new NoteFieldsComponent(plugin, "1", () => {
              }, file);
              plugin.addChild(noteFieldsComponent);
            }
            event.stopPropagation();
          };
        }
      } else {
        setStatus(el);
      }
    }
  }
}
function updateLinkMetadataMenuFormButton(app2, plugin, link, viewTypeName, source) {
  var _a, _b;
  const linkHref = (_a = link.getAttribute("href")) == null ? void 0 : _a.split("#")[0];
  const dest = linkHref && app2.metadataCache.getFirstLinkpathDest(linkHref, source);
  if (dest) {
    const fileClassName = (_b = plugin.fieldIndex.filesFileClassesNames.get(dest.path)) == null ? void 0 : _b.last();
    setLinkMetadataFormButton(plugin, link, dest.path.replace(/(.*).md/, "$1"), viewTypeName, fileClassName);
  }
}
function updateDivExtraAttributes(app2, plugin, link, viewTypeName, sourceName, _linkName) {
  var _a, _b, _c, _d, _e;
  switch (viewTypeName) {
    case "file-explorer":
      {
        const dataPath = (_a = link == null ? void 0 : link.parentElement) == null ? void 0 : _a.dataset.path;
        if (dataPath) {
          const fileClassName = (_b = plugin.fieldIndex.filesFileClassesNames.get(dataPath)) == null ? void 0 : _b.last();
          setLinkMetadataFormButton(plugin, link, dataPath.replace(/(.*).md/, "$1"), viewTypeName, fileClassName);
        }
      }
      break;
    case "tabHeader":
      {
        if (sourceName) {
          const fileClassName = (_c = plugin.fieldIndex.filesFileClassesNames.get(sourceName)) == null ? void 0 : _c.last();
          setLinkMetadataFormButton(plugin, link, sourceName.replace(/(.*).md/, "$1"), viewTypeName, fileClassName);
        }
      }
      break;
    case "outgoing-link":
      {
        const dest = link.innerText.split("\n")[0];
        if (dest) {
          const fileClassName = (_d = plugin.fieldIndex.filesFileClassesNames.get(`${dest}.md`)) == null ? void 0 : _d.last();
          setLinkMetadataFormButton(plugin, link, dest, viewTypeName, fileClassName);
        }
      }
      break;
    default:
      {
        const linkName = _linkName || link.textContent;
        const dest = linkName && app2.metadataCache.getFirstLinkpathDest((0, import_obsidian61.getLinkpath)(linkName), sourceName);
        if (dest) {
          const fileClassName = (_e = plugin.fieldIndex.filesFileClassesNames.get(dest.path)) == null ? void 0 : _e.last();
          setLinkMetadataFormButton(plugin, link, dest.path.replace(/(.*).md/, "$1"), viewTypeName, fileClassName);
        }
      }
      break;
  }
}
function updateElLinks(app2, plugin, el, ctx) {
  const links = el.querySelectorAll("a.internal-link");
  const source = ctx.sourcePath.replace(/(.*).md/, "$1");
  links.forEach((link) => {
    updateLinkMetadataMenuFormButton(app2, plugin, link, "a.internal-link", source);
  });
}
function updatePropertiesPane(propertiesEl, file, app2, plugin) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const frontmatter = (_a = app2.metadataCache.getCache(file.path)) == null ? void 0 : _a.frontmatter;
  if (!!frontmatter) {
    const nodes = propertiesEl.querySelectorAll("div.internal-link > .multi-select-pill-content");
    for (let i = 0; i < nodes.length; ++i) {
      const el = nodes[i];
      const linkText = el.textContent;
      const keyEl = (_e = (_d = (_c = (_b = el == null ? void 0 : el.parentElement) == null ? void 0 : _b.parentElement) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.parentElement) == null ? void 0 : _e.children[0].children[1];
      const key = keyEl.value;
      const listOfLinks = frontmatter[key];
      let foundS = null;
      if (!listOfLinks) {
        continue;
      }
      for (const s of listOfLinks) {
        if (s.length > 4 && s.startsWith("[[") && s.endsWith("]]")) {
          const slicedS = s.slice(2, -2);
          const split = slicedS.split("|");
          if (split.length == 1 && split[0] == linkText) {
            foundS = split[0];
            break;
          } else if (split.length == 2 && split[1] == linkText) {
            foundS = split[0];
            break;
          }
        }
      }
      if (!!foundS) {
        updateDivExtraAttributes(plugin.app, plugin, el, "properties", foundS);
      }
    }
    const singleNodes = propertiesEl.querySelectorAll("div.metadata-link-inner");
    for (let i = 0; i < singleNodes.length; ++i) {
      const el = singleNodes[i];
      const linkText = el.textContent;
      const keyEl = (_h = (_g = (_f = el == null ? void 0 : el.parentElement) == null ? void 0 : _f.parentElement) == null ? void 0 : _g.parentElement) == null ? void 0 : _h.children[0].children[1];
      const key = keyEl.value;
      const link = frontmatter[key];
      if (!link) {
        continue;
      }
      let foundS = null;
      if (link.length > 4 && link.startsWith("[[") && link.endsWith("]]")) {
        const slicedS = link.slice(2, -2);
        const split = slicedS.split("|");
        if (split.length == 1 && split[0] == linkText) {
          foundS = split[0];
        } else if (split.length == 2 && split[1] == linkText) {
          foundS = split[0];
        }
      }
      if (!!foundS) {
        updateDivExtraAttributes(plugin.app, plugin, el, "properties", foundS);
      }
    }
  }
}
function updateVisibleLinks(app2, plugin) {
  const settings = plugin.settings;
  app2.workspace.iterateRootLeaves((leaf) => {
    var _a;
    if (leaf.view instanceof import_obsidian61.MarkdownView && leaf.view.file) {
      const file = leaf.view.file;
      const cachedFile = app2.metadataCache.getFileCache(file);
      const fileName = file.path.replace(/(.*).md/, "$1");
      const metadata = (_a = leaf.view) == null ? void 0 : _a.metadataEditor.contentEl;
      if (!!metadata) {
        updatePropertiesPane(metadata, file, app2, plugin);
      }
      const tabHeader = leaf.tabHeaderInnerTitleEl;
      if (settings.enableTabHeader) {
        updateDivExtraAttributes(app2, plugin, tabHeader, "tabHeader", leaf.view.file.path);
      } else {
        clearExtraAttributes(tabHeader);
      }
      if ((cachedFile == null ? void 0 : cachedFile.links) && settings.enableLinks) {
        cachedFile.links.forEach((link) => {
          var _a2;
          const dest = app2.metadataCache.getFirstLinkpathDest(link.link, fileName);
          if (dest) {
            const fileClassName = (_a2 = plugin.fieldIndex.filesFileClassesNames.get(dest.path)) == null ? void 0 : _a2.last();
            const internalLinks = leaf.view.containerEl.querySelectorAll(`a.internal-link[href="${link.link}"]`);
            internalLinks.forEach((internalLink) => setLinkMetadataFormButton(plugin, internalLink, dest.path.replace(/(.*).md/, "$1"), `a.internal-link`, fileClassName));
          }
        });
      }
    }
  });
}

// src/components/ExtraButton.ts
var import_state4 = require("@codemirror/state");

// src/options/livePreview.ts
var import_obsidian62 = require("obsidian");
var import_view3 = require("@codemirror/view");
var import_state3 = require("@codemirror/state");
var import_language4 = require("@codemirror/language");
var import_language5 = require("@codemirror/language");
function buildCMViewPlugin(plugin) {
  class HeaderWidget extends import_view3.WidgetType {
    constructor(fileClassName, after, destName) {
      super();
      this.fileClassName = fileClassName;
      this.after = after;
      this.destName = destName;
    }
    toDOM() {
      let metadataMenuBtn = document.createElement("span");
      if (this.fileClassName) {
        metadataMenuBtn.setAttr("fileclass-name", this.fileClassName);
        metadataMenuBtn.addClass("fileclass-icon");
        metadataMenuBtn.addClass("metadata-menu");
        let fileClass = plugin.fieldIndex.fileClassesName.get(this.fileClassName);
        const classFilesPath = plugin.settings.classFilesPath;
        if (classFilesPath && this.destName.includes(classFilesPath)) {
          const icon = (fileClass == null ? void 0 : fileClass.getIcon()) || "file-spreadsheet";
          fileClass = plugin.fieldIndex.fileClassesPath.get(this.destName + ".md");
          if (fileClass) {
            (0, import_obsidian62.setIcon)(metadataMenuBtn, icon || settings.fileClassIcon);
            metadataMenuBtn.onclick = (event) => {
              const fileClassViewManager = new FileClassViewManager(plugin, fileClass);
              plugin.addChild(fileClassViewManager);
              fileClassViewManager.build();
              event.stopPropagation();
            };
          }
        } else if (fileClass) {
          const icon = fileClass.getIcon();
          (0, import_obsidian62.setIcon)(metadataMenuBtn, icon || settings.fileClassIcon);
          metadataMenuBtn.onclick = (event) => {
            const file = plugin.app.vault.getAbstractFileByPath(`${this.destName}.md`);
            if (file instanceof import_obsidian62.TFile && file.extension === "md") {
              const noteFieldsComponent = new NoteFieldsComponent(plugin, "1", () => {
              }, file);
              plugin.addChild(noteFieldsComponent);
            }
            event.stopPropagation();
          };
        }
      }
      return metadataMenuBtn;
    }
    ignoreEvent() {
      return true;
    }
  }
  const settings = plugin.settings;
  const viewPlugin = import_view3.ViewPlugin.fromClass(
    class {
      constructor(view) {
        this.decorations = this.buildDecorations(view);
      }
      update(update) {
        if (update.docChanged || update.viewportChanged) {
          this.decorations = this.buildDecorations(update.view);
        }
      }
      destroy() {
      }
      buildDecorations(view) {
        let builder = new import_state3.RangeSetBuilder();
        if (!settings.enableEditor) {
          return builder.finish();
        }
        const mdView = view.state.field(import_obsidian62.editorInfoField);
        let lastAttributes = {};
        let iconDecoAfter = null;
        let iconDecoAfterWhere = null;
        let mdAliasFrom = null;
        let mdAliasTo = null;
        for (let { from, to } of view.visibleRanges) {
          (0, import_language4.syntaxTree)(view.state).iterate({
            from,
            to,
            enter: (node) => {
              var _a;
              const tokenProps = node.type.prop(import_language5.tokenClassNodeProp);
              if (tokenProps) {
                const props = new Set(tokenProps.split(" "));
                const isLink = props.has("hmd-internal-link");
                const isAlias2 = props.has("link-alias");
                const isPipe = props.has("link-alias-pipe");
                const isMDLink = props.has("link");
                const isMDUrl = props.has("url");
                const isMDFormatting = props.has("formatting-link");
                if (isMDLink && !isMDFormatting) {
                  mdAliasFrom = node.from;
                  mdAliasTo = node.to;
                }
                if (!isPipe && !isAlias2) {
                  if (iconDecoAfter && iconDecoAfterWhere) {
                    builder.add(iconDecoAfterWhere, iconDecoAfterWhere, iconDecoAfter);
                    iconDecoAfter = null;
                    iconDecoAfterWhere = null;
                  }
                }
                if (mdView.file && isLink && !isAlias2 && !isPipe || isMDUrl) {
                  let linkText = view.state.doc.sliceString(node.from, node.to);
                  linkText = linkText.split("#")[0];
                  let file = plugin.app.metadataCache.getFirstLinkpathDest(linkText, mdView.file.basename);
                  if (isMDUrl && !file) {
                    try {
                      file = plugin.app.vault.getAbstractFileByPath(decodeURIComponent(linkText));
                    } catch (e) {
                    }
                  }
                  if (file) {
                    let fileClassName;
                    if (plugin.settings.classFilesPath && file.path.startsWith(plugin.settings.classFilesPath))
                      fileClassName = file.basename;
                    else
                      fileClassName = (_a = plugin.fieldIndex.filesFileClassesNames.get(file.path)) == null ? void 0 : _a.last();
                    if (fileClassName) {
                      const attributes = { "fileclass-name": fileClassName };
                      let deco = import_view3.Decoration.mark({
                        attributes,
                        class: "fileclass-text"
                      });
                      iconDecoAfter = import_view3.Decoration.widget({
                        widget: new HeaderWidget(fileClassName, true, file.path.replace(/(.*).md/, "$1"))
                      });
                      if (isMDUrl && mdAliasFrom && mdAliasTo) {
                        let deco2 = import_view3.Decoration.mark({
                          attributes,
                          class: "fileclass-text"
                        });
                        builder.add(mdAliasFrom, mdAliasTo, deco2);
                        if (iconDecoAfter) {
                          builder.add(mdAliasTo, mdAliasTo, iconDecoAfter);
                          iconDecoAfter = null;
                          iconDecoAfterWhere = null;
                          mdAliasFrom = null;
                          mdAliasTo = null;
                        }
                      }
                      builder.add(node.from, node.to, deco);
                      lastAttributes = attributes;
                      iconDecoAfterWhere = node.to;
                    }
                  }
                } else if (isLink && isAlias2) {
                  let deco = import_view3.Decoration.mark({
                    attributes: lastAttributes,
                    class: "fileclass-text"
                  });
                  builder.add(node.from, node.to, deco);
                  if (iconDecoAfter) {
                    builder.add(node.to, node.to, iconDecoAfter);
                    iconDecoAfter = null;
                    iconDecoAfterWhere = null;
                  }
                }
              }
            }
          });
        }
        return builder.finish();
      }
    },
    {
      decorations: (v) => v.decorations
    }
  );
  return viewPlugin;
}

// src/components/ExtraButton.ts
var ExtraButton = class extends import_obsidian63.Component {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.modalObservers = [];
    this.updateLinks = () => {
      updateVisibleLinks(this.plugin.app, this.plugin);
      this.observers.forEach(([observer, type, own_class]) => {
        const leaves = this.plugin.app.workspace.getLeavesOfType(type);
        leaves.forEach((leaf) => {
          this.updateContainer(leaf.view.containerEl, own_class, type);
        });
      });
    };
  }
  onload() {
    this.plugin.registerMarkdownPostProcessor((el, ctx) => {
      updateElLinks(this.plugin.app, this.plugin, el, ctx);
    });
    const ext = import_state4.Prec.lowest(buildCMViewPlugin(this.plugin));
    this.plugin.registerEditorExtension(ext);
    this.observers = [];
    this.plugin.app.workspace.onLayoutReady(() => {
      this.initViewObservers();
      this.initModalObservers(document);
      updateVisibleLinks(this.plugin.app, this.plugin);
    });
    this.registerEvent(this.plugin.app.metadataCache.on("changed", (0, import_obsidian63.debounce)(this.updateLinks, 100, true)));
    this.registerEvent(this.plugin.app.workspace.on("metadata-menu:indexed", (0, import_obsidian63.debounce)(this.updateLinks, 100, true)));
    this.registerEvent(this.plugin.app.workspace.on("layout-change", (0, import_obsidian63.debounce)(this.updateLinks, 10, true)));
    this.registerEvent(this.plugin.app.workspace.on("window-open", (window2, win) => this.initModalObservers(window2.getContainer().doc)));
    this.registerEvent(this.plugin.app.workspace.on("layout-change", () => this.initViewObservers()));
    this.registerEvent(this.plugin.app.internalPlugins.getPluginById("bookmarks").instance.on("changed", (0, import_obsidian63.debounce)(this.updateLinks, 100, true)));
  }
  initViewObservers() {
    var _a, _b, _c, _d, _e, _f;
    this.observers.forEach(([observer, type]) => {
      observer.disconnect();
    });
    this.observers = [];
    this.registerViewType("backlink", ".tree-item-inner", true);
    this.registerViewType("outgoing-link", ".tree-item-inner", true);
    this.registerViewType("search", ".tree-item-inner", true);
    this.registerViewType("BC-matrix", ".BC-Link");
    this.registerViewType("BC-ducks", ".internal-link");
    this.registerViewType("BC-tree", "a.internal-link");
    this.registerViewType("graph-analysis", ".internal-link");
    this.registerViewType("starred", ".nav-file-title-content", true);
    this.registerViewType("file-explorer", ".nav-file-title-content", true);
    this.registerViewType("recent-files", ".nav-file-title-content", true);
    if ((_f = (_e = (_d = (_c = (_b = (_a = this.plugin.app) == null ? void 0 : _a.internalPlugins) == null ? void 0 : _b.plugins) == null ? void 0 : _c.backlink) == null ? void 0 : _d.instance) == null ? void 0 : _e.options) == null ? void 0 : _f.backlinkInDocument) {
      this.registerViewType("markdown", ".tree-item-inner", true);
    }
  }
  initModalObservers(doc) {
    var _a;
    const config = {
      subtree: false,
      childList: true,
      attributes: false
    };
    this.modalObservers.push(new MutationObserver((records) => {
      records.forEach((mutation) => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((n) => {
            if ("className" in n && // @ts-ignore
            (n.className.includes("modal-container") && this.plugin.settings.enableQuickSwitcher || n.className.includes("suggestion-container") && this.plugin.settings.enableSuggestor)) {
              let selector = ".suggestion-title, .suggestion-note, .another-quick-switcher__item__title, .omnisearch-result__title";
              if (n.className.includes("suggestion-container")) {
                selector = ".suggestion-title, .suggestion-note";
              }
              this.updateContainer(n, selector, null);
              this._watchContainer(null, n, selector);
            }
          });
        }
      });
    }));
    (_a = this.modalObservers.last()) == null ? void 0 : _a.observe(doc.body, config);
  }
  registerViewType(viewTypeName, selector, updateDynamic = false) {
    const leaves = this.plugin.app.workspace.getLeavesOfType(viewTypeName);
    if (leaves.length > 1) {
      for (let i = 0; i < leaves.length; i++) {
        const container = leaves[i].view.containerEl;
        if (updateDynamic) {
          this._watchContainerDynamic(viewTypeName + i, container, selector);
        } else {
          this._watchContainer(viewTypeName + i, container, selector);
        }
      }
    } else if (leaves.length < 1)
      return;
    else {
      const container = leaves[0].view.containerEl;
      this.updateContainer(container, selector, viewTypeName);
      if (updateDynamic) {
        this._watchContainerDynamic(viewTypeName, container, selector);
      } else {
        this._watchContainer(viewTypeName, container, selector);
      }
    }
  }
  updateContainer(container, selector, viewTypeName) {
    var _a, _b;
    const nodes = container.findAll(selector);
    for (let i = 0; i < nodes.length; ++i) {
      const el = nodes[i];
      const isCanvasFileLink = (_b = (_a = el.parentElement) == null ? void 0 : _a.getAttr("data-path")) == null ? void 0 : _b.includes(".canvas");
      if (!isCanvasFileLink) {
        updateDivExtraAttributes(this.plugin.app, this.plugin, el, viewTypeName, "");
      }
    }
  }
  removeFromContainer(container, selector) {
    const nodes = container.findAll(selector);
    for (let i = 0; i < nodes.length; ++i) {
      const el = nodes[i];
      clearExtraAttributes(el);
    }
  }
  _watchContainer(viewType, container, selector) {
    let observer = new MutationObserver((records, _) => {
      this.updateContainer(container, selector, viewType);
    });
    observer.observe(container, { subtree: true, childList: true, attributes: false });
    if (viewType) {
      this.observers.push([observer, viewType, selector]);
    }
  }
  _watchContainerDynamic(viewType, container, selector, ownClass = "tree-item-inner", parent_class = "tree-item") {
    let observer = new MutationObserver((records, _) => {
      records.forEach((mutation) => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach((n) => {
            if ("className" in n) {
              if (n.className.includes && typeof n.className.includes === "function" && n.className.includes(parent_class)) {
                const fileDivs = n.getElementsByClassName(ownClass);
                for (let i = 0; i < fileDivs.length; ++i) {
                  const link = fileDivs[i];
                  updateDivExtraAttributes(this.plugin.app, this.plugin, link, viewType, "");
                }
              }
            }
          });
        }
      });
    });
    observer.observe(container, { subtree: true, childList: true, attributes: false });
    this.observers.push([observer, viewType, selector]);
  }
  reloadObservers() {
    this.disconnectObservers();
    this.initModalObservers(document);
    this.initViewObservers();
    updateVisibleLinks(this.plugin.app, this.plugin);
  }
  disconnectObservers() {
    this.observers.forEach(([observer, type, own_class]) => {
      observer.disconnect();
      const leaves = this.plugin.app.workspace.getLeavesOfType(type);
      leaves.forEach((leaf) => {
        this.removeFromContainer(leaf.view.containerEl, own_class);
      });
    });
    for (const observer of this.modalObservers) {
      observer.disconnect();
    }
  }
  onunload() {
    this.disconnectObservers();
  }
};

// src/index/FieldIndex.ts
var import_obsidian67 = require("obsidian");

// src/fileClass/FileClassQuery.ts
var import_obsidian64 = require("obsidian");
var FileClassQuery = class {
  constructor(name = "", id = "", query = "", fileClassName = "") {
    this.name = name;
    this.id = id;
    this.query = query;
    this.fileClassName = fileClassName;
  }
  //@ts-ignore
  getResults(api) {
    try {
      return new Function("dv", `return ${this.query}`)(api);
    } catch (error) {
      new import_obsidian64.Notice(` for <${this.name}>. Check your settings`);
      return [];
    }
  }
  matchFile(file) {
    const dataview = app.plugins.plugins.dataview;
    if (this.query && (dataview == null ? void 0 : dataview.settings.enableDataviewJs) && (dataview == null ? void 0 : dataview.settings.enableInlineDataviewJs)) {
      try {
        const filesPath = this.getResults(dataview.api).values.map((v) => v.file.path);
        return filesPath.includes(file.path);
      } catch (error) {
        return false;
      }
    } else {
      return false;
    }
  }
  static copyProperty(target, source) {
    target.id = source.id;
    target.name = source.name;
    target.query = source.query;
    target.fileClassName = source.fileClassName;
  }
};
var FileClassQuery_default = FileClassQuery;

// src/commands/resolveLookups.ts
function resolveLookups(plugin) {
  var _a, _b;
  const index = plugin.fieldIndex;
  const lookupQueryResults = /* @__PURE__ */ new Map();
  [...index.lookupQueries].forEach(([lookupName, field]) => {
    const queryRelatedDVFiles = new Function("dv", `return ${field.options.dvQueryString}`)(index.dv.api).values;
    lookupQueryResults.set(lookupName, queryRelatedDVFiles);
  });
  [...index.filesLookupAndFormulaFieldsExists].forEach(([filePath, fields]) => {
    fields.filter((field) => field.type === "Lookup" /* Lookup */).forEach((lookupField) => {
      const queryRelatedDVFiles = lookupQueryResults.get(`${lookupField.fileClassName || "presetField"}___${lookupField.name}`) || [];
      const fileRelatedDVFiles = queryRelatedDVFiles.filter((dvFile) => {
        const targetValue = dvFile[lookupField.options.targetFieldName];
        if (Array.isArray(targetValue)) {
          return targetValue.filter((v) => index.dv.api.value.isLink(v)).map((v) => v.path).includes(filePath);
        } else {
          return (targetValue == null ? void 0 : targetValue.path) === filePath;
        }
      });
      const relatedFieldName = `${filePath}__related__${lookupField.fileClassName || "presetField"}___${lookupField.name}`;
      index.fileLookupFiles.set(relatedFieldName, fileRelatedDVFiles);
    });
  });
  for (let id of index.fileLookupFiles.keys()) {
    const matchRegex = /(?<filePath>.*)__related__(?<fileClassName>.*)___(?<fieldName>.*)/;
    const { filePath, fileClassName, fieldName } = ((_a = id.match(matchRegex)) == null ? void 0 : _a.groups) || {};
    const existingLookFieldWithNameAndFileClassName = (_b = index.filesFields.get(filePath)) == null ? void 0 : _b.find(
      (field) => field.name === fieldName && (field.fileClassName === void 0 && fileClassName === "presetField" || field.fileClassName === fileClassName)
    );
    const dvPage = index.dv.api.page(filePath);
    if (dvPage === void 0 || dvPage[fieldName] === void 0 || !existingLookFieldWithNameAndFileClassName) {
      index.fileLookupFiles.delete(id);
      index.fileLookupFieldLastValue.delete(id);
      index.fileLookupFieldLastOutputType.delete(id);
      index.fileLookupFieldsStatus.delete(`${filePath}__${fieldName}`);
    }
  }
}

// src/commands/updateCanvas.ts
var import_obsidian65 = require("obsidian");
async function updateCanvas(plugin, forceUpdateOne) {
  var _a;
  const start2 = Date.now();
  const f = plugin.fieldIndex;
  const dvApi = (_a = plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
  const canvases = forceUpdateOne ? [forceUpdateOne.canvas] : plugin.app.vault.getFiles().filter((t) => t.extension === "canvas");
  const isNodeInGroup = (node, group) => {
    const { x: x1, y: y1, width: w1, height: h1 } = node;
    const { x: x2, y: y2, width: w2, height: h2 } = group;
    return x2 <= x1 && y2 <= y1 && x2 + w2 >= x1 + w1 && y2 + h2 >= y1 + h1;
  };
  const orientedEdges = (direction, edges, node) => {
    switch (direction) {
      case "incoming":
        return edges.filter((edge) => edge.toNode === node.id);
      case "outgoing":
        return edges.filter((edge) => edge.fromNode === node.id);
      case "bothsides":
        return edges.filter((edge) => edge.fromNode === node.id || edge.toNode === node.id);
      default:
        return [];
    }
  };
  const targetNode = (direction, edge, nodes, currentNode) => {
    switch (direction) {
      case "incoming":
        return nodes.find((node) => node.id !== currentNode.id && node.id === edge.fromNode);
      case "outgoing":
        return nodes.find((node) => node.id !== currentNode.id && node.id === edge.toNode);
      case "bothsides":
        return nodes.find((node) => node.id !== currentNode.id && (node.id === edge.toNode || node.id === edge.fromNode));
      default:
        return void 0;
    }
  };
  const resolveFieldLinksForNode = (field, targetFilePath, edges, nodes, node, cumulativeSet) => {
    const { nodeColors, edgeColors, edgeFromSides, edgeToSides, edgeLabels, filesFromDVQuery, direction } = field.options;
    const matchingFiles = filesFromDVQuery && dvApi ? new Function("dv", "current", `return ${filesFromDVQuery}`)(dvApi, dvApi.page(targetFilePath)) : void 0;
    const matchingEdges = orientedEdges(direction, edges, node);
    const linkNodes = matchingEdges.filter(
      (edge) => !edgeLabels || edgeLabels.length === 0 || edgeLabels.includes(edge.label)
    ).filter(
      (edge) => !edgeColors || edgeColors.length === 0 || !edge.color && edgeColors.includes("0") || edgeColors.includes(edge.color)
    ).filter(
      (edge) => !edgeFromSides || edgeFromSides.length === 0 || edgeFromSides.includes(edge.fromSide)
    ).filter(
      (edge) => !edgeToSides || edgeToSides.length === 0 || edgeToSides.includes(edge.toSide)
    ).map((edge) => targetNode(direction, edge, nodes, node)).filter((node2) => !!node2 && node2.type === "file").filter(
      (node2) => !nodeColors || nodeColors.length === 0 || !node2.color && nodeColors.includes("0") || nodeColors.includes(node2.color)
    ).filter((node2) => {
      return matchingFiles === void 0 || matchingFiles.map((f2) => f2.file.path).includes(node2.file);
    });
    const uniqueLinkNodes = [...new Map(linkNodes.map((link) => [link.file, link])).values()];
    cumulativeSet.set(
      field.name,
      [
        ...cumulativeSet.get(field.name) || [],
        ...uniqueLinkNodes.filter(
          (link) => {
            var _a2;
            return !((_a2 = cumulativeSet.get(field.name)) == null ? void 0 : _a2.map((link2) => link2.id).includes(link.id));
          }
        )
      ]
    );
  };
  const filterGroupsForField = (field, canvasGroups, node) => {
    const { groupColors, groupLabels } = field.options;
    const groupNodes = canvasGroups.filter(
      (group) => !groupColors || groupColors.length === 0 || !group.color && groupColors.includes("0") || groupColors.includes(group.color)
    ).filter(
      (group) => !groupLabels || groupLabels.length === 0 || groupLabels.includes(group.label)
    ).filter((group) => isNodeInGroup(node, group));
    return groupNodes;
  };
  const resolveFieldGroupsForNode = (field, canvasGroups, node, cumulatedGroupsFields) => {
    const groupNodes = filterGroupsForField(field, canvasGroups, node);
    cumulatedGroupsFields.set(
      field.name,
      [
        ...cumulatedGroupsFields.get(field.name) || [],
        ...groupNodes.filter(
          (group) => {
            var _a2;
            return !((_a2 = cumulatedGroupsFields.get(field.name)) == null ? void 0 : _a2.map((group2) => group2.id).includes(group.id));
          }
        )
      ]
    );
  };
  canvases.forEach(async (canvas) => {
    const previousFilesPaths = plugin.fieldIndex.canvasLastFiles.get(canvas.path) || [];
    const currentFilesPaths = [];
    let { nodes, edges } = { nodes: [], edges: [] };
    const rawContent = await plugin.app.vault.read(canvas);
    if (rawContent) {
      try {
        const canvasContent = JSON.parse(rawContent);
        nodes = canvasContent.nodes;
        edges = canvasContent.edges;
      } catch (error) {
        DEBUG && console.log(error);
        new import_obsidian65.Notice(`Couldn't read ${canvas.path}`);
      }
    }
    const canvasGroups = nodes.filter((node) => node.type === "group");
    const currentFiles = /* @__PURE__ */ new Map();
    nodes.forEach(async (node) => {
      if (node.type === "file" && dvApi) {
        const { cumulatedLinksFields, cumulatedGroupsFields, cumulatedGroupsLinksFields } = currentFiles.get(node.file) || {
          cumulatedGroupsFields: /* @__PURE__ */ new Map(),
          cumulatedLinksFields: /* @__PURE__ */ new Map(),
          cumulatedGroupsLinksFields: /* @__PURE__ */ new Map()
        };
        const targetFilePath = node.file;
        if (!currentFilesPaths.includes(targetFilePath))
          currentFilesPaths.push(targetFilePath);
        const fileFields2 = f.filesFields.get(targetFilePath);
        const linksFields = fileFields2 == null ? void 0 : fileFields2.filter(
          (field) => field.type === "Canvas" /* Canvas */ && field.options.canvasPath === canvas.path
        );
        const groupsFields = fileFields2 == null ? void 0 : fileFields2.filter(
          (field) => field.type === "CanvasGroup" /* CanvasGroup */ && field.options.canvasPath === canvas.path
        );
        const groupsLinksFields = fileFields2 == null ? void 0 : fileFields2.filter(
          (field) => field.type === "CanvasGroupLink" /* CanvasGroupLink */ && field.options.canvasPath === canvas.path
        );
        linksFields == null ? void 0 : linksFields.forEach((field) => {
          resolveFieldLinksForNode(field, targetFilePath, edges, nodes, node, cumulatedLinksFields);
        });
        groupsFields == null ? void 0 : groupsFields.forEach((field) => {
          resolveFieldGroupsForNode(field, canvasGroups, node, cumulatedGroupsFields);
        });
        groupsLinksFields == null ? void 0 : groupsLinksFields.forEach((field) => {
          const groupNodes = filterGroupsForField(field, canvasGroups, node);
          groupNodes.forEach((node2) => {
            resolveFieldLinksForNode(field, targetFilePath, edges, nodes, node2, cumulatedGroupsLinksFields);
          });
          if (groupNodes.length === 0) {
            cumulatedGroupsLinksFields.set(
              field.name,
              [...cumulatedGroupsLinksFields.get(field.name) || []]
            );
          }
        });
        currentFiles.set(node.file, {
          cumulatedLinksFields,
          cumulatedGroupsFields,
          cumulatedGroupsLinksFields
        });
      }
    });
    currentFiles.forEach(async ({ cumulatedLinksFields, cumulatedGroupsFields, cumulatedGroupsLinksFields }, filePath) => {
      const file = plugin.app.vault.getAbstractFileByPath(filePath);
      if (file && file instanceof import_obsidian65.TFile) {
        const fields = plugin.fieldIndex.filesFields.get(file.path) || [];
        const payload = [];
        cumulatedLinksFields.forEach((linkNodes, name) => {
          const field = fields.find((_f) => _f.name === name);
          const values = linkNodes.map((node) => FieldManager2.buildMarkDownLink(plugin, file, node.file, node.subpath));
          if (field)
            payload.push({ id: field.id, payload: { value: values ? [...new Set(values)].join(",") : "" } });
        });
        cumulatedGroupsFields.forEach((groupNodes, name) => {
          const field = fields.find((_f) => _f.name === name);
          const values = groupNodes.map((group) => group.label);
          if (field)
            payload.push({ id: field.id, payload: { value: values ? [...new Set(values.filter((v) => !!v))].join(",") : "" } });
        });
        cumulatedGroupsLinksFields.forEach((linkNodes, name) => {
          const field = fields.find((_f) => _f.name === name);
          const values = linkNodes.map((node) => FieldManager2.buildMarkDownLink(plugin, file, node.file, node.subpath));
          if (field)
            payload.push({ id: field.id, payload: { value: values ? [...new Set(values)].join(",") : "" } });
        });
        if (payload.length)
          await postValues(plugin, payload, file);
      }
    });
    previousFilesPaths.filter((f2) => !currentFilesPaths.includes(f2)).forEach(async (filePath) => {
      var _a2, _b, _c;
      const targetFile = app.vault.getAbstractFileByPath(filePath);
      if (targetFile && targetFile instanceof import_obsidian65.TFile) {
        const payload = [];
        const canvasFields = (_a2 = f.filesFields.get(filePath)) == null ? void 0 : _a2.filter(
          (field) => field.type === "Canvas" /* Canvas */ && field.options.canvasPath === canvas.path
        );
        canvasFields == null ? void 0 : canvasFields.forEach((field) => {
          payload.push({ id: field.id, payload: { value: "" } });
        });
        const canvasGroupFields = (_b = f.filesFields.get(filePath)) == null ? void 0 : _b.filter(
          (field) => field.type === "CanvasGroup" /* CanvasGroup */ && field.options.canvasPath === canvas.path
        );
        canvasGroupFields == null ? void 0 : canvasGroupFields.forEach((field) => {
          payload.push({ id: field.id, payload: { value: "" } });
        });
        const canvasGroupLinksFields = (_c = f.filesFields.get(filePath)) == null ? void 0 : _c.filter(
          (field) => field.type === "CanvasGroupLink" /* CanvasGroupLink */ && field.options.canvasPath === canvas.path
        );
        canvasGroupLinksFields == null ? void 0 : canvasGroupLinksFields.forEach((field) => {
          payload.push({ id: field.id, payload: { value: "" } });
        });
        if (payload.length)
          await postValues(plugin, payload, targetFile);
      }
    });
    plugin.fieldIndex.canvasLastFiles.set(canvas.path, currentFilesPaths);
  });
}
async function updateCanvasAfterFileClass(plugin, files = []) {
  var _a, _b;
  for (const file of files) {
    const index = plugin.fieldIndex;
    if (index.classFilesPath && file.path.startsWith(this.classFilesPath)) {
      const fileClassName = (_a = index.fileClassesPath.get(file.path)) == null ? void 0 : _a.name;
      const canvasFields = fileClassName && ((_b = index.fileClassesFields.get(fileClassName)) == null ? void 0 : _b.filter((field) => field.type === "Canvas" /* Canvas */)) || [];
      await Promise.all(canvasFields.map(async (field) => {
        const canvasFile = this.plugin.app.vault.getAbstractFileByPath(field.options.canvasPath);
        if (canvasFile instanceof import_obsidian65.TFile && canvasFile.extension === "canvas") {
          await updateCanvas(this.plugin, { canvas: canvasFile });
        }
      }));
    }
  }
}

// src/fileClass/fileClassMigration.ts
var V1FileClassMigration = class {
  /*
  Moving fileClass fields definition from dataview inline fields to frontmatter yaml
  */
  constructor(plugin) {
    this.plugin = plugin;
  }
  static getInlineFileClassAttributes(plugin, fileClass, excludes) {
    var _a;
    const file = fileClass.getClassFile();
    let attributes = [];
    const dvApi = (_a = plugin.app.plugins.plugins["dataview"]) == null ? void 0 : _a.api;
    if (dvApi) {
      const dvFile = dvApi.page(file.path);
      try {
        legacyGenuineKeys(dvFile).forEach((key) => {
          if (key !== "file" && !Object.keys(dvFile.file.frontmatter || {}).includes(key)) {
            const item = typeof dvFile[key] !== "string" ? JSON.stringify(dvFile[key]) : dvFile[key];
            try {
              const { type, options: options2, command, display, style } = JSON.parse(item);
              const fieldType = FieldTypeLabelMapping[capitalize(type)];
              const attr = new FileClassAttribute(plugin, this.name, key, this.name, fieldType, options2, fileClass.name, command, display, style);
              attributes.push(attr);
            } catch (e) {
            }
          }
        });
      } catch (error) {
        throw error;
      }
    }
    if (excludes) {
      return attributes.filter((attr) => !excludes.includes(attr.name));
    } else {
      return attributes;
    }
  }
  async migrate(fileClass) {
    const file = fileClass.getClassFile();
    if (!fileClass.getMajorVersion() || fileClass.getMajorVersion() < 2) {
      const fields = [];
      await this.plugin.app.fileManager.processFrontMatter(file, async (fm) => {
        const attributes = V1FileClassMigration.getInlineFileClassAttributes(this.plugin, fileClass);
        attributes.forEach((attr) => {
          fields.push({
            id: Field_default.getNewFieldId(this.plugin),
            command: attr.command,
            display: attr.display,
            name: attr.name,
            options: attr.options,
            style: attr.style,
            type: attr.type,
            path: ""
          });
        });
        fm.fields = fields;
        fm.version = "2.0";
      });
    }
  }
  static async migrateV1FileClasses(plugin) {
    const index = plugin.fieldIndex;
    await Promise.all(
      [...index.v1FileClassesPath.values()].map(async (remainingV1FileClass) => {
        const migration = new V1FileClassMigration(plugin);
        await migration.migrate(remainingV1FileClass);
      })
    );
    if ([...index.v1FileClassesPath.values()].length)
      await index.indexFields();
  }
};

// src/index/FieldIndexBuilder.ts
var import_obsidian66 = require("obsidian");
var FieldIndexBuilder = class extends import_obsidian66.Component {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.changedFiles = [];
    this.openFileClassManagerAfterIndex = [];
    this.settings = this.plugin.settings;
    this.init();
    this.dvReady = () => {
      var _a, _b;
      return ((_a = this.dv) == null ? void 0 : _a._loaded) && !!((_b = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _b.index.initialized);
    };
  }
  init() {
    this.flushCache();
    this.filesFields = /* @__PURE__ */ new Map();
    this.previousFilesFields = /* @__PURE__ */ new Map();
    this.filesFieldsLastChange = /* @__PURE__ */ new Map();
    this.remainingLegacyFileClasses = false;
    this.canvasLastFiles = /* @__PURE__ */ new Map();
    this.fileFormulaFieldLastValue = /* @__PURE__ */ new Map();
    this.fileFormulaFieldsStatus = /* @__PURE__ */ new Map();
    this.fileLookupFieldLastOutputType = /* @__PURE__ */ new Map();
    this.fileLookupFieldLastValue = /* @__PURE__ */ new Map();
    this.fileLookupFieldsStatus = /* @__PURE__ */ new Map();
    this.fileLookupFiles = /* @__PURE__ */ new Map();
    this.dv = this.plugin.app.plugins.plugins.dataview;
    this.classFilesPath = this.settings.classFilesPath;
    this.dVRelatedFieldsToUpdate = /* @__PURE__ */ new Map();
    this.bookmarks = this.plugin.app.internalPlugins.getPluginById("bookmarks");
  }
  flushCache() {
    this.filesLookupsAndFormulasFields = /* @__PURE__ */ new Map();
    this.filesLookupAndFormulaFieldsExists = /* @__PURE__ */ new Map();
    this.fileClassesFields = /* @__PURE__ */ new Map();
    this.fieldsFromGlobalFileClass = [];
    this.filesFieldsFromTags = /* @__PURE__ */ new Map();
    this.filesFieldsFromFilesPaths = /* @__PURE__ */ new Map();
    this.filesFieldsFromBookmarksGroups = /* @__PURE__ */ new Map();
    this.filesFieldsFromFileClassQueries = /* @__PURE__ */ new Map();
    this.filesFieldsFromInnerFileClasses = /* @__PURE__ */ new Map();
    this.fileClassesPath = /* @__PURE__ */ new Map();
    this.v1FileClassesPath = /* @__PURE__ */ new Map();
    this.v2FileClassesPath = /* @__PURE__ */ new Map();
    this.fileClassesName = /* @__PURE__ */ new Map();
    this.fileClassesAncestors = /* @__PURE__ */ new Map();
    this.valuesListNotePathValues = /* @__PURE__ */ new Map();
    this.tagsMatchingFileClasses = /* @__PURE__ */ new Map();
    this.filesPathsMatchingFileClasses = /* @__PURE__ */ new Map();
    this.bookmarksGroupsMatchingFileClasses = /* @__PURE__ */ new Map();
    this.filesFileClasses = /* @__PURE__ */ new Map();
    this.filesFileClassesNames = /* @__PURE__ */ new Map();
    this.lookupQueries = /* @__PURE__ */ new Map();
  }
};

// src/index/FieldIndex.ts
var FieldIndex = class extends FieldIndexBuilder {
  constructor(plugin) {
    super(plugin);
    this.plugin = plugin;
    this.launchTime = Date.now();
  }
  async onload() {
    this.registerEvent(
      this.bookmarks.instance.on("changed", async () => {
        if (this.bookmarks.enabled) {
          const updateTime = this.bookmarks.lastSave;
          if (this.lastBookmarkChange === void 0 || updateTime > this.lastBookmarkChange) {
            await this.indexFields();
            this.lastBookmarkChange = updateTime;
            this.plugin.app.workspace.trigger("metadata-menu:indexed");
          }
        }
      })
    );
    this.registerEvent(
      this.plugin.app.vault.on("modify", async (file) => {
        if (file instanceof import_obsidian67.TFile) {
          if (file.extension === "md") {
            this.changedFiles.push(file);
            this.lastTimeBeforeResolving = Date.now();
          } else if (file.extension === "canvas") {
            await updateCanvas(this.plugin, { canvas: file });
          }
        }
      })
    );
    this.registerEvent(
      this.plugin.app.vault.on("delete", async (file) => {
        this.filesFields.delete(file.path);
        await this.fullIndex();
      })
    );
    this.registerEvent(
      this.plugin.app.vault.on("rename", async (file, oldPath) => {
        this.filesFields.delete(oldPath);
        await this.fullIndex();
      })
    );
    this.registerEvent(
      this.plugin.app.metadataCache.on("resolved", async () => {
        if (this.plugin.app.metadataCache.inProgressTaskCount === 0 && this.plugin.launched) {
          if (this.changedFiles.every((file) => this.classFilesPath && file.path.startsWith(this.classFilesPath))) {
            this.plugin.app.workspace.trigger("metadata-menu:fileclass-indexed");
            await updateCanvasAfterFileClass(this.plugin, this.changedFiles);
          }
          await this.indexFields();
          this.plugin.app.workspace.trigger("metadata-menu:indexed");
          this.changedFiles = [];
        }
      })
    );
    this.registerEvent(
      this.plugin.app.metadataCache.on("dataview:index-ready", async () => {
        DEBUG && console.log("dataview index ready");
        this.dv = this.plugin.app.plugins.plugins.dataview;
      })
    );
    this.registerEvent(
      this.plugin.app.metadataCache.on("dataview:metadata-change", async (op, file) => {
        if (file.stat.mtime > this.launchTime && op === "update" && this.dvReady() && this.settings.isAutoCalculationEnabled) {
          const filePayloadToProcess = this.dVRelatedFieldsToUpdate.get(file.path);
          if (![...this.dVRelatedFieldsToUpdate.keys()].includes(file.path)) {
            await this.resolveAndUpdateDVQueriesBasedFields(false);
          } else if (filePayloadToProcess) {
            filePayloadToProcess.status = "processed";
          }
          if ([...this.dVRelatedFieldsToUpdate.values()].every((item) => item.status === "processed"))
            this.dVRelatedFieldsToUpdate = /* @__PURE__ */ new Map();
        }
      })
    );
  }
  indexableFiles() {
    return this.plugin.app.vault.getMarkdownFiles().filter((f) => !this.classFilesPath || !f.path.startsWith(this.classFilesPath)).filter((f) => !this.settings.fileIndexingExcludedFolders.some((path) => f.path.startsWith(path))).filter((f) => !this.settings.fileIndexingExcludedExtensions.some((extension) => f.path.endsWith(extension))).filter((f) => !this.settings.fileIndexingExcludedRegex.some((regexStr) => {
      try {
        const regex = new RegExp(regexStr);
        return regex.test(f.path);
      } catch (e) {
        return true;
      }
    }));
  }
  indexableFileClasses() {
    const classFilesPath = this.classFilesPath;
    if (classFilesPath) {
      return this.plugin.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(classFilesPath));
    }
    return [];
  }
  async fullIndex(forceUpdateAll = false) {
    this.plugin.indexStatus.setState("indexing");
    this.classFilesPath = this.plugin.settings.classFilesPath;
    await this.indexFields();
    if (this.dvReady() && (this.settings.isAutoCalculationEnabled || forceUpdateAll)) {
      this.resolveAndUpdateDVQueriesBasedFields(forceUpdateAll);
    }
    if (this.remainingLegacyFileClasses)
      await this.migrateFileClasses();
    this.plugin.app.workspace.trigger("metadata-menu:indexed");
  }
  async indexFields() {
    let start2 = Date.now();
    this.flushCache();
    this.getFileClassesAncestors();
    this.getGlobalFileClass();
    this.getFileClasses();
    this.getLookupQueries();
    this.resolveFileClassMatchingTags();
    this.resolveFileClassMatchingFilesPaths();
    this.resolveFileClassMatchingBookmarksGroups();
    this.resolveFileClassQueries();
    this.getFilesFieldsFromFileClass();
    const indexedFiles = this.getFilesFields();
    await this.getCanvasesFiles();
    await this.getValuesListNotePathValues();
    this.getFilesLookupAndFormulaFieldsExists();
    DEBUG && console.log("indexed FIELDS for ", indexedFiles, " files in ", (Date.now() - start2) / 1e3, "s");
  }
  pushPayloadToUpdate(filePath, fieldsPayloadToUpdate) {
    const currentFieldsPayloadToUpdate = this.dVRelatedFieldsToUpdate.get(filePath) || { status: "toProcess", fieldsPayload: [] };
    for (const fieldPayload of fieldsPayloadToUpdate) {
      currentFieldsPayloadToUpdate.status = "toProcess";
      const { id, payload } = fieldPayload;
      const currentField = currentFieldsPayloadToUpdate == null ? void 0 : currentFieldsPayloadToUpdate.fieldsPayload.find((item) => item.id === id);
      if (currentField)
        currentField.payload = payload;
      else
        currentFieldsPayloadToUpdate.fieldsPayload.push(fieldPayload);
      this.dVRelatedFieldsToUpdate.set(filePath, currentFieldsPayloadToUpdate);
    }
  }
  async applyUpdates() {
    await Promise.all(
      [...this.dVRelatedFieldsToUpdate.keys()].map(
        async (filePath) => {
          var _a;
          const fieldsPayload = (_a = this.dVRelatedFieldsToUpdate.get(filePath)) == null ? void 0 : _a.fieldsPayload;
          if (fieldsPayload) {
            await postValues(this.plugin, fieldsPayload, filePath);
            fieldsPayload.forEach((fieldPayload) => {
              var _a2;
              const field = (_a2 = this.filesFields.get(filePath)) == null ? void 0 : _a2.find((_f) => _f.isRoot() && _f.id === fieldPayload.id);
              if (field && field.type === "Lookup" /* Lookup */)
                this.fileLookupFieldsStatus.set(`${filePath}__${field.name}`, "upToDate" /* upToDate */);
              if (field && field.type === "Formula" /* Formula */)
                this.fileFormulaFieldsStatus.set(`${filePath}__${field.name}`, "upToDate" /* upToDate */);
            });
          }
        }
      )
    );
    this.lastDVUpdatingTime = Date.now();
  }
  async resolveAndUpdateDVQueriesBasedFields(force_update_all = false, forceUpdateOne) {
    const start2 = Date.now();
    this.plugin.indexStatus.setState("indexing");
    cleanRemovedFormulasFromIndex(this.plugin);
    this.getFilesLookupAndFormulaFieldsExists();
    resolveLookups(this.plugin);
    await updateLookups(this.plugin, forceUpdateOne, force_update_all);
    await updateFormulas(this.plugin, forceUpdateOne, force_update_all);
    await this.applyUpdates();
    this.plugin.app.workspace.trigger("metadata-menu:indexed");
    DEBUG && console.log("Resolved dvQ in ", (Date.now() - start2) / 1e3, "s");
  }
  async migrateFileClasses() {
    await V1FileClassMigration.migrateV1FileClasses(this.plugin);
    this.remainingLegacyFileClasses = false;
  }
  async getCanvasesFiles() {
    const canvases = this.plugin.app.vault.getFiles().filter((t) => t.extension === "canvas");
    canvases.forEach(async (canvas) => {
      const currentFilesPaths = [];
      let { nodes, edges } = { nodes: [], edges: [] };
      const rawContent = await this.plugin.app.vault.read(canvas);
      if (rawContent) {
        try {
          const canvasContent = JSON.parse(rawContent);
          nodes = canvasContent.nodes;
          edges = canvasContent.edges;
        } catch (error) {
          DEBUG && console.log(error);
          new import_obsidian67.Notice(`Couldn't read ${canvas.path}`);
        }
      }
      nodes == null ? void 0 : nodes.forEach(async (node) => {
        if (node.type === "file") {
          const targetFilePath = node.file;
          if (!currentFilesPaths.includes(targetFilePath))
            currentFilesPaths.push(targetFilePath);
        }
      });
      this.canvasLastFiles.set(canvas.path, currentFilesPaths);
    });
  }
  async getValuesListNotePathValues() {
    this.fileClassesName.forEach((fileClass) => {
      fileClass.attributes.forEach(async (attr) => {
        if (typeof attr.options === "object" && !!attr.options["valuesListNotePath"]) {
          this.valuesListNotePathValues.set(
            attr.options.valuesListNotePath,
            await FieldSetting.getValuesListFromNote(
              this.plugin,
              attr.options.valuesListNotePath
            )
          );
        }
      });
    });
    this.plugin.presetFields.forEach(async (setting) => {
      if (setting.options.valuesListNotePath) {
        this.valuesListNotePathValues.set(
          setting.options.valuesListNotePath,
          await FieldSetting.getValuesListFromNote(
            this.plugin,
            setting.options.valuesListNotePath
          )
        );
      }
    });
  }
  getFileClassesAncestors() {
    this.indexableFileClasses().forEach((f) => {
      var _a, _b;
      const fileClassName = FileClass.getFileClassNameFromPath(this.settings, f.path);
      if (fileClassName) {
        const parent = (_b = (_a = this.plugin.app.metadataCache.getFileCache(f)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b.extends;
        if (parent) {
          const parentFile = this.plugin.app.vault.getAbstractFileByPath(`${this.classFilesPath || ""}${parent}.md`);
          if (parentFile) {
            this.fileClassesAncestors.set(fileClassName, [parent]);
          } else {
            this.fileClassesAncestors.set(fileClassName, []);
          }
        } else {
          this.fileClassesAncestors.set(fileClassName, []);
        }
      }
    });
    [...this.fileClassesAncestors].forEach(([fileClassName, ancestors]) => {
      if (ancestors.length > 0) {
        this.getAncestorsRecursively(fileClassName);
      }
    });
  }
  getAncestorsRecursively(fileClassName) {
    var _a;
    const ancestors = this.fileClassesAncestors.get(fileClassName);
    if (ancestors && ancestors.length) {
      const lastAncestor = ancestors.last();
      const lastAncestorParent = (_a = this.fileClassesAncestors.get(lastAncestor)) == null ? void 0 : _a[0];
      if (lastAncestorParent && lastAncestorParent !== fileClassName) {
        this.fileClassesAncestors.set(fileClassName, [...ancestors, lastAncestorParent]);
        this.getAncestorsRecursively(fileClassName);
      }
    }
  }
  getGlobalFileClass() {
    const globalFileClass = this.settings.globalFileClass;
    if (!globalFileClass) {
      this.fieldsFromGlobalFileClass = [];
    } else {
      try {
        this.fieldsFromGlobalFileClass = FileClass.createFileClass(
          this.plugin,
          globalFileClass
        ).attributes.map((attr) => attr.getField());
      } catch (error) {
      }
    }
  }
  getFileClasses() {
    this.indexableFileClasses().forEach((f) => FileClass.indexFileClass(this, f));
    (async () => {
      await Promise.all(this.openFileClassManagerAfterIndex.map(async (fileClassName) => {
        const fileClass = this.fileClassesName.get(fileClassName);
        if (fileClass) {
          const fileClassViewManager = new FileClassViewManager(this.plugin, fileClass, "settingsOption");
          this.plugin.addChild(fileClassViewManager);
          await fileClassViewManager.build();
        }
      }));
      this.openFileClassManagerAfterIndex = [];
    })();
  }
  getLookupQueries() {
    this.plugin.presetFields.filter((field) => field.type === "Lookup" /* Lookup */).forEach((field) => {
      this.lookupQueries.set(`presetField___${field.name}`, field);
    });
    [...this.fileClassesFields].forEach(([fileClassName, fields]) => {
      fields.filter((field) => field.type === "Lookup" /* Lookup */).forEach((field) => {
        this.lookupQueries.set(`${fileClassName}___${field.name}`, field);
      });
    });
  }
  resolveFileClassBinding(itemMatchingFileClasses, filesFieldsFromBinding, itemToMatch, cFile) {
    const fileClass = itemMatchingFileClasses.get(itemToMatch);
    const filePath = cFile.path;
    if (fileClass) {
      this.filesFileClasses.set(filePath, [.../* @__PURE__ */ new Set([...this.filesFileClasses.get(filePath) || [], fileClass])]);
      this.filesFileClassesNames.set(cFile.path, [.../* @__PURE__ */ new Set([...this.filesFileClassesNames.get(filePath) || [], fileClass.name])]);
      const fileFileClassesFieldsFromBinding = this.fileClassesFields.get(fileClass.name);
      const currentFields = filesFieldsFromBinding.get(filePath);
      if (fileFileClassesFieldsFromBinding) {
        const newFields = [...fileFileClassesFieldsFromBinding];
        const filteredCurrentFields = (currentFields == null ? void 0 : currentFields.filter(
          (field) => {
            var _a, _b;
            return !newFields.map((f) => f.id).includes(field.id) && !((_b = (_a = fileClass.options) == null ? void 0 : _a.excludes) == null ? void 0 : _b.map((attr) => attr.id).includes(field.id));
          }
        )) || [];
        newFields.push(...filteredCurrentFields);
        filesFieldsFromBinding.set(filePath, newFields);
      }
    }
  }
  resolveFileClassMatchingTags() {
    if (!this.tagsMatchingFileClasses.size)
      return;
    const mappedTags = [...this.tagsMatchingFileClasses.keys()].map((_t) => `#${_t}`);
    const filesWithMappedTag = [];
    this.indexableFiles().forEach((_f) => {
      var _a, _b;
      const cache = this.plugin.app.metadataCache.getFileCache(_f);
      const cachedTags = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.tags;
      let fileTags = [];
      if (Array.isArray(cachedTags)) {
        fileTags = cachedTags;
      } else if (typeof cachedTags === "string") {
        fileTags = cachedTags.split(",").map((_t) => _t.trim());
      }
      const filteredTagsFromFrontmatter = fileTags.filter((_t) => mappedTags.includes(`#${_t}`));
      const filteredTagsFromFile = ((_b = cache == null ? void 0 : cache.tags) == null ? void 0 : _b.filter((_t) => mappedTags.includes(_t.tag)).map((_t) => _t.tag)) || [];
      const filteredTags = filteredTagsFromFrontmatter.concat(filteredTagsFromFile);
      if (filteredTags == null ? void 0 : filteredTags.length) {
        const fileWithTags = { path: _f.path, tags: [] };
        filteredTags.forEach((_t) => fileWithTags.tags.push(_t));
        filesWithMappedTag.push(fileWithTags);
      }
    });
    filesWithMappedTag.forEach((cFile) => {
      cFile.tags.forEach((_tag) => {
        const tag = _tag.replace(/^\#/, "");
        this.resolveFileClassBinding(
          this.tagsMatchingFileClasses,
          this.filesFieldsFromTags,
          tag,
          cFile
        );
      });
    });
  }
  resolveFileClassMatchingFilesPaths() {
    if (!this.filesPathsMatchingFileClasses.size)
      return;
    const paths = [...this.filesPathsMatchingFileClasses.keys()];
    this.indexableFiles().filter((_f) => _f.parent !== null).forEach((file) => {
      for (const path of paths) {
        if (file.parent.path.startsWith(path)) {
          this.resolveFileClassBinding(
            this.filesPathsMatchingFileClasses,
            this.filesFieldsFromFilesPaths,
            path,
            file
          );
        }
      }
    });
  }
  getFilesForItems(items, groups, filesWithGroups, path = "") {
    if (groups.includes(path || "/")) {
      items.filter((_i) => _i.type === "file").forEach((_i) => filesWithGroups.push({ path: _i.path, group: path || "/" }));
    }
    for (const group of items.filter((_i) => _i.type === "group")) {
      const subPath = `${path}${path ? "/" : ""}${group.title}`;
      this.getFilesForItems(group.items || [], groups, filesWithGroups, subPath);
    }
  }
  resolveFileClassMatchingBookmarksGroups() {
    if (!this.bookmarksGroupsMatchingFileClasses.size)
      return;
    const groups = [...this.bookmarksGroupsMatchingFileClasses.keys()];
    const bookmarks = this.bookmarks;
    if (!bookmarks.enabled)
      return;
    const filesWithGroups = [];
    this.getFilesForItems(bookmarks.instance.items || [], groups, filesWithGroups);
    filesWithGroups.forEach((cFile) => {
      this.resolveFileClassBinding(
        this.bookmarksGroupsMatchingFileClasses,
        this.filesFieldsFromBookmarksGroups,
        cFile.group,
        cFile
      );
    });
  }
  resolveFileClassQueries() {
    var _a;
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    if (!dvApi)
      return;
    this.settings.fileClassQueries.forEach((sfcq) => {
      const fcq = new FileClassQuery_default(sfcq.name, sfcq.id, sfcq.query, sfcq.fileClassName);
      fcq.getResults(dvApi).forEach((result) => {
        const fileClass = this.fileClassesName.get(fcq.fileClassName);
        if (fileClass) {
          const f = result.file;
          this.filesFileClasses.set(f.path, [.../* @__PURE__ */ new Set([...this.filesFileClasses.get(f.path) || [], fileClass])]);
          this.filesFileClassesNames.set(f.path, [.../* @__PURE__ */ new Set([...this.filesFileClassesNames.get(f.path) || [], fileClass.name])]);
        }
        const fileFileClassesFieldsFromQuery = this.fileClassesFields.get(fcq.fileClassName);
        if (fileFileClassesFieldsFromQuery)
          this.filesFieldsFromFileClassQueries.set(result.file.path, fileFileClassesFieldsFromQuery);
      });
    });
  }
  getFilesFieldsFromFileClass() {
    this.indexableFiles().forEach((f) => {
      var _a, _b;
      const fileFileClassesNames = [];
      const fileClassesCache = (_b = (_a = this.plugin.app.metadataCache.getFileCache(f)) == null ? void 0 : _a.frontmatter) == null ? void 0 : _b[this.settings.fileClassAlias];
      if (fileClassesCache) {
        Array.isArray(fileClassesCache) ? fileFileClassesNames.push(...fileClassesCache) : fileFileClassesNames.push(...fileClassesCache.split(",").map((fcn) => fcn.trim()));
        fileFileClassesNames.forEach((fileFileClassName) => {
          const fileClass = this.fileClassesName.get(fileFileClassName);
          if (fileClass) {
            this.filesFileClasses.set(f.path, [.../* @__PURE__ */ new Set([...this.filesFileClasses.get(f.path) || [], fileClass])]);
            this.filesFileClassesNames.set(f.path, [.../* @__PURE__ */ new Set([...this.filesFileClassesNames.get(f.path) || [], fileClass.name])]);
            const fileClassesFieldsFromFile = this.fileClassesFields.get(fileFileClassName);
            const currentFields = this.filesFieldsFromInnerFileClasses.get(f.path);
            if (fileClassesFieldsFromFile) {
              const newFields = [...fileClassesFieldsFromFile];
              const filteredCurrentFields = (currentFields == null ? void 0 : currentFields.filter(
                (field) => {
                  var _a2, _b2;
                  return !newFields.map((f2) => f2.id).includes(field.id) && !((_b2 = (_a2 = fileClass.options) == null ? void 0 : _a2.excludes) == null ? void 0 : _b2.map((attr) => attr.id).includes(field.id));
                }
              )) || [];
              newFields.push(...filteredCurrentFields);
              this.filesFieldsFromInnerFileClasses.set(f.path, newFields);
            } else {
              this.filesFieldsFromInnerFileClasses.set(f.path, []);
            }
          } else {
            this.filesFieldsFromInnerFileClasses.set(f.path, []);
          }
        });
      } else {
        this.filesFieldsFromInnerFileClasses.set(f.path, []);
      }
    });
  }
  isLookupOrFormula(field) {
    return ["Lookup" /* Lookup */, "Formula" /* Formula */].includes(field.type);
  }
  getFilesFields() {
    const filesToIndex = this.indexableFiles().filter(
      (_f) => !this.changedFiles.length || //forceupdateAll
      this.changedFiles.filter((file) => this.classFilesPath && file.path.startsWith(this.classFilesPath)).length || // a fileclass has changed forceupdate all
      this.changedFiles.includes(_f)
    );
    filesToIndex.forEach((f) => {
      var _a;
      const fileFieldsFromInnerFileClasses = this.filesFieldsFromInnerFileClasses.get(f.path);
      const fileFieldsFromQuery = this.filesFieldsFromFileClassQueries.get(f.path);
      const fileFieldsFromTag = this.filesFieldsFromTags.get(f.path);
      const fileFieldsFromPath = this.filesFieldsFromFilesPaths.get(f.path);
      const fileFieldsFromGroup = this.filesFieldsFromBookmarksGroups.get(f.path);
      let fileFields2;
      const previousFileFields = ((_a = this.previousFilesFields.get(f.path)) == null ? void 0 : _a.map((_f) => _f.id)) || [];
      if ((fileFieldsFromInnerFileClasses == null ? void 0 : fileFieldsFromInnerFileClasses.length) || (fileFieldsFromQuery == null ? void 0 : fileFieldsFromQuery.length) || (fileFieldsFromTag == null ? void 0 : fileFieldsFromTag.length) || (fileFieldsFromPath == null ? void 0 : fileFieldsFromPath.length) || (fileFieldsFromGroup == null ? void 0 : fileFieldsFromGroup.length)) {
        fileFields2 = fileFieldsFromInnerFileClasses || [];
        fileFields2.push(...(fileFieldsFromTag || []).filter((field) => !fileFields2.map((f2) => f2.id).includes(field.id)));
        fileFields2.push(...(fileFieldsFromPath || []).filter((field) => !fileFields2.map((f2) => f2.id).includes(field.id)));
        fileFields2.push(...(fileFieldsFromGroup || []).filter((field) => !fileFields2.map((f2) => f2.id).includes(field.id)));
        fileFields2.push(...(fileFieldsFromQuery || []).filter((field) => !fileFields2.map((f2) => f2.id).includes(field.id)));
        this.filesFields.set(f.path, fileFields2);
        const filesLookupAndFormulasFields = fileFields2.filter((f2) => this.isLookupOrFormula(f2));
        filesLookupAndFormulasFields.push(...(fileFieldsFromTag || []).filter((field) => !filesLookupAndFormulasFields.map((f2) => f2.id).includes(field.id) && this.isLookupOrFormula(field)));
        filesLookupAndFormulasFields.push(...(fileFieldsFromPath || []).filter((field) => !filesLookupAndFormulasFields.map((f2) => f2.id).includes(field.id) && this.isLookupOrFormula(field)));
        filesLookupAndFormulasFields.push(...(fileFieldsFromGroup || []).filter((field) => !filesLookupAndFormulasFields.map((f2) => f2.id).includes(field.id) && this.isLookupOrFormula(field)));
        filesLookupAndFormulasFields.push(...(fileFieldsFromQuery || []).filter((field) => !filesLookupAndFormulasFields.map((f2) => f2.id).includes(field.id) && this.isLookupOrFormula(field)));
        if (filesLookupAndFormulasFields.length)
          this.filesLookupsAndFormulasFields.set(f.path, filesLookupAndFormulasFields);
      } else if (this.fieldsFromGlobalFileClass.length) {
        fileFields2 = this.fieldsFromGlobalFileClass;
        this.filesFields.set(f.path, fileFields2);
        const filesLookupAndFormulasFields = this.fieldsFromGlobalFileClass.filter((f2) => this.isLookupOrFormula(f2));
        if (filesLookupAndFormulasFields.length)
          this.filesLookupsAndFormulasFields.set(f.path, this.fieldsFromGlobalFileClass.filter((f2) => this.isLookupOrFormula(f2)));
        this.filesFileClasses.set(f.path, [this.fileClassesName.get(this.settings.globalFileClass)]);
        this.filesFileClassesNames.set(f.path, [this.settings.globalFileClass]);
      } else {
        fileFields2 = this.plugin.presetFields.map((prop) => {
          const property = new Field_default(this.plugin);
          return Object.assign(property, prop);
        });
        this.filesFields.set(f.path, fileFields2);
        const filesLookupAndFormulasFields = fileFields2.filter((f2) => this.isLookupOrFormula(f2));
        if (filesLookupAndFormulasFields.length)
          this.filesLookupsAndFormulasFields.set(f.path, fileFields2.filter((f2) => this.isLookupOrFormula(f2)));
      }
      if (fileFields2.some((f2) => !(previousFileFields == null ? void 0 : previousFileFields.includes(f2.id))) || (previousFileFields == null ? void 0 : previousFileFields.some((fId) => !fileFields2.map((_f) => _f.id).includes(fId)))) {
        this.filesFieldsLastChange.set(f.path, Date.now());
      }
      this.previousFilesFields.set(f.path, fileFields2);
    });
    return filesToIndex.length;
  }
  getFilesLookupAndFormulaFieldsExists(file) {
    if (!this.dvReady())
      return;
    [...this.filesFields.entries()].forEach(([filePath, fields]) => {
      const dvFormulaFields = fields.filter((f) => f.isRoot() && f.type === "Formula" /* Formula */ && f.name in this.dv.api.page(filePath));
      if (!this.settings.isAutoCalculationEnabled)
        dvFormulaFields.forEach((field) => this.fileFormulaFieldsStatus.set(`${filePath}__${field.name}`, "mayHaveChanged" /* mayHaveChanged */));
      const dvLookupFields = fields.filter((f) => f.isRoot() && f.type === "Lookup" /* Lookup */ && f.name in this.dv.api.page(filePath));
      if (!this.settings.isAutoCalculationEnabled)
        dvFormulaFields.forEach((field) => this.fileLookupFieldsStatus.set(`${filePath}__${field.name}`, "mayHaveChanged" /* mayHaveChanged */));
      this.filesLookupAndFormulaFieldsExists.set(filePath, [...dvFormulaFields, ...dvLookupFields]);
    });
  }
  dvQFieldChanged(path) {
    var _a;
    let changed = false;
    (_a = this.filesLookupAndFormulaFieldsExists.get(path)) == null ? void 0 : _a.forEach((field) => {
      if (field.type === "Lookup" /* Lookup */) {
        changed = changed || this.fileLookupFieldsStatus.get(path + "__" + field.name) === "changed" /* changed */;
      } else if (field.type === "Formula" /* Formula */) {
        changed = changed || this.fileFormulaFieldsStatus.get(path + "__" + field.name) === "changed" /* changed */;
      }
    });
    return changed;
  }
  dvQFieldMayHaveChanged(path) {
    var _a;
    let changed = false;
    (_a = this.filesLookupAndFormulaFieldsExists.get(path)) == null ? void 0 : _a.forEach((field) => {
      if (field.type === "Lookup" /* Lookup */) {
        changed = changed || this.fileLookupFieldsStatus.get(path + "__" + field.name) === "mayHaveChanged" /* mayHaveChanged */;
      } else if (field.type === "Formula" /* Formula */) {
        changed = changed || this.fileFormulaFieldsStatus.get(path + "__" + field.name) === "mayHaveChanged" /* mayHaveChanged */;
      }
    });
    return changed;
  }
  dvQFieldHasAnError(path) {
    var _a;
    let changed = false;
    (_a = this.filesLookupAndFormulaFieldsExists.get(path)) == null ? void 0 : _a.forEach((field) => {
      if (field.type === "Lookup" /* Lookup */) {
        changed = changed || this.fileLookupFieldsStatus.get(path + "__" + field.name) === "error" /* error */;
      } else if (field.type === "Formula" /* Formula */) {
        changed = changed || this.fileFormulaFieldsStatus.get(path + "__" + field.name) === "error" /* error */;
      }
    });
    return changed;
  }
  isIndexed(file) {
    this.indexableFiles().map((f) => f.path).includes(file.path);
    return true;
  }
};

// src/components/IndexStatus.ts
var import_obsidian68 = require("obsidian");
var Statuses = /* @__PURE__ */ ((Statuses2) => {
  Statuses2["indexing"] = "indexing";
  Statuses2["indexed"] = "indexed";
  Statuses2["update"] = "update";
  return Statuses2;
})(Statuses || {});
var statusIcon2 = {
  "indexing": `<svg class="svg-icon sync" xmlns="http://www.w3.org/2000/svg" width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" fill="none">
            <path
                d="M9 20H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H20a2 2 0 0 1 2 2v1" />
            <path class="rotating" id="arrow"
                d="M12 10v4h4 m-4 0 1.5-1.5c.9-.9 2.2-1.5 3.5-1.5s2.6.6 3.5 1.5c.4.4.8 1 1 1.5 M22 22v-4h-4 m4 0-1.5 1.5c-.9.9-2.1 1.5-3.5 1.5s-2.6-.6-3.5-1.5c-.4-.4-.8-1-1-1.5" />

            <animateTransform href="#arrow" attributeName="transform" type="rotate" from="0 17 16" to="-180 17 16"
                begin="0s" dur="1s" repeatCount="indefinite" />
        </svg>`,
  "indexed": `<svg class="svg-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" stroke="currentColor" viewBox="0 0 24 24" fill="none">
            <path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z"/>
            <path class="check-mark" d="m9 13 2 2 4-4"/>
        </svg>`,
  "update": `<svg class="svg-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke="red" d="M8.42 10.61a2.1 2.1 0 1 1 2.97 2.97L5.95 19 2 20l.99-3.95 5.43-5.44Z"/>
            <path d="M2 11.5V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H20a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-9.5"/>
        </svg>`
};
var statusTooltip = {
  "indexing": "Metadata Menu: indexing fields",
  "indexed": "Metadata Menu: field index complete",
  "update": "Click to update lookups and formulas"
};
var IndexStatus = class extends import_obsidian68.Component {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.state = "indexed" /* indexed */;
  }
  setState(state) {
    this.state = state;
    this.statusBtn.setTooltip(statusTooltip[state], { placement: "top" });
    for (const status in Statuses) {
      this.statusIcon.removeClass(status);
    }
    this.statusIcon.addClass(state);
    this.statusIcon.innerHTML = statusIcon2[state];
  }
  onload() {
    const indexStatus = this.plugin.addStatusBarItem();
    const container = indexStatus.createEl("div", { cls: "status-bar-item-segment" });
    this.statusBtn = new import_obsidian68.ButtonComponent(container);
    this.statusBtn.setClass("status-item-btn");
    this.statusIcon = this.statusBtn.buttonEl.createEl("span", { cls: "status-bar-item-icon sync-status-icon" });
    this.setState("indexed");
    this.statusBtn.onClick(async () => {
      let updatesToApply = false;
      if (this.state === "update") {
        const dvQFields = this.getdvQFieldsToUpdate();
        await Promise.all(
          dvQFields.map(async (field) => {
            if (this.file) {
              if (field.type === "Lookup" /* Lookup */) {
                await updateLookups(this.plugin, { file: this.file, fieldName: field.name });
                updatesToApply = true;
              } else if (field.type === "Formula" /* Formula */) {
                await updateFormulas(this.plugin, { file: this.file, fieldName: field.name });
                updatesToApply = true;
              }
            }
          })
        );
      }
      if (updatesToApply)
        this.plugin.fieldIndex.applyUpdates();
    });
  }
  onunload() {
    const indexStatusEl = document.querySelector(".status-bar-item.plugin-metadata-menu");
    if (indexStatusEl)
      this.plugin.app.statusBar.containerEl.removeChild(indexStatusEl);
  }
  getdvQFieldsToUpdate() {
    if (this.file) {
      const index = this.plugin.fieldIndex;
      const fileDVQFields = index.filesLookupsAndFormulasFields.get(this.file.path) || [];
      return fileDVQFields.filter((field) => ["Lookup" /* Lookup */, "Formula" /* Formula */].includes(field.type));
    }
    return [];
  }
  checkForUpdate(view) {
    if (view && view instanceof import_obsidian68.FileView && view.file) {
      const file = this.plugin.app.vault.getAbstractFileByPath(view.file.path);
      if (file instanceof import_obsidian68.TFile && file.extension === "md") {
        this.file = file;
        if (this.plugin.fieldIndex.dvQFieldChanged(file.path)) {
          this.setState("update");
        } else if (this.plugin.fieldIndex.dvQFieldMayHaveChanged(file.path)) {
          this.setState("update");
        } else {
          this.setState("indexed");
        }
      } else {
        this.file = void 0;
      }
    } else {
      this.file = void 0;
    }
  }
};

// src/commands/fieldModifier.ts
var import_obsidian69 = require("obsidian");
function buildAndOpenModal(plugin, file, fieldName, attrs) {
  var _a;
  if ((_a = attrs == null ? void 0 : attrs.options) == null ? void 0 : _a.inFrontmatter) {
    const lineNumber = -1;
    FieldManager2.openFieldModal(plugin, file, fieldName, lineNumber, false, false);
  } else {
    new chooseSectionModal(
      plugin,
      file,
      (lineNumber, asList, asBlockquote) => FieldManager2.openFieldModal(
        plugin,
        file,
        fieldName,
        lineNumber,
        asList,
        asBlockquote
      )
    ).open();
  }
}
function createDvField(plugin, dv, p, fieldContainer, fieldName, attrs) {
  var _a;
  const field = (_a = plugin.fieldIndex.filesFields.get(p.file.path)) == null ? void 0 : _a.filter((f) => f.isRoot()).find((field2) => field2.name === fieldName);
  if (!(field == null ? void 0 : field.isRoot())) {
    dv.el("span", p[field.name], attrs);
    return;
  }
  if (field == null ? void 0 : field.type) {
    const fieldManager = new FieldManager[field.type](plugin, field);
    fieldManager.createDvField(dv, p, fieldContainer, attrs);
  } else {
    const fieldManager = FieldManager2.createDefault(plugin, fieldName);
    fieldManager.createDvField(dv, p, fieldContainer, attrs);
  }
}
function fieldModifier(plugin, dv, p, fieldName, attrs) {
  var _a, _b;
  const fieldContainer = dv.el("div", "");
  fieldContainer.setAttr("class", `metadata-menu-dv-field-container ${fieldName}`);
  if (p[fieldName] === void 0) {
    if (!((_a = attrs == null ? void 0 : attrs.options) == null ? void 0 : _a.showAddField)) {
      const emptyField = dv.el("span", null, attrs);
      fieldContainer.appendChild(emptyField);
    } else {
      const addFieldBtn = dv.el("button", attrs);
      (0, import_obsidian69.setIcon)(addFieldBtn, "log-in");
      addFieldBtn.onclick = async () => {
        var _a2;
        const file = plugin.app.vault.getAbstractFileByPath(p.file.path);
        if (file instanceof import_obsidian69.TFile && file.extension == "md") {
          const field = (_a2 = plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a2.filter((f) => f.isRoot()).find((field2) => field2.name === fieldName);
          if (field) {
            buildAndOpenModal(plugin, file, fieldName, attrs);
          } else {
            new chooseSectionModal(
              plugin,
              file,
              (lineNumber, asList, asBlockquote) => FieldManager2.openFieldModal(
                plugin,
                file,
                void 0,
                lineNumber,
                asList,
                asBlockquote
              )
            ).open();
          }
        } else {
          throw Error("path doesn't correspond to a proper file");
        }
      };
      fieldContainer.appendChild(addFieldBtn);
      const addInFrontmatterFieldBtn = dv.el("button", attrs);
      (0, import_obsidian69.setIcon)(addInFrontmatterFieldBtn, "align-vertical-space-around");
      addInFrontmatterFieldBtn.onclick = async () => {
        var _a2;
        const file = plugin.app.vault.getAbstractFileByPath(p.file.path);
        if (file instanceof import_obsidian69.TFile && file.extension == "md") {
          const field = (_a2 = plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a2.filter((f) => f.isRoot()).find((field2) => field2.name === fieldName);
          if (field)
            FieldManager2.openFieldModal(plugin, file, field.name, -1, false, false);
        } else {
          throw Error("path doesn't correspond to a proper file");
        }
      };
      fieldContainer.appendChild(addInFrontmatterFieldBtn);
    }
  } else {
    const file = plugin.app.vault.getAbstractFileByPath(p.file.path);
    if (file instanceof import_obsidian69.TFile && file.extension == "md") {
      const field = (_b = plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _b.filter((f) => f.isRoot()).find((field2) => field2.name === fieldName);
      if (field) {
        createDvField(plugin, dv, p, fieldContainer, fieldName, attrs);
      } else {
        const fieldManager = FieldManager2.createDefault(plugin, fieldName);
        fieldManager.createDvField(dv, p, fieldContainer, attrs);
      }
    }
  }
  return fieldContainer;
}

// src/commands/fileFields.ts
var import_obsidian70 = require("obsidian");
var FieldInfo = class {
  constructor(plugin, file, eF) {
    this.plugin = plugin;
    this.file = file;
    this.eF = eF;
  }
  getInfos() {
    const field = this.eF.field;
    const fieldManager = new FieldManager[field.type](this.plugin, field);
    return {
      ignoredInMenu: this.plugin.settings.globallyIgnoredFields.includes(this.eF.field.name),
      isValid: fieldManager.validateValue(this.eF.value),
      fileClassName: this.eF.field.fileClassName,
      type: this.eF.field.type,
      options: this.eF.field.options,
      sourceType: this.eF.field.fileClassName ? "fileClass" : "settings",
      indexedPath: this.eF.indexedPath,
      id: this.eF.field.id,
      name: this.eF.field.name,
      value: this.eF.value
    };
  }
};
async function fileFields(plugin, fileOrfilePath) {
  let file;
  if (fileOrfilePath instanceof import_obsidian70.TFile) {
    file = fileOrfilePath;
  } else {
    const _file = plugin.app.vault.getAbstractFileByPath(fileOrfilePath);
    if (_file instanceof import_obsidian70.TFile && _file.extension == "md") {
      file = _file;
    } else {
      throw Error("path doesn't correspond to a proper file");
    }
  }
  const eFs = await Note.getExistingFields(plugin, file);
  const fields = {};
  for (const eF of eFs) {
    if (eF.indexedPath)
      fields[eF.indexedPath] = new FieldInfo(plugin, file, eF).getInfos();
  }
  return fields;
}

// src/commands/getValues.ts
var import_obsidian71 = require("obsidian");
async function getValues(plugin, fileOrfilePath, attribute) {
  let file;
  if (fileOrfilePath instanceof import_obsidian71.TFile) {
    file = fileOrfilePath;
  } else {
    const _file = plugin.app.vault.getAbstractFileByPath(fileOrfilePath);
    if (_file instanceof import_obsidian71.TFile && _file.extension == "md") {
      file = _file;
    } else {
      throw Error("path doesn't correspond to a proper file");
    }
  }
  const eF = await Note.getExistingFields(plugin, file);
  return eF.filter((_ef) => _ef.field.name === attribute).map((_eF) => _eF.value);
}
async function getValuesForIndexedPath(plugin, fileOrfilePath, indexedPath) {
  let file;
  if (fileOrfilePath instanceof import_obsidian71.TFile) {
    file = fileOrfilePath;
  } else {
    const _file = plugin.app.vault.getAbstractFileByPath(fileOrfilePath);
    if (_file instanceof import_obsidian71.TFile && _file.extension == "md") {
      file = _file;
    } else {
      throw Error("path doesn't correspond to a proper file");
    }
  }
  const eF = await Note.getExistingFieldForIndexedPath(plugin, file, indexedPath);
  return eF == null ? void 0 : eF.value;
}

// src/MetadataMenuApi.ts
var MetadataMenuApi = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  make() {
    return {
      getValues: this.getValues(),
      getValuesForIndexedPath: this.getValuesForIndexedPath(),
      fieldModifier: this.fieldModifier(),
      fileFields: this.fileFields(),
      insertMissingFields: this.insertMissingFields(),
      postValues: this.postValues()
    };
  }
  getValues() {
    return async (fileOrFilePath, attribute) => getValues(this.plugin, fileOrFilePath, attribute);
  }
  getValuesForIndexedPath() {
    return async (fileOrFilePath, indexedPath) => getValuesForIndexedPath(this.plugin, fileOrFilePath, indexedPath);
  }
  fieldModifier() {
    return (dv, p, fieldName, attrs) => fieldModifier(this.plugin, dv, p, fieldName, attrs);
  }
  fileFields() {
    return async (fileOrFilePath) => fileFields(this.plugin, fileOrFilePath);
  }
  insertMissingFields() {
    return async (fileOrFilePath, lineNumber, asList, asBlockquote, fileClassName) => insertMissingFields(this.plugin, fileOrFilePath, lineNumber, asList, asBlockquote, fileClassName);
  }
  postValues() {
    return async (fileOrFilePath, payload, lineNumber, asList, asBlockquote) => postValues(this.plugin, payload, fileOrFilePath, lineNumber, asList, asBlockquote);
  }
};

// src/settings/MetadataMenuSettingTab.ts
var import_obsidian75 = require("obsidian");

// src/suggester/FolderSuggester.ts
var import_obsidian72 = require("obsidian");
var FolderSuggest = class extends TextInputSuggest {
  constructor(plugin, inputEl) {
    super(inputEl);
    this.plugin = plugin;
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.plugin.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian72.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/FileClassQuerySettingModal.ts
var import_obsidian74 = require("obsidian");

// src/settings/FileClassQuerySetting.ts
var import_obsidian73 = require("obsidian");
var FileClassQuerySetting = class extends import_obsidian73.Setting {
  constructor(containerEl, property, plugin) {
    super(containerEl);
    this.containerEl = containerEl;
    this.plugin = plugin;
    this.fileClassQuery = property;
    this.setTextContentWithname();
    this.addEditButton();
    this.addDeleteButton();
    this.addMoveUpButton();
    this.settingEl.addClass("no-border");
  }
  setTextContentWithname() {
    this.infoEl.textContent = "";
    this.infoEl.addClass("setting-item");
    const fileClassQueryContainer = this.infoEl.createDiv();
    const nameContainer = fileClassQueryContainer.createEl("div", "name");
    nameContainer.innerHTML = `<strong>${this.fileClassQuery.name}</strong>`;
    const fileClassNameContainer = fileClassQueryContainer.createEl("div");
    fileClassNameContainer.innerHTML = `<span>FileClass</span> : ${this.fileClassQuery.fileClassName}`;
    const queryContainer = fileClassQueryContainer.createEl("div");
    queryContainer.innerHTML = `<span>Query</span> : ${this.fileClassQuery.query}`;
  }
  addEditButton() {
    this.addButton((b) => {
      b.setIcon("pencil").setTooltip("Edit").onClick(() => {
        let modal = new FileClassQuerySettingsModal(this.plugin, this.containerEl, this, this.fileClassQuery);
        modal.open();
      });
    });
  }
  addDeleteButton() {
    this.addButton((b) => {
      b.setIcon("trash").setTooltip("Delete").onClick(() => {
        var _a;
        const currentExistingFileClassQuery = this.plugin.initialFileClassQueries.find((p) => p.id == this.fileClassQuery.id);
        if (currentExistingFileClassQuery) {
          this.plugin.initialFileClassQueries.remove(currentExistingFileClassQuery);
        }
        ;
        (_a = this.settingEl.parentElement) == null ? void 0 : _a.removeChild(this.settingEl);
        this.plugin.saveSettings();
      });
    });
  }
  addMoveUpButton() {
    this.addButton((b) => {
      b.setIcon("up-chevron-glyph").setTooltip("Move up (lower priority)").onClick(() => {
        const currentFileClassQueryIndex = this.plugin.initialFileClassQueries.map((fcq) => fcq.id).indexOf(this.fileClassQuery.id);
        if (currentFileClassQueryIndex > 0) {
          this.containerEl.insertBefore(this.settingEl, this.settingEl.previousElementSibling);
          this.plugin.initialFileClassQueries.splice(currentFileClassQueryIndex, 1);
          this.plugin.initialFileClassQueries.splice(currentFileClassQueryIndex - 1, 0, this.fileClassQuery);
          this.plugin.saveSettings();
        }
      });
    });
  }
};

// src/settings/FileClassQuerySettingModal.ts
var FileClassQuerySettingsModal = class extends import_obsidian74.Modal {
  constructor(plugin, parentSettingContainer, parentSetting, fileClassQuery) {
    super(plugin.app);
    this.plugin = plugin;
    this.parentSettingContainer = parentSettingContainer;
    this.parentSetting = parentSetting;
    this.saved = false;
    this.new = true;
    this.initialFileClassQuery = new FileClassQuery_default();
    if (fileClassQuery) {
      this.new = false;
      this.fileClassQuery = fileClassQuery;
      FileClassQuery_default.copyProperty(this.initialFileClassQuery, this.fileClassQuery);
    } else {
      let newId = 1;
      this.plugin.initialFileClassQueries.forEach((prop) => {
        if (parseInt(prop.id) && parseInt(prop.id) >= newId) {
          newId = parseInt(prop.id) + 1;
        }
        ;
      });
      this.fileClassQuery = new FileClassQuery_default();
      this.fileClassQuery.id = newId.toString();
      this.initialFileClassQuery.id = newId.toString();
    }
    ;
    this.containerEl.addClass("metadata-menu");
  }
  async onOpen() {
    if (this.fileClassQuery.name == "") {
      this.titleEl.setText(`Select a fileClass and add an applicable query`);
    } else {
      this.titleEl.setText(`Manage ${this.fileClassQuery.name} settings`);
    }
    ;
    await this.createForm();
  }
  onClose() {
    Object.assign(this.fileClassQuery, this.initialFileClassQuery);
    if (!this.new && this.parentSetting) {
      this.parentSetting.setTextContentWithname();
    } else if (this.saved) {
      new FileClassQuerySetting(this.parentSettingContainer, this.fileClassQuery, this.plugin);
    }
    ;
  }
  createnameInputContainer(container) {
    container.createDiv({ cls: "label", text: `FileClass Query Name:` });
    const input = new import_obsidian74.TextComponent(container);
    input.inputEl.addClass("with-label");
    input.inputEl.addClass("full-width");
    const name = this.fileClassQuery.name;
    input.setValue(name);
    input.setPlaceholder("Name of this fileClass query");
    input.onChange((value) => {
      this.fileClassQuery.name = value;
      this.titleEl.setText(`Manage options for ${this.fileClassQuery.name}`);
    });
    return input;
  }
  createFileClassSelectorContainer(container) {
    container.createDiv({ cls: "label", text: `Fileclass:` });
    container.createDiv({ cls: "spacer" });
    const select = new import_obsidian74.DropdownComponent(container);
    const classFilesPath = this.plugin.settings.classFilesPath;
    const fileClasses = this.plugin.app.vault.getFiles().filter((f) => classFilesPath && f.path.startsWith(classFilesPath)).reverse();
    select.addOption("--Select a fileClass--", "--Select a fileClass--");
    fileClasses.forEach((fileClass) => {
      const fileClassName = FileClass.getFileClassNameFromPath(this.plugin.settings, fileClass.path);
      if (fileClassName)
        select.addOption(fileClassName, fileClassName);
    });
    if (this.fileClassQuery.fileClassName) {
      select.setValue(this.fileClassQuery.fileClassName);
    }
    select.onChange((value) => {
      if (value != "--Select a fileClass--") {
        this.fileClassQuery.fileClassName = value;
      } else {
        this.fileClassQuery.fileClassName = "";
      }
    });
  }
  createQueryInputContainer(container) {
    container.createDiv({ text: "dataviewJS query:" });
    const queryStringInputContainer = container.createDiv({ cls: "field-container" });
    const queryStringInput = new import_obsidian74.TextAreaComponent(queryStringInputContainer);
    queryStringInput.inputEl.addClass("full-width");
    queryStringInput.inputEl.rows = 4;
    queryStringInput.setValue(this.fileClassQuery.query);
    queryStringInput.onChange((value) => this.fileClassQuery.query = value);
  }
  async createForm() {
    const nameContainer = this.contentEl.createDiv({ cls: "field-container" });
    this.createnameInputContainer(nameContainer);
    const fileClassSelectContainer = this.contentEl.createDiv({ cls: "field-container" });
    this.createFileClassSelectorContainer(fileClassSelectContainer);
    const fileClassQueryContainer = this.contentEl.createDiv({ cls: "vstacked" });
    this.createQueryInputContainer(fileClassQueryContainer);
    cleanActions(this.contentEl, ".footer-actions");
    const footer = this.contentEl.createDiv({ cls: "footer-actions" });
    footer.createDiv({ cls: "spacer" });
    this.createSaveButton(footer);
    this.createCancelButton(footer);
  }
  createSaveButton(container) {
    const b = new import_obsidian74.ButtonComponent(container);
    b.setTooltip("Save");
    b.setIcon("checkmark");
    b.onClick(async () => {
      var _a;
      if (this.fileClassQuery.fileClassName && this.fileClassQuery.name && this.fileClassQuery.query) {
        this.saved = true;
        const currentExistingFileClassQuery = this.plugin.initialFileClassQueries.filter((p) => p.id == this.fileClassQuery.id)[0];
        if (currentExistingFileClassQuery) {
          FileClassQuery_default.copyProperty(currentExistingFileClassQuery, this.fileClassQuery);
        } else {
          this.plugin.initialFileClassQueries.push(this.fileClassQuery);
        }
        ;
        FileClassQuery_default.copyProperty(this.initialFileClassQuery, this.fileClassQuery);
        if (this.parentSetting)
          FileClassQuery_default.copyProperty(this.parentSetting.fileClassQuery, this.fileClassQuery);
        (_a = this.parentSetting) == null ? void 0 : _a.setTextContentWithname();
        this.plugin.saveSettings();
        this.close();
      }
    });
  }
  createCancelButton(container) {
    const b = new import_obsidian74.ButtonComponent(container);
    b.setIcon("cross").setTooltip("Cancel").onClick(() => {
      this.saved = false;
      if (this.initialFileClassQuery.name != "") {
        Object.assign(this.fileClassQuery, this.initialFileClassQuery);
      }
      ;
      this.close();
    });
  }
};

// src/settings/MetadataMenuSettingTab.ts
var SettingTextWithButtonComponent = class extends import_obsidian75.Setting {
  constructor(plugin, containerEl, name, description, placeholder, currentValues, normalizeValue) {
    super(containerEl);
    this.plugin = plugin;
    this.containerEl = containerEl;
    this.name = name;
    this.description = description;
    this.placeholder = placeholder;
    this.currentValues = currentValues;
    this.normalizeValue = normalizeValue;
    this.newValues = [];
    const saveButton = new import_obsidian75.ButtonComponent(this.containerEl);
    saveButton.buttonEl.addClass("save");
    saveButton.setIcon("save");
    saveButton.onClick(async () => {
      this.plugin.settings[this.currentValues] = this.newValues;
      await this.plugin.saveSettings();
      saveButton.removeCta();
    });
    this.setName(this.name).setDesc(this.description).addTextArea((text) => {
      text.setPlaceholder(this.placeholder).setValue(this.plugin.settings[this.currentValues].join(", ")).onChange(async (value) => {
        saveButton.setCta();
        const values = value.split(",");
        this.newValues = [];
        values.forEach((_value) => {
          if (value.trim())
            this.newValues.push(this.normalizeValue(_value.trim()));
        });
      });
      text.inputEl.rows = 2;
      text.inputEl.cols = 25;
    });
    this.settingEl.addClass("vstacked");
    this.settingEl.addClass("no-border");
    this.controlEl.addClass("full-width");
    this.infoEl.addClass("with-button");
    const infoTextContainer = this.infoEl.createDiv({ cls: "setting-item-info-text" });
    while (infoTextContainer.previousElementSibling) {
      infoTextContainer.prepend(this.infoEl.removeChild(infoTextContainer.previousElementSibling));
    }
    this.infoEl.createDiv({ cls: "spacer" });
    this.infoEl.appendChild(saveButton.buttonEl);
  }
};
var ButtonDisplaySetting = class extends import_obsidian75.Setting {
  constructor(plugin, containerEl, name, description, value, needsReload) {
    super(containerEl);
    this.plugin = plugin;
    this.containerEl = containerEl;
    this.name = name;
    this.description = description;
    this.value = value;
    this.needsReload = needsReload;
    const reloadInfo = this.containerEl.createDiv({ cls: "settings-info-warning" });
    this.setName(this.name).setDesc(this.description).addToggle((cb) => {
      cb.setValue(this.plugin.settings[this.value]);
      cb.onChange((value2) => {
        this.plugin.settings[this.value] = value2;
        this.plugin.saveSettings();
        if (this.needsReload)
          reloadInfo.textContent = "Please reload metadata menu to apply this change";
      });
    }).settingEl.addClass("no-border");
  }
};
var MetadataMenuSettingTab = class extends import_obsidian75.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.plugin = plugin;
    this.newFileClassAlias = this.plugin.settings.fileClassAlias;
    this.newFileClassesPath = this.plugin.settings.classFilesPath;
    this.newTableViewMaxRecords = this.plugin.settings.tableViewMaxRecords;
    this.newIcon = this.plugin.settings.fileClassIcon;
    this.containerEl.addClass("metadata-menu");
    this.containerEl.addClass("settings");
  }
  createSettingGroup(title, subTitle, withButton = false) {
    const settingHeader = this.containerEl.createEl("div");
    const settingHeaderContainer = settingHeader.createEl("div", { cls: "header-container" });
    const settingHeaderTextContainer = settingHeaderContainer.createEl("div", { cls: "text-container" });
    settingHeaderTextContainer.createEl("h4", { text: title, cls: "section-header" });
    if (subTitle)
      settingHeaderTextContainer.createEl("div", { text: subTitle, cls: "setting-item-description" });
    const settingsContainer = this.containerEl.createEl("div");
    if (withButton) {
      const settingsContainerShowButtonContainer = settingHeaderContainer.createEl("div", { cls: "setting-item-control" });
      const settingsContainerShowButton = new import_obsidian75.ButtonComponent(settingsContainerShowButtonContainer);
      settingsContainerShowButton.buttonEl.addClass("setting-item-control");
      settingsContainer.hide();
      settingsContainerShowButton.setCta();
      settingsContainerShowButton.setIcon("chevrons-up-down");
      const toggleState = () => {
        if (settingsContainer.isShown()) {
          settingsContainer.hide();
          settingsContainerShowButton.setIcon("chevrons-up-down");
          settingsContainerShowButton.setCta();
        } else {
          settingsContainer.show();
          settingsContainerShowButton.setIcon("chevrons-down-up");
          settingsContainerShowButton.removeCta();
        }
      };
      settingsContainerShowButton.onClick(() => toggleState());
    }
    return settingsContainer;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    const globalSettings = this.createSettingGroup(
      "Global settings",
      "Global settings to apply to your whole vault",
      true
    );
    const scopeReloadInfo = globalSettings.createDiv({ cls: "settings-info-warning" });
    new import_obsidian75.Setting(globalSettings).setName("Scope").setDesc("Index fields in frontmatter only or in the whole note (if you use dataview inline fields). Indexing full notes could cause some latencies in vaults with large files").addDropdown((cb) => {
      cb.addOption("frontmatterOnly", "Frontmatter only");
      cb.addOption("fullNote", "Full note");
      cb.setValue(this.plugin.settings.frontmatterOnly ? "frontmatterOnly" : "fullNote");
      cb.onChange(async (value) => {
        this.plugin.settings.frontmatterOnly = value === "frontmatterOnly" ? true : false;
        await this.plugin.saveSettings();
        scopeReloadInfo.textContent = "Please reload metadata menu to apply this change";
      });
    }).settingEl.addClass("no-border");
    new import_obsidian75.Setting(globalSettings).setName("Display field options in context menu").setDesc("Choose to show or hide fields options in the context menu of a link or a file").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.displayFieldsInContextMenu);
      toggle.onChange(async (value) => {
        this.plugin.settings.displayFieldsInContextMenu = value;
        await this.plugin.saveSettings();
      });
    }).settingEl.addClass("no-border");
    new SettingTextWithButtonComponent(
      this.plugin,
      globalSettings,
      "Excluded folders",
      "Folders where preset fields and fileClass options won't be applied. Useful for templates or settings folders.",
      "Enter/folders/paths/, comma/separated/",
      "fileIndexingExcludedFolders",
      (item) => item.replace(/\/?$/, "/")
    );
    new SettingTextWithButtonComponent(
      this.plugin,
      globalSettings,
      "Excluded extensions",
      "Files with these extensions won't be indexed Useful for big files that don't contain metadata. Comma separated",
      "",
      "fileIndexingExcludedExtensions",
      (item) => item
    );
    new SettingTextWithButtonComponent(
      this.plugin,
      globalSettings,
      "Excluded file name patterns",
      "files with names matching those regex won't be indexed. Useful for very specific usecases. Comma separated ",
      "foo*, .md$",
      "fileIndexingExcludedRegex",
      (item) => item
    );
    new SettingTextWithButtonComponent(
      this.plugin,
      globalSettings,
      "Globally ignored fields",
      "Fields to be ignored by the plugin. Comma separated ",
      "",
      "globallyIgnoredFields",
      (item) => item
    );
    const enableAutoComplete = new import_obsidian75.Setting(globalSettings).setName("Autocomplete").setDesc("Activate autocomplete fields").addToggle((cb) => {
      cb.setValue(this.plugin.settings.isAutosuggestEnabled);
      cb.onChange((value) => {
        this.plugin.settings.isAutosuggestEnabled = value;
        this.plugin.saveSettings();
      });
    });
    enableAutoComplete.settingEl.addClass("no-border");
    enableAutoComplete.controlEl.addClass("full-width");
    const enableAutoCalculation = new import_obsidian75.Setting(globalSettings).setName("Auto calculation").setDesc("Activate lookups and formulas fields global auto-calculation").addToggle((cb) => {
      cb.setValue(this.plugin.settings.isAutoCalculationEnabled);
      cb.onChange((value) => {
        this.plugin.settings.isAutoCalculationEnabled = value;
        this.plugin.saveSettings();
      });
    });
    enableAutoCalculation.settingEl.addClass("no-border");
    enableAutoCalculation.controlEl.addClass("full-width");
    const showIndexingStatus = new import_obsidian75.Setting(globalSettings).setName("Fields Indexing Status").setDesc("Show fields indexing status icon in status toolbar").addToggle((cb) => {
      cb.setValue(this.plugin.settings.showIndexingStatusInStatusBar);
      cb.onChange((value) => {
        this.plugin.settings.showIndexingStatusInStatusBar = value;
        if (!value) {
          this.plugin.indexStatus.unload();
        } else {
          this.plugin.indexStatus.load();
        }
        this.plugin.saveSettings();
      });
    });
    showIndexingStatus.settingEl.addClass("no-border");
    showIndexingStatus.controlEl.addClass("full-width");
    const frontmatterListDisplay = new import_obsidian75.Setting(globalSettings).setName("Frontmatter list display").setDesc("Choose wether lists should be displayed as arrays or indented lists in frontmatter").addDropdown((cb) => {
      [["Array", "asArray"], ["Indented List", "asList"]].forEach(([display, value]) => {
        cb.addOption(value, display);
      });
      cb.setValue(this.plugin.settings.frontmatterListDisplay || "asArray" /* asArray */);
      cb.onChange(async (value) => {
        this.plugin.settings.frontmatterListDisplay = value;
        await this.plugin.saveSettings();
      });
    });
    frontmatterListDisplay.settingEl.addClass("no-border");
    frontmatterListDisplay.controlEl.addClass("full-width");
    new import_obsidian75.Setting(globalSettings).setName("First day of week").setDesc("For date fields, which day the date picker's week should start with").addDropdown((cb) => {
      for (let i = 0; i < 2; i++) {
        cb.addOption(i.toString(), (0, import_obsidian75.moment)().day(i).format("dddd"));
      }
      cb.setValue(this.plugin.settings.firstDayOfWeek.toString() || "1");
      cb.onChange(async (value) => {
        this.plugin.settings.firstDayOfWeek = parseInt(value);
        await this.plugin.saveSettings();
      });
    }).settingEl.addClass("no-border");
    containerEl.createDiv({ cls: "setting-divider" });
    const presetFieldsSettings = this.createSettingGroup(
      "Preset Fields settings",
      "Manage globally predefined type and options for a field throughout your whole vault",
      true
    );
    new import_obsidian75.Setting(presetFieldsSettings).setName("Add New Field Setting").setDesc("Add a new Frontmatter property for which you want preset options.").addButton((button) => {
      return button.setTooltip("Add New Property Manager").setButtonText("Add new").setCta().onClick(async () => {
        let modal = new FieldSettingsModal(this.plugin, presetFieldsSettings);
        modal.open();
      });
    }).settingEl.addClass("no-border");
    const fieldsContainer = presetFieldsSettings.createDiv({ cls: "fields-container" });
    this.plugin.presetFields.sort((a, b) => {
      const _a = a.path ? a.path + "_" : a.id;
      const _b = b.path ? b.path + "_" : b.id;
      return _a < _b ? -1 : 1;
    }).forEach((prop) => {
      const property = new Field_default(this.plugin);
      Object.assign(property, prop);
      new FieldSetting(fieldsContainer, property, this.plugin);
    });
    containerEl.createDiv({ cls: "setting-divider" });
    const classFilesSettings = this.createSettingGroup(
      "FileClass settings",
      "Manage fileClass folder and alias. When a note has a fileClass defined, fileClass field properties will override global preset fields settings for the same field name",
      true
    );
    const fileClassesFolderSaveButton = new import_obsidian75.ButtonComponent(classFilesSettings);
    fileClassesFolderSaveButton.buttonEl.addClass("save");
    fileClassesFolderSaveButton.setIcon("save");
    fileClassesFolderSaveButton.onClick(async () => {
      this.plugin.settings.classFilesPath = this.newFileClassesPath;
      await this.plugin.saveSettings();
      fileClassesFolderSaveButton.removeCta();
    });
    const path = new import_obsidian75.Setting(classFilesSettings).setName("Class Files path").setDesc("Path to the files containing the authorized fields for a type of note").addSearch((cfs) => {
      new FolderSuggest(this.plugin, cfs.inputEl);
      cfs.setPlaceholder("Folder").setValue(this.plugin.settings.classFilesPath || "").onChange((new_folder) => {
        const newPath = new_folder.endsWith("/") || !new_folder ? new_folder : new_folder + "/";
        this.newFileClassesPath = newPath || null;
        fileClassesFolderSaveButton.setCta();
      });
    });
    path.settingEl.addClass("no-border");
    path.settingEl.addClass("narrow-title");
    path.controlEl.addClass("full-width");
    path.settingEl.appendChild(fileClassesFolderSaveButton.buttonEl);
    const aliasSaveButton = new import_obsidian75.ButtonComponent(classFilesSettings);
    aliasSaveButton.buttonEl.addClass("save");
    aliasSaveButton.setIcon("save");
    aliasSaveButton.onClick(async () => {
      this.plugin.settings.fileClassAlias = this.newFileClassAlias;
      await this.plugin.saveSettings();
      aliasSaveButton.removeCta();
    });
    const alias = new import_obsidian75.Setting(classFilesSettings).setName("FileClass field alias").setDesc("Choose another name for fileClass field in frontmatter (example: Category, type, ...").addText((text) => {
      text.setValue(this.plugin.settings.fileClassAlias).onChange(async (value) => {
        this.newFileClassAlias = value || "fileClass";
        aliasSaveButton.setCta();
      });
    });
    alias.settingEl.addClass("no-border");
    alias.settingEl.addClass("narrow-title");
    alias.controlEl.addClass("full-width");
    alias.settingEl.appendChild(aliasSaveButton.buttonEl);
    const global = new import_obsidian75.Setting(classFilesSettings).setName("Global fileClass").setDesc("Choose one fileClass to be applicable to all files (even it is not present as a fileClass attribute in their frontmatter). This will override the preset Fields defined above").addSearch((cfs) => {
      new FileSuggest(
        cfs.inputEl,
        this.plugin,
        this.plugin.settings.classFilesPath || ""
      );
      cfs.setPlaceholder("Global fileClass");
      cfs.setValue(
        this.plugin.settings.globalFileClass ? this.plugin.settings.classFilesPath + this.plugin.settings.globalFileClass + ".md" : ""
      ).onChange((newPath) => {
        var _a;
        this.plugin.settings.globalFileClass = newPath ? (_a = newPath.split("\\").pop().split("/").pop()) == null ? void 0 : _a.replace(".md", "") : "";
        this.plugin.saveSettings();
      });
    });
    global.settingEl.addClass("no-border");
    global.settingEl.addClass("narrow-title");
    global.controlEl.addClass("full-width");
    const defaultIconSave = new import_obsidian75.ButtonComponent(classFilesSettings);
    defaultIconSave.buttonEl.addClass("save");
    defaultIconSave.setIcon("save");
    defaultIconSave.onClick(async () => {
      this.plugin.settings.fileClassIcon = this.newIcon;
      await this.plugin.saveSettings();
      defaultIconSave.removeCta();
    });
    const iconManagerContainer = classFilesSettings.createDiv({ cls: "icon" });
    const defaultIconSetting = new import_obsidian75.Setting(classFilesSettings).setName("Default Icon").setDesc("Choose a default icon for fileclasses from lucide.dev library").addText((cb) => {
      cb.setValue(this.plugin.settings.fileClassIcon || DEFAULT_SETTINGS.fileClassIcon).onChange((value) => {
        this.newIcon = value;
        (0, import_obsidian75.setIcon)(iconManagerContainer, value);
        defaultIconSave.setCta();
      });
    });
    (0, import_obsidian75.setIcon)(iconManagerContainer, this.plugin.settings.fileClassIcon || DEFAULT_SETTINGS.fileClassIcon);
    defaultIconSetting.settingEl.appendChild(iconManagerContainer);
    defaultIconSetting.settingEl.appendChild(defaultIconSave.buttonEl);
    defaultIconSetting.settingEl.addClass("no-border");
    defaultIconSetting.settingEl.addClass("narrow-title");
    defaultIconSetting.controlEl.addClass("full-width");
    const rowPerPageSaveButton = new import_obsidian75.ButtonComponent(classFilesSettings);
    rowPerPageSaveButton.buttonEl.addClass("save");
    rowPerPageSaveButton.setIcon("save");
    rowPerPageSaveButton.onClick(async () => {
      this.plugin.settings.tableViewMaxRecords = this.newTableViewMaxRecords;
      await this.plugin.saveSettings();
      rowPerPageSaveButton.removeCta();
    });
    const maxRows = new import_obsidian75.Setting(classFilesSettings).setName("Result per page").setDesc("Number of result per page in table view").addText((text) => {
      text.setValue(`${this.plugin.settings.tableViewMaxRecords}`).onChange(async (value) => {
        this.newTableViewMaxRecords = parseInt(value || `${this.plugin.settings.tableViewMaxRecords}`);
        rowPerPageSaveButton.setCta();
      });
    });
    maxRows.settingEl.addClass("no-border");
    maxRows.settingEl.addClass("narrow-title");
    maxRows.controlEl.addClass("full-width");
    maxRows.settingEl.appendChild(rowPerPageSaveButton.buttonEl);
    const chooseFileClassAtFileCreation = new import_obsidian75.Setting(classFilesSettings).setName("Add a fileclass after create").setDesc("Select a fileclass at file creation to be added to the file").addToggle((cb) => {
      cb.setValue(this.plugin.settings.chooseFileClassAtFileCreation);
      cb.onChange((value) => {
        this.plugin.settings.chooseFileClassAtFileCreation = value;
        this.plugin.saveSettings();
      });
    });
    chooseFileClassAtFileCreation.settingEl.addClass("no-border");
    chooseFileClassAtFileCreation.controlEl.addClass("full-width");
    const autoInsertFieldsAtFileClassInsertion = new import_obsidian75.Setting(classFilesSettings).setName("Insert fileClass fields").setDesc("Includes fileClass in frontmatter after fileClass choice").addToggle((cb) => {
      cb.setValue(this.plugin.settings.autoInsertFieldsAtFileClassInsertion);
      cb.onChange((value) => {
        this.plugin.settings.autoInsertFieldsAtFileClassInsertion = value;
        this.plugin.saveSettings();
      });
    });
    autoInsertFieldsAtFileClassInsertion.settingEl.addClass("no-border");
    autoInsertFieldsAtFileClassInsertion.controlEl.addClass("full-width");
    const showFileClassSelectInModal = new import_obsidian75.Setting(classFilesSettings).setName("Fileclass Select").setDesc("Show fileclass select option in note fields modals").addToggle((cb) => {
      cb.setValue(this.plugin.settings.showFileClassSelectInModal);
      cb.onChange((value) => {
        this.plugin.settings.showFileClassSelectInModal = value;
        this.plugin.saveSettings();
      });
    });
    showFileClassSelectInModal.settingEl.addClass("no-border");
    showFileClassSelectInModal.controlEl.addClass("full-width");
    containerEl.createDiv({ cls: "setting-divider" });
    const metadataMenuBtnSettings = this.createSettingGroup(
      "Metadata Menu button",
      "Show extra button to access metadata menu modal of fields",
      true
    );
    [
      {
        name: "Reading mode links",
        description: "Display an extra button to access metadata menu form after a link in reading mode",
        value: "enableLinks"
      },
      {
        name: "Live preview mode",
        description: "Display an extra button to access metadata menu form after a link in live preview",
        value: "enableEditor"
      },
      {
        name: "Tab header",
        description: "Display an extra button to access metadata menu form in the tab header",
        value: "enableTabHeader"
      },
      {
        name: "Backlinks",
        description: "Display an extra button to access metadata menu form in the backlinks panel",
        value: "enableBacklinks"
      },
      {
        name: "Search",
        description: "Display an extra button to access metadata menu form in the search panel",
        value: "enableSearch"
      },
      {
        name: "File explorer",
        description: "Display an extra button to access metadata menu form in the file explorer",
        value: "enableFileExplorer",
        needsReload: true
      },
      {
        name: "Properties",
        description: "Display fields buttons to access metadata forms in the property section",
        value: "enableProperties"
      }
    ].forEach((s) => new ButtonDisplaySetting(this.plugin, metadataMenuBtnSettings, s.name, s.description, s.value, s.needsReload));
    containerEl.createDiv({ cls: "setting-divider" });
    const queryFileClassSettings = this.createSettingGroup(
      "Query based FileClass settings",
      "Manage globally predefined type and options for a field matching this query",
      true
    );
    new import_obsidian75.Setting(queryFileClassSettings).setName("Add New Query for fileClass").setDesc("Add a new query and a FileClass that will apply to files matching this query.").addButton((button) => {
      return button.setTooltip("Add New fileClass query").setButtonText("Add new").setCta().onClick(async () => {
        let modal = new FileClassQuerySettingsModal(this.plugin, queryFileClassSettings);
        modal.open();
      });
    }).settingEl.addClass("no-border");
    this.plugin.initialFileClassQueries.forEach((query) => {
      const fileClassQuery = new FileClassQuery_default();
      Object.assign(fileClassQuery, query);
      new FileClassQuerySetting(queryFileClassSettings, fileClassQuery, this.plugin);
    });
  }
};

// src/settings/migrateSetting.ts
var migrateSettings = async (plugin) => {
  if (plugin.settings.settingsVersion === void 0)
    await migrateSettingsV1toV2(plugin);
  if (plugin.settings.settingsVersion === 2)
    await migrateSettingsV2toV3(plugin);
  if (plugin.settings.settingsVersion === 3)
    await migrateSettingsV3toV4(plugin);
  if (plugin.settings.settingsVersion === 4)
    await migrateSettingsV4toV5(plugin);
};
var migrateSettingsV1toV2 = async (plugin) => {
  const presetFields = plugin.presetFields;
  presetFields.forEach((p) => {
    if (!Object.keys(p).contains("type")) {
      if (p.isMulti)
        p.type = "Multi" /* Multi */;
      else if (p.isCycle)
        p.type = "Cycle" /* Cycle */;
      else if (p.isBoolean)
        p.type = "Boolean" /* Boolean */;
      else if (p.options && Object.keys(p.options).length > 0)
        p.type = "Select" /* Select */;
      else
        p.type = "Input" /* Input */;
    }
    delete p.isMulti;
    delete p.isCycle;
    delete p.isBoolean;
    if (Object.getOwnPropertyDescriptor(p, "values") !== void 0) {
      Object.defineProperty(
        p,
        "options",
        Object.getOwnPropertyDescriptor(p, "values")
      );
      delete p["values"];
    }
  });
  plugin.settings.settingsVersion = 2;
  await plugin.saveData(plugin.settings);
  DEBUG && console.log("Metadata menu settings migrated to version 2");
};
var migrateSettingsV2toV3 = async (plugin) => {
  const presetFields = plugin.presetFields;
  presetFields.forEach((p) => {
    if (["Select" /* Select */, "Multi" /* Multi */].includes(p.type)) {
      const currentOptionKeys = Object.keys(p.options);
      p.options.valuesList = {};
      currentOptionKeys.forEach((key) => p.options.valuesList[key] = p.options[key]);
      if (p.valuesListNotePath) {
        const selectType = "ValuesListNotePath" /* ValuesListNotePath */;
        p.options.sourceType = selectType;
        p.options[Key[selectType]];
      } else {
        p.options.sourceType = "ValuesList" /* ValuesList */;
      }
      p.options.valuesListNotePath = p.valuesListNotePath;
      currentOptionKeys.forEach((key) => delete p.options[key]);
      p.options.valuesFromDVQuery = "";
    }
    delete p.valuesListNotePath;
  });
  plugin.settings.settingsVersion = 3;
  await plugin.saveData(plugin.settings);
  DEBUG && console.log("Metadata menu settings migrated to version 3");
};
var migrateSettingsV3toV4 = async (plugin) => {
  plugin.settings.fileClassExcludedFolders = [];
  plugin.settings.settingsVersion = 4;
  await plugin.saveData(plugin.settings);
  DEBUG && console.log("Metadata menu settings migrated to version 4");
};
var migrateSettingsV4toV5 = async (plugin) => {
  plugin.settings.fileClassExcludedFolders = [];
  plugin.settings.settingsVersion = "5.0";
  await plugin.saveData(plugin.settings);
  DEBUG && console.log("Metadata menu settings migrated to version 5");
};

// src/suggester/metadataSuggester.ts
var import_obsidian76 = require("obsidian");
var listPrefix = "  - ";
var ValueSuggest = class extends import_obsidian76.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.inFrontmatter = false;
    this.inFullLine = false;
    this.inSentence = false;
    this.didSelect = false;
    this.filterOption = (firstValues, lastValue, option) => {
      return !firstValues || !(firstValues == null ? void 0 : firstValues.contains(encodeLink(option))) && (!lastValue || !!lastValue && encodeLink(option).includes(lastValue));
    };
    this.plugin = plugin;
    this.setInstructions([{ command: "Shift", purpose: "remove space after::" }]);
    this.scope.register(["Shift"], "Enter", (evt) => {
      this.suggestions.useSelectedItem(evt);
      return false;
    });
  }
  isInFrontmatter(editor, cursor) {
    let frontmatterEnd = void 0;
    if (editor.getLine(0) === "---") {
      for (let i = 1; i <= editor.lastLine(); i++) {
        if (editor.getLine(i) === "---") {
          frontmatterEnd = i;
          break;
        }
      }
    }
    return !!frontmatterEnd && cursor.line < frontmatterEnd;
  }
  onTrigger(cursor, editor, file) {
    var _a;
    if (this.didSelect) {
      this.didSelect = false;
      return null;
    }
    if (!this.plugin.settings.isAutosuggestEnabled) {
      return null;
    }
    ;
    if ((file == null ? void 0 : file.extension) !== "md")
      return null;
    if ((_a = editor.editorComponent) == null ? void 0 : _a.table)
      return null;
    const fullLine = editor.getLine(editor.getCursor().line);
    if (fullLine.startsWith("|"))
      return null;
    this.inFrontmatter = this.isInFrontmatter(editor, cursor);
    if (this.inFrontmatter) {
      const regex = new RegExp(`^${genericFieldRegex}:(?<values>.*)`, "u");
      if (!regex.test(fullLine) && !fullLine.startsWith(listPrefix)) {
        return null;
      } else {
        const line = editor.getLine(cursor.line);
        const separatorPos = line.indexOf(":");
        if (!["", " "].includes(line.slice(separatorPos + 1, separatorPos + 2))) {
          editor.replaceRange(" ", { line: cursor.line, ch: separatorPos + 1 }, { line: cursor.line, ch: separatorPos + 1 });
        }
      }
      ;
    } else if (getLineFields(fullLine).length === 0) {
      return null;
    }
    return {
      start: cursor,
      end: cursor,
      query: editor.getLine(cursor.line)
    };
  }
  getAlias(tFile) {
    var _a, _b;
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    let alias = void 0;
    if (dvApi && ((_b = this.field) == null ? void 0 : _b.options.customRendering)) {
      alias = new Function("page", `return ${this.field.options.customRendering}`)(dvApi.page(tFile.path));
    }
    return alias;
  }
  async getSuggestions(context) {
    const suggestions = await this.getValueSuggestions(context);
    if (suggestions.length) {
      return suggestions;
    }
    return [];
  }
  async getValueSuggestions(context) {
    var _a, _b, _c, _d;
    const lineNumber = context.start.line;
    const matchField = { attribute: void 0, values: [] };
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    const splitValues = (values) => {
      return (values == null ? void 0 : values.replace(/^\[|^\s\[|^\(|^\s\(/, "").replace(/\]$|\)$/, "").split(",").map((o) => encodeLink(o.trim()))) || [""];
    };
    const getFilteredOptionsList = (field, firstValues, lastValue) => {
      var _a2;
      const fieldManager = new FieldManager[field.type](this.plugin, this.field);
      const suggestions = fieldManager.getOptionsList(dvApi.page((_a2 = this.context) == null ? void 0 : _a2.file.path)).filter((option) => {
        return this.filterOption(firstValues, lastValue, option);
      }).map((_value) => Object({ attr: field.name, value: _value }));
      return suggestions;
    };
    if (!this.inFrontmatter) {
      const lineFields = getLineFields(encodeLink(context.editor.getLine(lineNumber)));
      const position = context.editor.getCursor().ch;
      const activeLineField = lineFields.find((lineField) => lineField.index <= position && lineField.index + lineField.length >= position);
      if (activeLineField) {
        this.inSentence = activeLineField.index > 0;
        this.inFullLine = activeLineField.index === 0;
        matchField.attribute = activeLineField.attribute;
        matchField.values = splitValues(activeLineField.values);
      }
    } else {
      const fieldRegex = new RegExp(`^${genericFieldRegex}:(?<values>.+)?`, "u");
      const listItemRegex = new RegExp(`^${listPrefix}(?<values>.+)?`, "u");
      let fieldLine = lineNumber;
      while (!context.editor.getLine(fieldLine).includes(":") && fieldLine > 0)
        fieldLine = fieldLine - 1;
      const regexResult = context.editor.getRange({ line: fieldLine, ch: 0 }, context.end).match(fieldRegex);
      if (regexResult == null ? void 0 : regexResult.groups) {
        matchField.attribute = regexResult.groups.attribute;
        matchField.values = splitValues(regexResult.groups.values);
      }
      let i = 1;
      while (context.editor.getLine(fieldLine + i).startsWith(listPrefix) && fieldLine + i <= context.editor.lastLine()) {
        const regexResult2 = context.editor.getLine(fieldLine + i).match(listItemRegex);
        if (regexResult2 == null ? void 0 : regexResult2.groups)
          (_b = matchField.values) == null ? void 0 : _b.push(...splitValues(regexResult2.groups.values));
        i += 1;
      }
    }
    ;
    if (matchField.attribute) {
      const fieldName = matchField.attribute;
      this.field = (_c = this.plugin.fieldIndex.filesFields.get(context.file.path)) == null ? void 0 : _c.find((f) => f.name === fieldName);
      const valuesList = matchField.values;
      const lastValue = valuesList == null ? void 0 : valuesList.last();
      const firstValues = valuesList == null ? void 0 : valuesList.slice(0, -1);
      if (fieldName === "tags" && this.inFrontmatter) {
        return Object.keys(this.plugin.app.metadataCache.getTags()).filter((t) => lastValue ? t.contains(lastValue) : t).sort().map((tag) => Object({ attr: fieldName, value: tag.replace(/^#/, "") }));
      }
      if (this.field && ["Cycle" /* Cycle */, "Multi" /* Multi */, "Select" /* Select */].contains(this.field.type)) {
        return getFilteredOptionsList(this.field, firstValues, lastValue);
      } else if (this.field && ["File" /* File */, "MultiFile" /* MultiFile */].includes(this.field.type)) {
        const sortingMethod = new Function("a", "b", `return ${this.field.options.customSorting}`) || function(a, b) {
          return a.basename < b.basename ? -1 : 1;
        };
        const fieldManager = new FieldManager[this.field.type](this.plugin, this.field);
        const files = fieldManager.getFiles((_d = this.context) == null ? void 0 : _d.file).sort(sortingMethod);
        if (lastValue) {
          const results = files.filter((f) => {
            var _a2;
            return f.basename.toLowerCase().includes(lastValue.toLowerCase()) || ((_a2 = this.getAlias(f)) == null ? void 0 : _a2.toLowerCase().includes(lastValue.toLowerCase()));
          }).map((f) => {
            return Object({
              attr: fieldName,
              value: FileField.buildMarkDownLink(this.plugin, context.file, f.basename, void 0, this.getAlias(f))
            });
          });
          return results;
        } else {
          return files.map((f) => {
            var _a2;
            let alias = void 0;
            if (dvApi && ((_a2 = this.field) == null ? void 0 : _a2.options.customRendering)) {
              alias = new Function("page", `return ${this.field.options.customRendering}`)(dvApi.page(f.path));
            }
            return Object({ attr: fieldName, value: FileField.buildMarkDownLink(this.plugin, context.file, f.basename, void 0, alias) });
          });
        }
      } else {
        return [];
      }
    }
    ;
    return [];
  }
  renderSuggestion(suggestion, el) {
    var _a;
    el.addClass("metadata-menu");
    el.addClass("suggester");
    const [rawValue, alias] = `${suggestion.value}`.replace(/^\[\[/, "").replace(/\]\]$/, "").split("|");
    const targetFile = this.plugin.app.metadataCache.getFirstLinkpathDest(rawValue, this.context.file.path);
    const dvApi = (_a = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _a.api;
    if (dvApi && this.field && this.field.options.customRendering && targetFile) {
      if (alias) {
        const suggestionContainer = el.createDiv({ cls: "item-with-alias" });
        suggestionContainer.createDiv({ text: alias });
        const filePath = suggestionContainer.createDiv({ cls: "item-with-alias-filepath" });
        filePath.setText(rawValue);
      } else {
        el.setText(new Function("page", `return ${this.field.options.customRendering}`)(dvApi.page(targetFile.path)));
      }
    } else {
      el.setText(rawValue);
    }
  }
  async selectSuggestion(suggestion, event) {
    var _a, _b, _c, _d, _e;
    const activeView = this.plugin.app.workspace.getActiveViewOfType(import_obsidian76.MarkdownView);
    if (!activeView) {
      return;
    }
    ;
    const editor = activeView.editor;
    const activeLine = editor.getLine(this.context.start.line);
    const file = (_a = this.context) == null ? void 0 : _a.file;
    const position = ((_b = this.context) == null ? void 0 : _b.editor.getCursor().ch) || 0;
    const fieldName = suggestion.attr;
    const dvApi = (_c = this.plugin.app.plugins.plugins.dataview) == null ? void 0 : _c.api;
    const clean = (item) => {
      return item == null ? void 0 : item.replace(/\s?\,$/, "");
    };
    if (this.inFrontmatter && file) {
      try {
        let beginFieldLineNumber = this.context.start.line;
        let endFieldLineNumber = this.context.start.line;
        while (!editor.getLine(beginFieldLineNumber).startsWith(`${fieldName}:`) && beginFieldLineNumber > 0)
          beginFieldLineNumber = beginFieldLineNumber - 1;
        while (!editor.getLine(endFieldLineNumber + 1).includes(":") && !(editor.getLine(endFieldLineNumber + 1) === "---") && endFieldLineNumber + 1 <= this.context.editor.lastLine())
          endFieldLineNumber = endFieldLineNumber + 1;
        const serializedField = editor.getRange(
          { line: beginFieldLineNumber, ch: 0 },
          { line: endFieldLineNumber, ch: editor.getLine(endFieldLineNumber).length }
        );
        let parsedField2 = (0, import_obsidian76.parseYaml)(serializedField);
        let [attr, pastValues] = Object.entries(parsedField2)[0];
        let newField;
        if (this.field && this.field.getDisplay() === "asList" /* asList */) {
          const fieldManager = new FieldManager[this.field.type](this.plugin, this.field);
          const options2 = fieldManager.getOptionsList(dvApi.page((_d = this.context) == null ? void 0 : _d.file.path));
          let valuesArray = [suggestion.value];
          if (typeof pastValues == "string") {
            valuesArray = [...new Set([clean(pastValues), ...valuesArray].filter((item) => options2.includes(item)))];
          } else if (Array.isArray(pastValues)) {
            valuesArray = [...new Set([
              ...pastValues.filter((v) => !!v).map((value) => clean(value)),
              ...valuesArray
            ].filter((item) => options2.includes(item)))];
          }
          newField = `${attr}: ${valuesArray.map((value) => `
  - ${clean(value)}`).join("")}`;
        } else if (fieldName === "tags" && this.plugin.settings.frontmatterListDisplay === "asList" /* asList */) {
          let valuesArray = [suggestion.value];
          const options2 = Object.keys(this.plugin.app.metadataCache.getTags()).map((t) => t.replace(/^#/, ""));
          if (typeof pastValues == "string") {
            valuesArray = [...new Set([clean(pastValues), ...valuesArray].filter((item) => options2.includes(item)))];
          } else if (Array.isArray(pastValues)) {
            valuesArray = [...new Set([
              ...pastValues.filter((v) => !!v).map((value) => clean(value)),
              ...valuesArray
            ].filter((item) => options2.includes(item)))];
          }
          newField = `${attr}: ${valuesArray.map((value) => `
  - ${clean(value)}`).join("")}`;
        } else {
          if (!pastValues) {
            newField = attr + ": " + suggestion.value;
          } else if (typeof pastValues == "string") {
            if (!pastValues.contains(",")) {
              newField = attr + ": " + suggestion.value;
            } else {
              const pastValuesArray = pastValues.split(",").map((o) => o.trim()).slice(0, -1);
              newField = attr + ": [" + pastValuesArray.join(", ") + ", " + clean(suggestion.value) + "]";
            }
          } else if (Array.isArray(pastValues)) {
            if (activeLine.endsWith(",]") || activeLine.endsWith(", ]")) {
              newField = attr + ": [" + [...pastValues, clean(suggestion.value)].join(", ") + "]";
            } else {
              newField = attr + ": [" + [...pastValues.slice(0, -1), clean(suggestion.value)].join(", ") + "]";
            }
          } else {
            newField = attr + ": [" + [...pastValues].join(", ") + "]";
          }
        }
        editor.replaceRange(newField, { line: beginFieldLineNumber, ch: 0 }, { line: endFieldLineNumber, ch: editor.getLine(endFieldLineNumber).length });
        if (!(((_e = this.field) == null ? void 0 : _e.getDisplay()) === "asList" /* asList */) && !(fieldName === "tags" && this.plugin.settings.frontmatterListDisplay === "asList" /* asList */) && (Array.isArray(pastValues) || typeof pastValues === "string" && pastValues.contains(","))) {
          editor.setCursor({ line: beginFieldLineNumber, ch: newField.length - 1 });
        } else {
          let endFieldLineNumber2 = this.context.start.line;
          while (!editor.getLine(endFieldLineNumber2 + 1).includes(":") && !(editor.getLine(endFieldLineNumber2 + 1) === "---")) {
            editor.getLine(endFieldLineNumber2);
            endFieldLineNumber2 = endFieldLineNumber2 + 1;
          }
          editor.setCursor({ line: endFieldLineNumber2, ch: editor.getLine(endFieldLineNumber2).length });
        }
      } catch (error) {
        new import_obsidian76.Notice("Frontmatter wrongly formatted", 2e3);
        this.close();
        return;
      }
    } else if (this.inFullLine && this.field && file) {
      let cleanedLine = activeLine;
      while (![",", ":"].contains(cleanedLine.charAt(cleanedLine.length - 1))) {
        cleanedLine = cleanedLine.slice(0, -1);
      }
      editor.replaceRange(
        `${cleanedLine}${event.shiftKey ? "" : " "}` + suggestion.value,
        { line: this.context.start.line, ch: 0 },
        this.context.end
      );
    } else if (this.inSentence && this.field && file) {
      let beforeCursor = activeLine.slice(0, position);
      let afterCursor = activeLine.slice(position);
      let separatorPos = position;
      let currentValueLength = 0;
      while (!beforeCursor.endsWith("::") && !beforeCursor.endsWith(",") && beforeCursor.length) {
        separatorPos = separatorPos - 1;
        currentValueLength = currentValueLength + 1;
        beforeCursor = beforeCursor.slice(0, -1);
      }
      let nextBracketPos = position;
      while (!encodeLink(afterCursor).match("(\\]|\\)).*") && afterCursor.length) {
        nextBracketPos = nextBracketPos + 1;
        afterCursor = afterCursor.slice(nextBracketPos - position);
      }
      editor.replaceRange(
        suggestion.value,
        { line: this.context.start.line, ch: separatorPos },
        { line: this.context.start.line, ch: nextBracketPos }
      );
      editor.setCursor({ line: this.context.start.line, ch: nextBracketPos - currentValueLength + suggestion.value.length });
    }
    this.didSelect = true;
    this.close();
  }
};

// src/options/updateProps.ts
var import_obsidian77 = require("obsidian");
var updateProps = async (plugin, view) => {
  if (!(view instanceof import_obsidian77.MarkdownView) || !(view.file instanceof import_obsidian77.TFile) || view.file === void 0)
    return;
  const file = view.file;
  const optionsList = new OptionsList(plugin, file, "ManageAtCursorCommand");
  const note = new Note(plugin, file);
  await note.build();
  view.metadataEditor.rendered.forEach((item) => {
    var _a, _b, _c, _d;
    const key = item.entry.key;
    const pseudoField = {
      id: key === plugin.settings.fileClassAlias ? `fileclass-field-${plugin.settings.fileClassAlias}` : (_b = (_a = plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _a.find((_f) => _f.isRoot() && _f.name === key)) == null ? void 0 : _b.id,
      type: key === plugin.settings.fileClassAlias ? "Select" : (_d = (_c = plugin.fieldIndex.filesFields.get(file.path)) == null ? void 0 : _c.find((_f) => _f.isRoot() && _f.name === key)) == null ? void 0 : _d.type
    };
    if (!pseudoField.id || !pseudoField.type)
      return;
    const node = note.getNodeForIndexedPath(pseudoField.id);
    if (!node)
      return;
    const buttonsContainers = item.containerEl.findAll(".field-btn-container");
    buttonsContainers.forEach((container) => item.containerEl.removeChild(container));
    if (plugin.settings.enableProperties) {
      const btnContainer = item.containerEl.createDiv({ cls: "field-btn-container" });
      const btn = new import_obsidian77.ButtonComponent(btnContainer);
      btn.setIcon(FieldIcon[pseudoField.type]);
      btn.setClass("property-metadata-menu");
      btn.onClick(() => {
        optionsList ? optionsList.createAndOpenFieldModal(node) : null;
      });
      item.containerEl.insertBefore(btnContainer, item.valueEl);
    }
  });
  const actionContainer = view.metadataEditor.contentEl.find(".action-container") || view.metadataEditor.contentEl.createDiv({ cls: "action-container" });
  actionContainer.replaceChildren();
  actionContainer.appendChild(view.metadataEditor.addPropertyButtonEl);
  const fileClassButtonsContainer = view.metadataEditor.contentEl.find(".fileclass-btn-container") || view.metadataEditor.contentEl.createDiv({ cls: "fileclass-btn-container" });
  fileClassButtonsContainer.replaceChildren();
  if (!plugin.settings.enableProperties)
    return;
  const fileClasses = plugin.fieldIndex.filesFileClasses.get(file.path);
  fileClasses == null ? void 0 : fileClasses.forEach((fileClass) => {
    const addFieldButton = new import_obsidian77.ButtonComponent(fileClassButtonsContainer);
    addFieldButton.setClass("add-field-button");
    addFieldButton.setIcon(fileClass.getIcon());
    addFieldButton.onClick(() => new InsertFieldSuggestModal(plugin, file, -1, false, false).open());
  });
  actionContainer.appendChild(fileClassButtonsContainer);
};
async function updatePropertiesSection(plugin) {
  var _a, _b, _c;
  const leaves = plugin.app.workspace.getLeavesOfType("markdown");
  for (const leaf of leaves) {
    updateProps(plugin, leaf.view);
  }
  const currentView = plugin.app.workspace.getActiveViewOfType(import_obsidian77.MarkdownView);
  if (currentView && currentView.file) {
    const file = currentView.file;
    const note = new Note(plugin, file);
    await note.build();
    plugin.indexStatus.checkForUpdate(currentView);
    const focusedElement = document.querySelector(".metadata-property:focus-within");
    if (focusedElement instanceof HTMLElement) {
      const key = focusedElement.dataset.propertyKey;
      const field = key && ((_a = plugin.fieldIndex.filesFields.get(currentView.file.path)) == null ? void 0 : _a.find((_f) => _f.isRoot() && _f.name === key));
      if (field) {
        const eF = note.getExistingFieldForIndexedPath(field.id);
        (_b = focusedElement.find("[class^=metadata-input]")) == null ? void 0 : _b.setText((eF == null ? void 0 : eF.value) || "");
      } else if (key === plugin.settings.fileClassAlias) {
        const eF = note.getExistingFieldForIndexedPath(`fileclass-field-${plugin.settings.fileClassAlias}`);
        (_c = focusedElement.find("[class^=metadata-input]")) == null ? void 0 : _c.setText((eF == null ? void 0 : eF.value) || "");
      }
    }
  }
}

// src/fileClass/fileClassFolderButton.ts
var import_obsidian78 = require("obsidian");
var FileClassFolderButton = class extends import_obsidian78.Component {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.addButton();
  }
  onload() {
    this.registerEvent(
      this.plugin.app.workspace.on("layout-change", () => {
        this.addButton();
      })
    );
    this.registerEvent(
      this.plugin.app.workspace.on("metadata-menu:indexed", () => {
        this.addButton();
      })
    );
  }
  addButton() {
    var _a, _b, _c;
    const fCFolderPath = (_a = this.plugin.settings.classFilesPath) == null ? void 0 : _a.replace(/\/$/, "");
    const explorerView = (_c = (_b = this.plugin.app.workspace.getLeavesOfType("file-explorer")) == null ? void 0 : _b[0]) == null ? void 0 : _c.view;
    if (!explorerView || !fCFolderPath)
      return;
    const fCFolder = explorerView.fileItems[fCFolderPath];
    if (!fCFolder)
      return;
    const container = fCFolder.selfEl;
    const existingButtons = container.findAll(".fileClass-add-button");
    for (const btn of existingButtons)
      container.removeChild(btn);
    if (!container.findAll(".fileClass-add-button").length) {
      const addBtn = container.createDiv({ cls: "fileClass-add-button" });
      (0, import_obsidian78.setIcon)(addBtn, "plus-circle");
      addBtn.onclick = (e) => {
        e.preventDefault();
        new AddNewFileClassModal(this.plugin).open();
      };
    }
  }
  static removeBtn(plugin) {
    var _a, _b, _c;
    const fCFolderPath = (_a = plugin.settings.classFilesPath) == null ? void 0 : _a.replace(/\/$/, "");
    const explorerView = (_c = (_b = plugin.app.workspace.getLeavesOfType("file-explorer")) == null ? void 0 : _b[0]) == null ? void 0 : _c.view;
    if (!explorerView || !fCFolderPath)
      return;
    const fCFolder = explorerView.fileItems[fCFolderPath];
    if (!fCFolder)
      return;
    const container = fCFolder.selfEl;
    const existingButtons = container.findAll(".fileClass-add-button");
    for (const btn of existingButtons)
      container.removeChild(btn);
  }
};

// src/db/DatabaseManager.ts
var import_obsidian80 = require("obsidian");

// src/db/StoreManager.ts
var import_obsidian79 = require("obsidian");
var StoreManager = class extends import_obsidian79.Component {
  constructor(indexDB, storeName) {
    super();
    this.indexDB = indexDB;
    this.storeName = storeName;
    this.executeRequest = (func) => {
      const open = indexedDB.open(this.indexDB.name);
      return new Promise(async (resolve, reject) => {
        open.onsuccess = () => {
          const db = open.result;
          if ([...db.objectStoreNames].find((name) => name === this.storeName)) {
            const transaction = db.transaction(this.storeName, "readwrite");
            const store = transaction.objectStore(this.storeName);
            resolve(func(store));
          } else {
            DEBUG && console.error("store not found");
            reject();
          }
        };
        open.onerror = () => {
          DEBUG && console.error("unable to open db");
          reject();
        };
      });
    };
    this.getElement = (key) => this.executeRequest(
      (store) => new Promise((resolve, reject) => {
        let request;
        if (key === "all")
          request = store.getAll();
        else
          request = store.get(key);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
      })
    );
    this.editElement = (key, payload) => this.executeRequest(
      (store) => new Promise((resolve, reject) => {
        let request;
        if (key === "all")
          request = store.getAll();
        else
          request = store.get(key);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          const serialized = JSON.parse(JSON.stringify(payload));
          const updateRequest = store.put(serialized);
          updateRequest.onsuccess = () => resolve(request.result);
        };
      })
    );
    this.bulkEditElements = (payload) => this.executeRequest(
      (store) => new Promise((resolve, reject) => {
        let request;
        if (payload.length) {
          payload.forEach((item) => {
            request = store.get(item.id);
            request.onerror = () => {
              DEBUG && console.log("error on getting ", item.id);
              reject(request.error);
            };
            request.onsuccess = () => {
              const serialized = JSON.parse(JSON.stringify(item));
              const updateRequest = store.put(serialized);
              updateRequest.onsuccess = () => resolve(request.result);
            };
          });
        } else {
          resolve();
        }
      })
    );
    this.removeElement = (key) => this.executeRequest(
      (store) => new Promise((resolve, reject) => {
        let request;
        if (key === "all")
          request = store.clear();
        else
          request = store.delete(key);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
      })
    );
    this.bulkRemoveElements = (keys) => this.executeRequest(
      (store) => new Promise((resolve, reject) => {
        let request;
        if (keys.length) {
          keys.forEach((key) => {
            request = store.get(key);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
              const delRequest = store.delete(key);
              delRequest.onsuccess = () => resolve();
            };
          });
        } else {
          resolve();
        }
      })
    );
  }
};

// src/db/stores/fileClassViews.ts
var FileClassViewStore = class extends StoreManager {
  constructor(indexDB) {
    super(indexDB, "fileClassView");
    this.indexDB = indexDB;
  }
};

// src/db/DatabaseManager.ts
var INDEXES = {
  fileClassView: [
    { name: "fileClassView", fields: "fileClassName", unique: true }
  ]
};
var IndexDatabase = class extends import_obsidian80.Component {
  constructor(plugin) {
    super();
    this.plugin = plugin;
    this.init();
    this.buildStores();
  }
  onload() {
  }
  init() {
    DEBUG && console.log("create or open db");
    this.name = `metadata_menu_${this.plugin.app.appId || this.plugin.app.vault.adapter.basePath || this.plugin.app.vault.getName()}`;
    if (!this.name)
      return;
    const request = indexedDB.open(this.name, 2);
    request.onerror = (err) => {
      console.error(`IndexedDB error: ${request.error}`, err);
    };
    request.onsuccess = () => {
      const db = request.result;
    };
    request.onupgradeneeded = () => {
      const db = request.result;
      Object.keys(INDEXES).forEach((storeName) => {
        const storeIndexes = INDEXES[storeName];
        const store = db.createObjectStore(storeName, { keyPath: "id" });
        const indexes = [{ name: "id", fields: "id", unique: true }, ...storeIndexes];
        indexes.forEach((index) => store.createIndex(index.name, index.fields, { unique: index.unique }));
      });
    };
  }
  buildStores() {
    this.fileClassViews = this.addChild(new FileClassViewStore(this));
  }
  onunload() {
  }
};

// src/components/FileClassCodeBlockManager.ts
var import_obsidian81 = require("obsidian");

// src/fileClass/views/fileClassCodeBlockView.ts
var FileClassCodeBlockView = class {
  constructor(manager, tableId, fileClass, paginationContainer, tableContainer, selectedView, ctx, children = []) {
    this.manager = manager;
    this.tableId = tableId;
    this.fileClass = fileClass;
    this.paginationContainer = paginationContainer;
    this.tableContainer = tableContainer;
    this.selectedView = selectedView;
    this.ctx = ctx;
    this.children = children;
    this.plugin = this.manager.plugin;
    this.viewConfiguration = this.getViewConfig();
    this.fileClassDataviewTable = new FileClassDataviewTable(this.viewConfiguration, this, fileClass);
  }
  getViewConfig() {
    var _a, _b;
    const options2 = this.fileClass.getFileClassOptions();
    const columns = [{
      id: "file",
      name: "file",
      hidden: false,
      position: 0
    }];
    const fields = ((_a = this.plugin.fieldIndex.fileClassesFields.get(this.fileClass.name)) == null ? void 0 : _a.filter((f) => f.isRoot())) || [];
    for (const [_index, f] of fields.entries()) {
      columns.push({
        id: `${this.fileClass.name}____${f.name}`,
        name: f.name,
        hidden: false,
        position: _index + 1
      });
    }
    const defaultConfig = {
      children: [],
      filters: [],
      sorters: [],
      columns
    };
    const partialViewConfig = ((_b = options2.savedViews) == null ? void 0 : _b.find((view) => view.name === this.selectedView)) || defaultConfig;
    return {
      children: partialViewConfig.children || [],
      filters: partialViewConfig.filters,
      sorters: partialViewConfig.sorters,
      columns: partialViewConfig.columns
    };
  }
  update(maxRows, sliceStart = 0) {
    this.fileClassDataviewTable = new FileClassDataviewTable(
      this.viewConfiguration,
      this,
      this.fileClass,
      maxRows,
      sliceStart,
      this.ctx
    );
    this.fileClassDataviewTable.buildTable(this.tableContainer);
    this.fileClassDataviewTable.buildPaginationManager(this.paginationContainer);
  }
};

// src/components/FileClassCodeBlockManager.ts
var FileClassCodeBlockManager = class extends import_obsidian81.MarkdownRenderChild {
  constructor(plugin, containerEl, source, ctx) {
    super(containerEl);
    this.plugin = plugin;
    this.containerEl = containerEl;
    this.source = source;
    this.ctx = ctx;
    this.isLoaded = false;
    this.showAddField = false;
  }
  build() {
    var _a;
    const el = this.containerEl;
    const source = this.source;
    el.replaceChildren();
    el.addClass("metadata-menu");
    el.addClass("fileclass-codeblock-view");
    const container = el.createDiv({ cls: "fv-table" });
    const header = container.createDiv({ cls: "options" });
    const paginationContainer = header.createDiv({ cls: "pagination" });
    this.tableId = `table-container-${Math.floor(Date.now())}`;
    const tableContainer = container.createDiv({ attr: { id: this.tableId } });
    container.createDiv();
    try {
      const content = (0, import_obsidian81.parseYaml)(source);
      const fileClassName = content[this.plugin.settings.fileClassAlias];
      const selectedView = (_a = content.view) == null ? void 0 : _a.toString();
      this.fileClass = this.plugin.fieldIndex.fileClassesName.get(fileClassName);
      if (this.fileClass) {
        this.itemsPerPage = content["files per page"] || this.fileClass.options.limit || this.plugin.settings.tableViewMaxRecords;
        this.startAtItem = content["start"] || 0;
        this.showAddField = content["showAddField"] === true || false;
        this.fileClassCodeBlockView = new FileClassCodeBlockView(this, this.tableId, this.fileClass, paginationContainer, tableContainer, selectedView, this.ctx);
        this.fileClassCodeBlockView.fileClassDataviewTable.limit = this.itemsPerPage;
        this.plugin.registerMarkdownPostProcessor((el2, ctx) => {
          this.fileClassCodeBlockView.fileClassDataviewTable.buidFileClassViewBtn();
        });
        this.fileClassCodeBlockView.update(this.itemsPerPage, this.startAtItem);
        this.isLoaded = true;
      } else {
        el.setText(`${fileClassName} isn't a proper fileclass`);
      }
    } catch (e) {
      el.setText(e);
    }
  }
  onload() {
    this.build();
  }
  onunload() {
    this.plugin.codeBlockListManager.removeChild(this);
  }
};

// src/components/FileClassCodeBlockListManager.ts
var import_obsidian82 = require("obsidian");
var FileClassCodeBlockListManager = class extends import_obsidian82.Component {
  constructor(plugin) {
    super();
  }
};

// main.ts
var MetadataMenu = class extends import_obsidian83.Plugin {
  constructor() {
    super(...arguments);
    this.presetFields = [];
    this.initialFileClassQueries = [];
    this.launched = false;
  }
  async onload() {
    console.log("+------ Metadata Menu loaded --------+");
    this.register(() => delete window.DEBUG);
    this.indexName = `metadata_menu_${this.app.appId || this.app.vault.adapter.basePath || this.app.vault.getName()}`;
    (window["MetadataMenuAPI"] = this.api) && this.register(() => delete window["MetadataMenuAPI"]);
    (window["MetadataMenu"] = this) && this.register(() => delete window["MetadataMenu"]);
    if (!this.app.plugins.enabledPlugins.has("dataview") || //@ts-ignore
    this.app.plugins.plugins["dataview"] && !this.app.plugins.plugins["dataview"].settings.enableDataviewJs) {
      new import_obsidian83.Notice(
        `------------------------------------------
(!) INFO (!) 
Install and enable dataview and dataviewJS for extra Metadata Menu features
------------------------------------------`,
        6e4
      );
    }
    await this.loadSettings();
    await migrateSettings(this);
    this.indexStatus = this.addChild(new IndexStatus(this));
    if (this.settings.showIndexingStatusInStatusBar)
      this.indexStatus.load();
    this.codeBlockListManager = this.addChild(new FileClassCodeBlockListManager(this));
    this.fieldIndex = this.addChild(new FieldIndex(this));
    this.contextMenu = this.addChild(new ContextMenu(this));
    this.settings.presetFields.forEach((prop) => {
      const property = new Field_default(this);
      Object.assign(property, prop);
      this.presetFields.push(property);
    });
    this.settings.fileClassQueries.forEach((query) => {
      const fileClassQuery = new FileClassQuery_default();
      Object.assign(fileClassQuery, query);
      this.initialFileClassQueries.push(fileClassQuery);
    });
    this.addSettingTab(new MetadataMenuSettingTab(this));
    this.api = new MetadataMenuApi(this).make();
    this.registerEvent(
      this.app.vault.on("create", (file) => {
        if (!this.fieldIndex.fileClassesName.size)
          return;
        if (file instanceof import_obsidian83.TFile && this.settings.chooseFileClassAtFileCreation) {
          const modal = new AddFileClassToFileModal(this, file);
          modal.open();
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf)
          this.indexStatus.checkForUpdate(leaf.view);
      })
    );
    this.registerEvent(
      this.app.workspace.on("metadata-menu:indexed", () => {
        this.indexStatus.setState("indexed");
        const currentView = this.app.workspace.getActiveViewOfType(import_obsidian83.MarkdownView);
        if (currentView)
          this.indexStatus.checkForUpdate(currentView);
        updatePropertiesSection(this);
        FileClassViewManager.reloadViews(this);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", (file) => {
        updatePropertiesSection(this);
      })
    );
    this.indexDB = this.addChild(new IndexDatabase(this));
    await this.fieldIndex.fullIndex();
    this.extraButton = this.addChild(new ExtraButton(this));
    if (this.settings.enableFileExplorer)
      this.addChild(new FileClassFolderButton(this));
    this.registerEditorSuggest(new ValueSuggest(this));
    this.launched = true;
    addCommands(this);
    this.registerMarkdownCodeBlockProcessor("mdm", async (source, el, ctx) => {
      const fileClassCodeBlockManager = new FileClassCodeBlockManager(this, el, source, ctx);
      this.codeBlockListManager.addChild(fileClassCodeBlockManager);
      ctx.addChild(fileClassCodeBlockManager);
    });
    this.app.workspace.trigger("layout-change");
  }
  /*
  ------------
  Settings
  ------------
  */
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    this.settings.presetFields = this.presetFields.map((_field) => {
      const { plugin, ...field } = _field;
      return field;
    });
    this.settings.fileClassQueries = this.initialFileClassQueries;
    await this.saveData(this.settings);
    await this.fieldIndex.fullIndex();
  }
  onunload() {
    console.log("x------ Metadata Menu unloaded ------x");
    FileClassFolderButton.removeBtn(this);
  }
};
